<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://pytorch.org/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://pytorch.org/" rel="alternate" type="text/html" />
  <updated>2025-01-24T09:44:25-08:00</updated>
  <id>https://pytorch.org/feed.xml</id>

  
  
  

  
    <title type="html">PyTorch Website</title>
  

  
    <subtitle>Scientific Computing...</subtitle>
  

  
    <author>
        <name>Facebook</name>
      
      
    </author>
  

  
  
  
    <entry>
      <title type="html">How Intel Uses PyTorch to Empower Generative AI through Intel Arc GPUs</title>
      <link href="https://pytorch.org/blog/how-intel-uses-pytorch-to-empower-generative-ai-through-intel-arc-gpus/" rel="alternate" type="text/html" title="How Intel Uses PyTorch to Empower Generative AI through Intel Arc GPUs" />
      <published>2025-01-24T00:00:00-08:00</published>
      <updated>2025-01-24T00:00:00-08:00</updated>
      <id>https://pytorch.org/blog/how-intel-uses-pytorch-to-empower-generative-ai-through-intel-arc-gpus</id>
      <content type="html" xml:base="https://pytorch.org/blog/how-intel-uses-pytorch-to-empower-generative-ai-through-intel-arc-gpus/">&lt;p&gt;Intel has long been at the forefront of technological innovation, and its recent venture into Generative AI (GenAI) solutions is no exception. With the rise of AI-powered gaming experiences, Intel sought to deliver an accessible and intuitive GenAI inferencing solution tailored for AI PCs powered by Intel’s latest GPUs. By leveraging PyTorch as the backbone for development efforts, Intel successfully launched AI Playground, an open source application that showcases advanced GenAI workloads.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The Business Challenge&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Our goal was to deliver an accessible and intuitive GenAI inferencing solution tailored for AI PCs powered by Intel. We recognized the need to showcase the capabilities of the latest GenAI workloads on our newest line of client GPUs. To address this, we developed a starter application, &lt;a href=&quot;https://github.com/intel/ai-playground&quot;&gt;AI Playground&lt;/a&gt;, which is open source and includes a comprehensive developer reference sample available on GitHub using PyTorch. This application seamlessly integrates image generation, image enhancement, and chatbot functionalities, using retrieval-augmented generation (RAG) features, all within a single, user-friendly installation package. This initiative not only demonstrates the functionality of these AI workloads but also serves as an educational resource for the ecosystem, guiding developers on effectively leveraging the &lt;a href=&quot;https://www.intel.com/content/www/us/en/products/details/discrete-gpus/arc.html&quot;&gt;Intel® Arc™ GPU&lt;/a&gt; product line for advanced AI applications. This solution leverages Intel® Arc™ Xe Cores and &lt;a href=&quot;https://www.intel.com/content/www/us/en/support/articles/000091112/graphics.html&quot;&gt;Xe Matrix Extensions (XMX)&lt;/a&gt; for accelerating inferencing.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/intel-case-study/fg1.png&quot; alt=&quot;AI Playground&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How Intel Used PyTorch&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;PyTorch is the core AI framework for AI Playground. We extensively leverage PyTorch’s eager mode, which aligns perfectly with the dynamic and iterative nature of our generative models. This approach not only enhances our development workflow but also enables us to rapidly prototype and iterate on advanced AI features. By harnessing PyTorch’s powerful capabilities, we have created a robust reference sample that showcases the potential of GenAI on Intel GPUs in one cohesive application.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Solving AI Challenges with PyTorch&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;PyTorch has been instrumental in addressing our AI challenges by providing a robust training and inference framework optimized for discrete and integrated Intel Arc GPU product lines. Choosing PyTorch over alternative frameworks or APIs was crucial. Other options would have necessitated additional custom development or one-off solutions, which could have significantly slowed our time to market and limited our feature set. With PyTorch, we leveraged its flexibility and ease of use, allowing our team to focus on innovation through experimentation, rather than infrastructure. The integration of &lt;a href=&quot;https://www.intel.com/content/www/us/en/developer/tools/oneapi/optimization-for-pytorch.html#gs.j6azz7&quot;&gt;Intel® Extension for PyTorch&lt;/a&gt; further enhanced performance by optimizing computational efficiency and enabling seamless scaling on Intel hardware, ensuring that our application ran faster and more efficiently.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A Word from Intel&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;With PyTorch as the backbone of our AI Playground project, we achieved rapid development cycles that significantly accelerated our time to market. This flexibility enabled us to iteratively enhance features and effectively align with the commitments of our hardware launches in 2024.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;-Bob Duffy, AI Playground Product Manager&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/intel-case-study/fg2.png&quot; alt=&quot;PyTorch Case Stidu&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The Benefits of Using PyTorch&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The biggest benefit of using PyTorch for us is the large PyTorch ecosystem, which connects us with an active and cooperative community of developers. This collaboration has facilitated the seamless deployment of key features from existing open source projects, allowing us to integrate the latest GenAI capabilities into AI Playground. Remarkably, we accomplished this with minimal re-coding, ensuring that these advanced features are readily accessible on Intel Arc GPUs.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Learn More&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;For more information about Intel’s AI Playground and collaboration with PyTorch, visit the following links:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.intel.com/content/www/us/en/developer/tools/oneapi/optimization-for-pytorch.html#gs.j8h6mc&quot;&gt;PyTorch Optimizations from Intel&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/intel/ai-playground&quot;&gt;AI Playground GitHub&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://intel.com/ai-playground&quot;&gt;AI Playground&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://youtu.be/cYPZye1MC6U&quot;&gt;AI Playground Deep Dive Video&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://pytorch.org/blog/intel-gpu-support-pytorch-2-5/&quot;&gt;Intel GPU Support Now Available in PyTorch 2.5&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>Team PyTorch</name>
        
        
      </author>

      

      

      
        <summary type="html">Intel has long been at the forefront of technological innovation, and its recent venture into Generative AI (GenAI) solutions is no exception. With the rise of AI-powered gaming experiences, Intel sought to deliver an accessible and intuitive GenAI inferencing solution tailored for AI PCs powered by Intel’s latest GPUs. By leveraging PyTorch as the backbone for development efforts, Intel successfully launched AI Playground, an open source application that showcases advanced GenAI workloads.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Bringing the PyTorch Community Together</title>
      <link href="https://pytorch.org/blog/bringing-the-pytorch-community-together/" rel="alternate" type="text/html" title="Bringing the PyTorch Community Together" />
      <published>2025-01-22T00:00:00-08:00</published>
      <updated>2025-01-22T00:00:00-08:00</updated>
      <id>https://pytorch.org/blog/bringing-the-pytorch-community-together</id>
      <content type="html" xml:base="https://pytorch.org/blog/bringing-the-pytorch-community-together/">&lt;p&gt;As we step into a new year, it’s a great moment to reflect on the incredible community events that made 2024 a memorable year for the PyTorch Foundation. Global meetups, events, and conferences brought the community together to learn, connect, and grow. Here’s a quick recap of the year’s highlights and what to expect in 2025.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/community-events-recap/fg5.jpg&quot; alt=&quot;PyTorch Seattle Meetup (May 23)&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PyTorch Seattle Meetup (May 23)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We hosted a PyTorch Meetup in Seattle in May at the Meta Bellevue Office where Meta, Microsoft, and Google gave technical talks and about 60 attendees participated in discussion and networking.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PyTorch Docathon 2024 (June 4-20)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The PyTorch Docathon returned for its third edition, spanning over two weeks in June. This unique event focused on improving PyTorch’s documentation with contributions from community members worldwide. Documentation is the backbone of any successful open source project, and PyTorch’s Docathon fostered inclusivity and collaboration, making it easier for new users to adopt the framework and for experienced developers to maximize its potential. The 2024 Docathon resulted in more than 50 merged pull requests and was a testament to the collaborative spirit of the PyTorch community and its commitment to enhancing accessibility and usability. Watch the &lt;a href=&quot;https://youtu.be/2D0aej50umA?feature=shared&quot;&gt;PyTorch Docathon Kickoff&lt;/a&gt; on YouTube.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/community-events-recap/fg3.png&quot; alt=&quot;PyTorch Shanghai Meetup (August 15)&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;pytorch-shanghai-meetup-august-15&quot;&gt;&lt;strong&gt;PyTorch Shanghai Meetup (August 15)&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;In August, the &lt;a href=&quot;https://pytorch.org/blog/pytorch-shanghai-notes/&quot;&gt;PyTorch Shanghai Meetup&lt;/a&gt; brought together developers, researchers, and enthusiasts in Shanghai, China. This event served as a platform for knowledge sharing, with engaging talks and networking opportunities. Highlights from the agenda included insights into PyTorch’s latest developments, community-led presentations showcasing innovative use cases, and networking sessions fostering collaboration among attendees.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/community-events-recap/fg1.jpg&quot; alt=&quot;PyTorch Conference 2024 (September 18-19)&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;pytorch-conference-2024-september-18-19&quot;&gt;&lt;strong&gt;PyTorch Conference 2024 (September 18-19)&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;The PyTorch Conference in San Francisco was undoubtedly one of the year’s most significant events. This two-day gathering brought together top-tier researchers, developers, and academic communities, fostering collaboration and innovation in machine learning.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/community-events-recap/fg6.jpeg&quot; alt=&quot;What Made It Special&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;what-made-it-special&quot;&gt;&lt;strong&gt;What Made It Special:&lt;/strong&gt;&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Keynote speeches from industry leaders and PyTorch maintainers.&lt;/li&gt;
  &lt;li&gt;In-depth sessions covering PyTorch’s end-to-end machine learning capabilities.&lt;/li&gt;
  &lt;li&gt;Hands-on workshops and breakout sessions.&lt;/li&gt;
  &lt;li&gt;A vibrant expo area showcasing cutting-edge tools and applications.&lt;/li&gt;
  &lt;li&gt;Startup Showcase where early-stage founders pitched their AI startups to a panel of top venture capitalists.&lt;/li&gt;
  &lt;li&gt;DL Compiler Mini-Summit that took a deep dive into the advances in deep learning (DL) compilers that are transforming AI workloads.&lt;/li&gt;
  &lt;li&gt;Fine-Tuning Mini-Summit that covered everything from memory efficiency, parameter-efficient fine-tuning and quantization to performance at scale and reproducible evaluations.&lt;/li&gt;
  &lt;li&gt;Poster Session showcasing innovations in PyTorch, including model optimization, hardware integration, generative AI, quantization, and tools for enhanced performance and usability, with contributions from industry leaders.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The conference’s focus on fostering collaboration underscored PyTorch’s role as a driving force in the open source ML community. Missed out? You can watch the &lt;a href=&quot;https://youtube.com/playlist?list=PL_lsbAsL_o2B_znuvm-pDtV_cRhpqZb8l&amp;amp;si=mdoSkqMJYKRlzxlg&quot;&gt;PyTorch Conference 2024 Playlist&lt;/a&gt; to catch any sessions you might have missed.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/community-events-recap/fg4.jpg&quot; alt=&quot;GPU MODE IRL Hackathon (September 21)&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;gpu-mode-irl-hackathon-september-21&quot;&gt;&lt;strong&gt;GPU MODE IRL Hackathon (September 21)&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;PyTorch sponsored this meetup in person in San Francisco where attendees made friends, watched keynotes, hacked all day, took breaks with afternoon talks, and then hacked all night. We heard about torchao, our new quantization and sparsity library, vLLM which deploys PyTorch models in production, llm.c, and more. Key takeaways included: GPU Mode IRL Hackathon 1st place winner was inspired by PyTorch FlexAttention to improve CUTLASS, NCCL in Triton would help us do distributed programming with a minimal NCCL reimplementation in pure Python, No libtorch pytorch binaries dramatically reduces binary sizes for on device deployments.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/community-events-recap/fg8.png&quot; alt=&quot;Consumer AI Edge Hackathon (November 22-23)&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;consumer-ai-edge-hackathon-november-22-23&quot;&gt;&lt;strong&gt;Consumer AI Edge Hackathon (November 22-23)&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;The PyTorch team served as mentors and coaches in a Hackathon in Paris, co-sponsored by Hugging Face, Scaleway, and Entrepreneur First, challenging teams to create innovative consumer (B2C) applications leveraging Hugging Face, PyTorch and other open source on-device tools and models. 120+ people across 22 teams hacked for 2 days (and nights!) building the future of AI-powered on-device solutions based on open source models and tools. Participants created innovative applications,  powered by PyTorch, &lt;a href=&quot;https://github.com/pytorch/executorch/tree/main&quot;&gt;ExecuTorch&lt;/a&gt; and Hugging Face resources, such as an on-device yoga coach, a magical storytelling companion and a Kinect-like experience to mobile phones. The PyTorch team is planning similar events in other geographies in 2025 around innovative on-device AI applications.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/community-events-recap/fg9.png&quot; alt=&quot;PyTorch Korea User Group Meetup (November 30)&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;pytorch-korea-user-group-meetup-november-30&quot;&gt;&lt;strong&gt;PyTorch Korea User Group Meetup (November 30)&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;The PyTorch Korea User Group, founded in 2018, is a community dedicated to introducing PyTorch to Korean-speaking users and growing together. The group began by translating PyTorch 0.3 tutorials into Korean and has since supported PyTorch’s growth in Korea. The group focuses on three primary activities:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Sharing knowledge for PyTorch learning and application,&lt;/li&gt;
  &lt;li&gt;Sharing insights and experiences in the field of artificial intelligence, and&lt;/li&gt;
  &lt;li&gt;Fostering growth through online and offline networking.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The PyTorch Korea User Group reaches tens of thousands of Korean AI developers every month. If you’re interested in their activities, check out these links:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://pytorch.kr&quot;&gt;PyTorch Korea User Group&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://tutorials.pytorch.kr&quot;&gt;PyTorch Korean Tutorials&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://discuss.pytorch.kr&quot;&gt;PyTorch Korean Community&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/PyTorchKorea&quot;&gt;GitHub Repository&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://youtube.com/@pytorchkr&quot;&gt;YouTube Channel&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/community-events-recap/fg2.jpeg&quot; alt=&quot;PyTorch Korea User Group 2025 Events Overview&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The PyTorch Korea User Group has planned three major activities for the year:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;PyTorch CoreSIG&lt;/strong&gt;&lt;br /&gt;
Since December 2024, this weekly online event has been held every Wednesday afternoon. Led by Kim Hong-Seok, CSO of Rebellions (a PyTorch member company), it provides in-depth knowledge and experience regarding PyTorch internals. Approximately 150 Korean developers participate weekly, reflecting growing interest in PyTorch Core development in Korea.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Offline Meetup&lt;/strong&gt;&lt;br /&gt;
These meetups provide opportunities to share insights and experiences in PyTorch and artificial intelligence, along with networking. Around 3–4 sessions are planned for this year, focusing on key topics in PyTorch and AI.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Online Community Engagement&lt;/strong&gt;&lt;br /&gt;
This activity involves sharing and discussing various projects and papers in the AI field. For more information, visit: &lt;a href=&quot;https://discuss.pytorch.kr&quot;&gt;https://discuss.pytorch.kr&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;open-source-ai-night-at-neurips-2024-december-10&quot;&gt;&lt;strong&gt;Open Source AI Night at NeurIPS 2024 (December 10)&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;The PyTorch Foundation co-hosted a social event at NeurIPS along with The Fin AI and Open Finance Foundation that featured engaging discussions on open source AI and applications in finance.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/community-events-recap/fg7.jpeg&quot; alt=&quot;PyTorch Webinars&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PyTorch Webinars&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Throughout 2024, PyTorch hosted the following virtual webinars:&lt;/p&gt;

&lt;p&gt;Expert Exchanges:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/live/HTcnp9NEHGY?feature=shared&quot;&gt;How does batching work on modern CPUs?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/live/Bh-jlh5vlF0?feature=shared&quot;&gt;DistServe: disaggregating prefill and decoding for goodput-optimized LLM inference&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/live/RnM84Sv9WpA?feature=shared&quot;&gt;Efficient Streaming Language Models with Attention Sinks&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/live/e1qUJFAo10s?feature=shared&quot;&gt;Adapting open source models with Open-Instruct and Tulu&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/live/Eqg0VIiWrgM?feature=shared&quot;&gt;Efficient Generative Models: From Sparse to Distributed Inference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Summer Series:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://youtu.be/xf2QgioY370?feature=shared&quot;&gt;Using PyTorch for Monocular Depth Estimation Webinar&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://youtu.be/NeHIhQWewug?feature=shared&quot;&gt;Accelerating LLM family of models on Arm Neoverse based Graviton AWS processors with KleidiAI&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/live/rew5CSUaIXg?feature=shared&quot;&gt;torch.compile: The Missing Manual&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Release Live Q&amp;amp;As:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/live/ry_QgUIYX1E?feature=shared&quot;&gt;PyTorch 2.4: Live Q&amp;amp;A&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/live/B3IgXpl4xt4?feature=shared&quot;&gt;PyTorch 2.5 Live Q&amp;amp;A&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Live Webinars:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=EjgTv6aSeqk&quot;&gt;PyTorch Documentary Virtual Premiere&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=gSC_IHyx0IM&quot;&gt;Using PyTorch to Help Predict Wildfires&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=zvk3Rr-OjU0&quot;&gt;Seismic Data to Subsurface Models with OpenFWI: Training an AI Model with PyTorch&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=w4JmPkqnD0E&quot;&gt;Dinosaur Bone Hunting with Intel AI&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Each of these events underscored the importance of collaboration and community engagement in advancing AI research and applications. Thank you to everyone who participated, organized, and supported these events—your contributions make all the difference!&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;looking-ahead&quot;&gt;&lt;strong&gt;Looking Ahead&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;2024 was packed with opportunities to connect, learn, and contribute, and there will be even more ways to connect with the PyTorch community in 2025.&lt;/p&gt;

&lt;p&gt;Mark your calendar! The &lt;a href=&quot;https://events.linuxfoundation.org/pytorch-conference-2025/&quot;&gt;PyTorch Conference&lt;/a&gt; is returning to San Francisco on October 22-23, 2025. Get ready for an exciting event filled with technical deep dives, exciting announcements, insightful sessions, and enhanced opportunities for community collaboration.&lt;/p&gt;

&lt;p&gt;Stay tuned for more upcoming events and opportunities to get involved by &lt;a href=&quot;https://pytorch.org/newsletter&quot;&gt;subscribing to our newsletter&lt;/a&gt;.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Team PyTorch</name>
        
        
      </author>

      

      

      
        <summary type="html">As we step into a new year, it’s a great moment to reflect on the incredible community events that made 2024 a memorable year for the PyTorch Foundation. Global meetups, events, and conferences brought the community together to learn, connect, and grow. Here’s a quick recap of the year’s highlights and what to expect in 2025.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Accelerating LLM Inference with GemLite, TorchAO and SGLang</title>
      <link href="https://pytorch.org/blog/accelerating-llm-inference/" rel="alternate" type="text/html" title="Accelerating LLM Inference with GemLite, TorchAO and SGLang" />
      <published>2025-01-21T00:00:00-08:00</published>
      <updated>2025-01-21T00:00:00-08:00</updated>
      <id>https://pytorch.org/blog/accelerating-llm-inference</id>
      <content type="html" xml:base="https://pytorch.org/blog/accelerating-llm-inference/">&lt;p&gt;Large Language Models (LLMs) are typically very resource-intensive, requiring significant amounts of memory, compute and power to operate effectively. Quantization provides a solution by reducing weights and activations from 16 bit floats to lower bitrates (e.g., 8 bit, 4 bit, 2 bit), achieving significant speedup and memory savings and also enables support for larger batch sizes.&lt;/p&gt;

&lt;p&gt;Existing solutions for low precision inference work well for small batch sizes, but suffer from following issues:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Performance drops when we increase the batch size&lt;/li&gt;
  &lt;li&gt;Restrictions on types of quantization, for example, some kernels only support symmetric quantization that could have implications on accuracy of the model at lower bits&lt;/li&gt;
  &lt;li&gt;Interplay between quantization, serialization, and tensor parallelism (TP) makes it difficult to load quantized models and requires changes to user models&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To address these challenges, we created an end-to-end, performant, modular and extensible low-precision inference solution integrating the following libraries:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/mobiusml/gemlite&quot;&gt;GemLite&lt;/a&gt;, a Triton kernel library, tackles the performance limitations of large batch sizes and restrictions on the types of quantization&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/pytorch/ao&quot;&gt;TorchAO&lt;/a&gt;, a PyTorch-native library, provides a streamlined experience for quantization, sparsity, and tensor parallelism (with DTensor)&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/sgl-project/sglang&quot;&gt;SGLang&lt;/a&gt;, a fast, efficient and hackable serving framework for Large Language Model (LLM) and Vision Language Models (VLM) with extensive model support&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you’re interested in trying this out in SGLang, please follow these &lt;a href=&quot;#repro-instructions&quot;&gt;repro instructions&lt;/a&gt;. For the rest of the blog, we’ll walk through relevant details for GemLite, TorchAO and SGlang both in terms of the design of the library itself and integration in addressing the problems we mentioned above, in the end we’ll present the benchmarking results on Llama 3.1-8B model across different batch sizes and tensor parallel sizes.&lt;/p&gt;

&lt;h2 id=&quot;1-teaser-of-results&quot;&gt;1. Teaser of Results&lt;/h2&gt;

&lt;p&gt;Following is a summary of the results in 8xH100 machine on Llama 3.1-8B for decode. For all experiments, the baseline is bfloat16 torch.compiled model:&lt;/p&gt;

&lt;table class=&quot;table table-bordered&quot;&gt;
  &lt;tr&gt;
   &lt;td&gt;
   &lt;/td&gt;
   &lt;td&gt;bfloat16 w/ torch.compile
   &lt;/td&gt;
   &lt;td&gt;int4 weight only quantization, group size 64
   &lt;/td&gt;
   &lt;td&gt;float8 per row dynamic quantization
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;Batch size 1, TP size 1
   &lt;/td&gt;
   &lt;td&gt;131 tokens/sec
   &lt;/td&gt;
   &lt;td&gt;255 tokens/sec (1.95x speedup)
   &lt;/td&gt;
   &lt;td&gt;166 tokens/sec (1.27x speedup)
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;Batch size 32, TP size 1
   &lt;/td&gt;
   &lt;td&gt;2799 tokens/sec
   &lt;/td&gt;
   &lt;td&gt;3241 tokens/sec (1.16x speedup)
   &lt;/td&gt;
   &lt;td&gt;3586 tokens/sec (1.28x speedup)
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;Batch size 32, TP size 4
   &lt;/td&gt;
   &lt;td&gt;5575 tokens/sec
   &lt;/td&gt;
   &lt;td&gt;6334 tokens/sec (1.14x speedup)
   &lt;/td&gt;
   &lt;td&gt;6159 tokens/sec (1.10x speedup)
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;Our solution supports NVIDIA GPUs, including H100 and A100, and achieves speedup over the compiled bfloat16 baseline across batch sizes and TP sizes for both int4 weight only (from 1.14x to 1.95x) and float8 dynamic quantization (from 1.10x to 1.28x). Note that quantization may have a small impact on accuracy, which is outside the scope of this blogpost. Our int4 weight-only quantization is compatible with accuracy preserving techniques like HQQ. Please refer to &lt;a href=&quot;https://github.com/pytorch/ao/blob/main/torchao/quantization/README.md#cuda-backend-1&quot;&gt;TorchAO’s README&lt;/a&gt;, &lt;a href=&quot;https://huggingface.co/mobiuslabsgmbh/Llama-3.1-8b-instruct_4bitgs64_hqq_calib&quot;&gt;this benchmark&lt;/a&gt;, and &lt;a href=&quot;https://neuralmagic.com/blog/we-ran-over-half-a-million-evaluations-on-quantized-llms-heres-what-we-found/&quot;&gt;this blog&lt;/a&gt; for more information.&lt;/p&gt;

&lt;h2 id=&quot;2-gemlite-kernel-development&quot;&gt;2. GemLite: Kernel Development&lt;/h2&gt;

&lt;p&gt;The kernels were developed as part of GemLite, a project dedicated to optimizing low-bit matrix multiplication kernels. Developed using Triton, GemLite provides highly flexible and performant solutions across various activations, bitrates and hardware. In a nutshell, the kernels offer:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Support for various activation data types:  fp16, int8 and fp8&lt;/li&gt;
  &lt;li&gt;Compatibility: works seamlessly with non-packed (e.g., int8, fp8) and packed formats (e.g., uint4, uint2, uint1)&lt;/li&gt;
  &lt;li&gt;Performance Optimization: includes optimized kernels and autotuning tools to achieve high performance across different hardware and batch sizes&lt;/li&gt;
  &lt;li&gt;Integration: Compatible with torch.compile and CUDA graphs, ensuring support for advanced features like tensor parallelism&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;kernel-selection&quot;&gt;Kernel Selection&lt;/h3&gt;

&lt;p&gt;Optimizing kernel selection for large language model (LLM) generation requires addressing the distinct needs of different batch sizes. LLM workloads involve a mix of compute-bound and memory-bound iterations: smaller batch sizes are memory-bound, while larger batch sizes become compute-bound. GemLite kernels are designed to adapt to these varying demands, ensuring optimal execution for each scenario.&lt;/p&gt;

&lt;p&gt;In memory-bound scenarios, where data transfer is the limiting factor, the processor often waits for data to be fetched, leading to underutilized computational resources. For batch size = 1, a GEMV kernel performs best, whereas for larger batch sizes, GEMM kernels are more efficient. For batch sizes between 2 and 64, when matrices are “skinny,” a GEMM-SPLITK kernel is used to enable better GPU utilization (&lt;a href=&quot;https://arxiv.org/abs/2402.00025&quot;&gt;arXiv&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;GemLite includes the following kernels optimized for each of these scenarios:&lt;/p&gt;

&lt;h3 id=&quot;single-sample-inference&quot;&gt;Single Sample Inference&lt;/h3&gt;

&lt;p&gt;For single-sample inferences, we use GEMV kernels. However, asymmetric quantization methods require additional metadata, such as scales and zero points, to be loaded for each block. This can lead to increased memory transfer, so careful handling is essential.&lt;/p&gt;

&lt;p&gt;Specifically, for packed data, our experiments indicate that loading scales and zero points only once per two consecutive blocks minimizes redundant operations. Since these blocks share the same metadata, this approach results in:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;5–8% end-to-end inference speedup compared to the default GEMV kernel&lt;/li&gt;
  &lt;li&gt;30–40% improvement over the traditional Split-K method&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This new kernel/algorithm, GEMV_REVSPLITK, is available &lt;a href=&quot;https://github.com/mobiusml/gemlite/blob/master/gemlite/triton_kernels/gemv_revsplitK_A16fWnO16f_int32packing.py&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For non-packed data, the &lt;a href=&quot;https://github.com/mobiusml/gemlite/blob/master/gemlite/triton_kernels/gemv_splitK_A16fWnO16f_int32packing.py&quot;&gt;GEMV_SPLITK&lt;/a&gt; algorithm is employed. This algorithm iterates over the k-dimension to compute the dot product without relying on Triton’s tl.dot.&lt;/p&gt;

&lt;h3 id=&quot;batched-inference&quot;&gt;Batched Inference&lt;/h3&gt;

&lt;p&gt;For moderate batch sizes, we use the GEMM-based Split-K method (&lt;a href=&quot;https://arxiv.org/abs/2402.00025&quot;&gt;arXiv&lt;/a&gt;) which splits the k-dimension (weight rows) into multiple jobs. The optimal-split SPLIT_K parameter is found by autotuning values ranging from 1 to 16. Setting SPLIT_K=1 enables a fallback implementation to a GEMM kernel, allowing the same kernel code to be used for compute-bound batch sizes starting from 32 and 64, depending on the matrix shape and the device.&lt;/p&gt;

&lt;h3 id=&quot;maximizing-high-performance-key-implementation-insights&quot;&gt;Maximizing High Performance: Key Implementation Insights&lt;/h3&gt;

&lt;p&gt;Various implementation details must be carefully addressed to achieve high performance. Following are some of the key aspects we focused on to ensure high performance:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Autotuning for Performance&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://triton-lang.org/main/python-api/generated/triton.autotune.html&quot;&gt;Autotuning&lt;/a&gt; is critical for achieving optimal kernel performance. Since this process can be time-intensive, GemLite provides tools to automatically save and load autotuning results for all kernels. This ensures that the autotuning process is performed only once per GPU device, minimizing runtime, reducing repetitive overhead, and maintaining consistent performance across runs.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Ensuring Kernel Correctness&lt;/p&gt;

    &lt;p&gt;Ensuring kernel correctness across different quantization and configuration settings is essential. Triton’s &lt;a href=&quot;https://triton-lang.org/main/python-api/generated/triton.autotune.html&quot;&gt;early configuration pruning&lt;/a&gt; plays a key role in this process. For example, during Split-K tuning, configurations are selected only if K is divisible by BLOCK_SIZE_K × SPLIT_K,, and BLOCKS_SIZE_K  is further pruned based on the group-size value. This approach ensures both efficiency and correctness in kernel operation.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Overcoming Bit-Unpacking Bottlenecks&lt;/p&gt;

    &lt;p&gt;When deploying on data center-grade GPUs like NVIDIA’s A100 and H100, performance bottlenecks related to bit-unpacking were observed. To mitigate these, various bit-packing configurations were explored, including packing along columns versus rows and experimenting with different bit-packing widths (e.g., 8-bit vs. 32-bit). Notably, transitioning from 32-bit to 8-bit packing delivered performance improvements of up to 18% on the A100 and 6% on the H100&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;torch.compile compatibility&lt;/p&gt;

    &lt;p&gt;To ensure seamless compatibility with PyTorch’s torch.compile, kernel calls are wrapped in a &lt;a href=&quot;https://pytorch.org/tutorials/advanced/python_custom_ops.html&quot;&gt;custom_op&lt;/a&gt;. This integration allows advanced features such as pre-hooks and early configuration pruning to function correctly, delivering accurate results without sacrificing performance. While some of these &lt;a href=&quot;https://github.com/pytorch/pytorch/issues/139059&quot;&gt;features&lt;/a&gt; are not yet fully supported in PyTorch, the custom_op implementation effectively bridges the gap, ensuring smooth integration and high performance.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-torchao&quot;&gt;3. TorchAO&lt;/h2&gt;

&lt;p&gt;TorchAO is a PyTorch native quantization and sparsity library for both training and inference, featuring simple user APIs to train, quantize and deploy low precision models, and composability with other PyTorch features like distributed inference and torch.compile.&lt;/p&gt;

&lt;p&gt;PyTorch does not support low precision dtypes or different packing formats by default. With Tensor Subclass, we extend PyTorch native Tensor abstractions and model quantization as dtype conversion, while different packing formats for custom kernels are handled through layouts. For example, we support quantized linear operations with int4 weights, packed in a Tensor Core friendly layout, with tinygemm or GemLite kernel implementations. More details can be found &lt;a href=&quot;https://pytorch.org/ao/stable/contributor_guide.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/accelerating-llm-inference/fg1.png&quot; alt=&quot;flow diagram&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Apart from more PyTorch native abstractions for developers, we want to highlight two benefits of this design for modeling users.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://pytorch.org/ao/stable/serialization.html&quot;&gt;Serialization&lt;/a&gt;: Save and load quantized weights into a state_dict just like a floating point model, eliminating the need to transform floating point model to quantized model before the quantized weights are loaded. This reduces friction of distributing and deploying quantized models.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;#torch-tensor-parallel&quot;&gt;Composability&lt;/a&gt;: Seamless integration with downstream features like tensor parallel, allowing users to focus on modeling without worrying about compatibility with tensor parallel, torch.compile, and other PyTorch features. Since these features are implemented with Tensor level abstraction, users can quantize and do distributed inference with no model changes most of the time.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;gemlite-kernel-integration&quot;&gt;GemLite Kernel Integration&lt;/h3&gt;

&lt;p&gt;To achieve the aforementioned benefits for the GemLite kernel, we integrated GemLite into TorchAO. This integration takes advantage of GemLite’s wide support and flexibility to allow for weight only quantization at 4 and 8 bits, under asymmetric and symmetric quantization schemes, 32 and 8 bit packing sizes, as well as grouped and ungrouped quantization. We enable this integration via the  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;quantize_&lt;/code&gt; api which can be used alongside the GemLite constructor as follows&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;quantize_(model, gemlite_uintx_weight_only(group_size, bit_width, packing_bitwidth))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The primary difficulty in creating this integration was making sure that the TorchAO composability guarantees were satisfied for the entire breadth of GemLite quantization kernel options. While the primary integration was relatively straight forward, making sure every different quantization type and their associated kernels worked well with tensor parallel was non-trivial.&lt;/p&gt;

&lt;h3 id=&quot;torch-tensor-parallel&quot;&gt;Torch Tensor Parallel&lt;/h3&gt;

&lt;p&gt;Tensor Parallelism is an effective way to speed up LLM inference. TP shards large matrices of linear or embedding modules onto multiple devices, typically in column-wise or row-wise styles. As the weight matrix gets distributed, computation is decomposed too. For example, the column-wise pattern below enables simultaneous matrix-vector multiply on four devices:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/accelerating-llm-inference/fg5.jpg&quot; alt=&quot;equation&quot; style=&quot;max-width:300px; width:100%; display: block; margin-left: auto; margin-right: auto&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PyTorch implements TP by converting a regular tensor (e.g. matrix &lt;em&gt;A&lt;/em&gt;) into a &lt;em&gt;DTensor&lt;/em&gt;:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dtensor = _shard_tensor(mA, device_mesh, (Shard(0),))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Since DTensor stores meta information about the sharding, it knows how to reconstruct the full result when needed. Take Transformers’ feedforward module for example, as the down projection and up projection use column-wise and row-wise sharding respectively, DTensor will automatically perform an all-reduce on the ranks’ results as they move into the next operation. Such automation allows model authors to focus on computation without worrying about the communication needed for distributed execution.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tensor Parallel and Quantization Order&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Since both DTensor and quantization are tensor-level transformations, the application order matters in ensuring a workflow can generally work on different setups. We have two observations: (i) checkpoints are typically saved in quantized formats, to save the quantization overhead before each run; and (ii) TP may run on a different number of devices, depending on resource constraints or service agreements. As such, we first apply quantization to the original tensor, save it to disk depending on whether a reuse is desired. At service launch time, we load the quantized checkpoint and shard the tensors into DTensors on-the-fly as we load them into the model.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tensor Parallel Support in TorchAO&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Since we quantize the model first then distribute the Tensor, we’ll have &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DTensor(QuantizedTensor(weight))&lt;/code&gt;, where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DTensor&lt;/code&gt; means a distributed Tensor class and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QuantizedTensor&lt;/code&gt; means a quantized tensor class in TorchAO. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QuantizedTensor&lt;/code&gt; should support the operators called when constructing a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DTensor&lt;/code&gt;, including slice and view ops. To make sure the overall execution is efficient, the packed weight that’s sliced in the dimension 0 and 1 should match the result of first slice the unpacked weight then pack (pack and slice operation should commute), otherwise the packing format is not compatible with tensor parallelism.&lt;/p&gt;

&lt;h2 id=&quot;4-sglang&quot;&gt;4. SGLang&lt;/h2&gt;

&lt;p&gt;SGLang is a fast serving framework for large language models and vision language models. It is known for its almost &lt;a href=&quot;https://lmsys.org/blog/2024-12-04-sglang-v0-4/&quot;&gt;zero-overhead batch scheduler&lt;/a&gt; and fast &lt;a href=&quot;https://lmsys.org/blog/2024-02-05-compressed-fsm/&quot;&gt;constrained decoding&lt;/a&gt;. It is mainly implemented in Python, lightweight, and easy to hack. It is also one of the first frameworks to integrate torch.compile.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TorchAO integration in SGLang&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We integrated &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;quantize_&lt;/code&gt; API for applying a specific type of quantization to model into SGLang that supports int4 weight only quantization (both tinygemm and GemLite version), float8 dynamic quantization and a few other types of quantization so far. Users can enable quantization by adding &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--torchao-config&lt;/code&gt; argument to the benchmarking script. The currently enabled options also support tensor parallelism through composition with DTensor that is enabled with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--tp-size&lt;/code&gt; option.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Torch Native Tensor Parallel Support in SGLang&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Existing model definitions in SGLang use special linear modules that are coupled with tensor parallelism style, for example: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MergedColumnParallelLinear&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QKVParallelLinear&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RowParallelLinear&lt;/code&gt;. To decouple the model definition and tensor parallelization style, we defined a &lt;a href=&quot;https://github.com/sgl-project/sglang/blob/main/python/sglang/srt/models/torch_native_llama.py&quot;&gt;pytorch native model&lt;/a&gt; that uses plain &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nn.Linear&lt;/code&gt; module from PyTorch and rely on PyTorch tensor parallelism APIs for parallelization and torch.compile for speedup. At related module hierarchies, we add a dictionary describing how a submodule should be parallelized. For example, in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;class LlamaAttention&lt;/code&gt;, we define:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;_tp_plan = {
    &quot;qkv_proj&quot;: &quot;Colwise_Sharded&quot;,
    &quot;o_proj&quot;: &quot;Rowwise&quot;,
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;qkv_proj&quot; &lt;/code&gt;and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;o_proj&quot; &lt;/code&gt;are the FQNs of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wqkv&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wo&lt;/code&gt; projections, and the values are their TP styles.&lt;/p&gt;

&lt;p&gt;We then define a TP engine in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;model_parallel.py&lt;/code&gt;. It searches for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_tp_plan &lt;/code&gt;recursively within the model, and applies the indicated TP styles to the submodules using PyTorch’s &lt;a href=&quot;https://pytorch.org/docs/stable/distributed.tensor.parallel.html#torch.distributed.tensor.parallel.parallelize_module&quot;&gt;parallelize_module&lt;/a&gt; API.&lt;/p&gt;

&lt;h2 id=&quot;5-results&quot;&gt;5. Results&lt;/h2&gt;

&lt;p&gt;The evaluation focused on two popular quantization techniques for H100 machines: int4 weight-only quantization and float8 dynamic quantization. These methods were chosen due to their widespread use in optimizing memory efficiency and computational performance on H100 machines, making them ideal candidates for benchmarking against various workloads.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;int4 Weight-Only Quantization&lt;/strong&gt;: This method significantly reduces memory footprint and accelerates decode for memory-bound workloads, with minimal impact on performance in compute-intensive scenarios like prefill or larger batch sizes. We present results for bf16, GemLite, and tinygemm kernels below, across various batch sizes and tensor parallel configurations&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;float8 Dynamic Quantization&lt;/strong&gt;: While offering less memory savings, this method often provides higher accuracy and balanced speedups for both memory-bound and compute-bound tasks. With Hopper-grade hardware and native fp8 support, the efficient cutlass/cuBLAS kernels used by AO contribute to a significant speedup&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The graphs below show the decode tokens/sec for different tp sizes, each graph shows the results across different batch sizes and for different types of quantization:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;BF16 is our bfloat16, torch.compile’d baseline&lt;/li&gt;
  &lt;li&gt;tinygemm-4-64 is using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int4_weight_only&lt;/code&gt; quantization in TorchAO, it’s a 4 bit groupwise quantization with group size of 64, using tinygemm kernel&lt;/li&gt;
  &lt;li&gt;gemlite-4-64 is using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gemlite_uintx_weight_only &lt;/code&gt;quantization in TorchAO, 4 means 4 bit, and 64 is also the group size, using GemLite kernel&lt;/li&gt;
  &lt;li&gt;fp8dq-per_row is using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;float8_dynamic_activation_float8_weight&lt;/code&gt; quantization in TorchAO, both activation and weights are quantized with per row scales&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/accelerating-llm-inference/fg2.png&quot; alt=&quot;bar chart&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/accelerating-llm-inference/fg3.png&quot; alt=&quot;bar chart&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/accelerating-llm-inference/fg4.png&quot; alt=&quot;bar chart&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;For int4 weight-only quantization, at batch size 1, the tinygemm kernel achieved the best performance. However, its efficiency declined with increasing batch sizes. Conversely, GemLite effectively bridged this gap, delivering superior performance at larger batch sizes. GemLite also achieved a 9–10x speedup during the prefill phase compared to tinygemm, despite ongoing performance optimizations constrained by Triton.&lt;/p&gt;

&lt;p&gt;Float8 dynamic quantization showed 1.3x speedup over bfloat16 consistently with tensor parallel size 1 across different batch sizes and 1.1x to 1.2x speedup in larger tensor parallel sizes. As the tensor parallel size increases, the overall speedup decreases, which is expected due to the reduction in matmul size. Note that we do expect to get speedup for prefill as well, but since we rely on torch.compile for speedup and prefill compile is not enabled in SGLang yet, we will leave this for future work.&lt;/p&gt;

&lt;h3 id=&quot;repro-instructions&quot;&gt;Repro Instructions&lt;/h3&gt;

&lt;p&gt;We conducted benchmarks on an 8xH100 machine using GemLite 0.4.1, SGLang built from commit feb2b76, TorchAO nightly 0.8.0.dev20241223+cu124, and PyTorch 2.5.1. The Llama-3.1 Instruct models were chosen as the architecture for evaluation.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;BATCH_SIZE=16
# Note: gemlite is only compatible with float16
# while int4wo-64 (tinygemm-4-64 as shown in the graph) and fp8dq-per_row should use bfloat16
DTYPE=float16
# int4wo-64, fp8dq-per_tensor
TORCHAO_CONFIG=gemlite-4-64
TP_SIZE=2
# Decode performance
python3 -m sglang.bench_offline_throughput --model-path meta-llama/Llama-3.1-8B-Instruct --json-model-override-args '{&quot;architectures&quot;: [&quot;TorchNativeLlamaForCausalLM&quot;]}' --dataset-name random --random-input 1024 --random-output 512 --random-range 1 --num-prompts $BATCH_SIZE --enable-torch-compile --dtype $DTYPE --torchao-config $TORCHAO_CONFIG --tp-size $TP_SIZE

# Example output
# Benchmark...
# [2024-12-20 12:42:16 TP0] Prefill batch. #new-seq: 2, #new-token: 2046, #cached-token: 4, cache hit rate: \0.06%, token usage: 0.00, #running-req: 0, #queue-req: 0
# ...
# [2024-12-20 12:45:35 TP0] Decode batch. #running-req: 16, #token: 16763, token usage: 0.01, gen throughput\ (token/s): 2.20, #queue-req: 0
# [2024-12-20 12:45:38 TP0] Decode batch. #running-req: 16, #token: 24443, token usage: 0.02, gen throughput\ (token/s): 2739.89, #queue-req: 0

# We reported the last throughput (token/s) as the performance for decode
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;With performant and extensible kernels from &lt;a href=&quot;https://github.com/mobiusml/gemlite&quot;&gt;GemLite&lt;/a&gt;, PyTorch native architecture optimization library &lt;a href=&quot;https://github.com/pytorch/ao&quot;&gt;TorchAO&lt;/a&gt; and high performance inference framework &lt;a href=&quot;https://github.com/sgl-project/sglang&quot;&gt;SGLang&lt;/a&gt;, we showcased fast end-to-end quantized inference for both int4 and float8 across different batch sizes and tensor parallel sizes with simple and composable user APIs to reduce the resource requirement for LLMs. This integration is our first step towards meeting the needs of fast inference across different models, workloads, precisions and hardwares and we are looking forward to continuing advancing the state of the art for end to end mixed and low precision LLM inference.&lt;/p&gt;

&lt;p&gt;Our immediate future work focuses on the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Exploring diverse combinations of weight and activation quantization to strike the best balance between speed and accuracy&lt;/li&gt;
  &lt;li&gt;Extending support to additional GPU architectures to broaden accessibility&lt;/li&gt;
  &lt;li&gt;Enhancing compatibility with MoE models to address growing demands in scalable inference&lt;/li&gt;
  &lt;li&gt;Allow for easy integration of fast custom kernels in TorchAO so that they can be easily leveraged by SGLang and other inference frameworks&lt;/li&gt;
  &lt;li&gt;While we didn’t measure accuracy impact in this blogpost, we can develop auto quantization tool in TorchAO to allow users to trade off between performance and accuracy&lt;/li&gt;
  &lt;li&gt;Better integration with tensor parallelism in SGLang to support running larger models&lt;/li&gt;
  &lt;li&gt;Enable torch.compile for prefill phase in SGLang&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We also invite the community to actively test, provide feedback, and contribute to shaping the future of fast and efficient LLM inference.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Teams at PyTorch, Mobius Labs and SGLang</name>
        
        
      </author>

      

      

      
        <summary type="html">Large Language Models (LLMs) are typically very resource-intensive, requiring significant amounts of memory, compute and power to operate effectively. Quantization provides a solution by reducing weights and activations from 16 bit floats to lower bitrates (e.g., 8 bit, 4 bit, 2 bit), achieving significant speedup and memory savings and also enables support for larger batch sizes.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">MLOps Workflow Simplified for PyTorch with Arm and GitHub Collaboration</title>
      <link href="https://pytorch.org/blog/mlops-workflow/" rel="alternate" type="text/html" title="MLOps Workflow Simplified for PyTorch with Arm and GitHub Collaboration" />
      <published>2025-01-15T00:00:00-08:00</published>
      <updated>2025-01-15T00:00:00-08:00</updated>
      <id>https://pytorch.org/blog/mlops-workflow</id>
      <content type="html" xml:base="https://pytorch.org/blog/mlops-workflow/">&lt;p&gt;PyTorch is one of the most widely used and most powerful deep learning frameworks for training and deploying complex neural networks. It has never been easier to train and deploy AI applications, and low-cost, high-performance, energy-efficient hardware, tools, and technology for creating optimized workflows are more accessible than ever.  But data science, machine learning, and devops can be deep topics unto themselves, and it can be overwhelming for developers with one specialty to see how they all come together in the real world, or even to know where to get started.&lt;/p&gt;

&lt;p&gt;To that end, we at Arm have collaborated with our friends at GitHub to decompose the basic elements of real world MLOps pipelines that use PyTorch models and create a simplified workflow and MLOps tutorial that anyone with a GitHub and a Docker Hub account can leverage.&lt;/p&gt;

&lt;h2 id=&quot;mlops-overview&quot;&gt;MLOps Overview&lt;/h2&gt;

&lt;p&gt;The software development lifecycle for machine learning applications typically starts from training data, which is used to train sophisticated neural networks (NNs) that are optimized, integrated into software images, and then deployed onto compute clusters and even fleets of devices in the field.  These devices are typically continuously collecting data and are managed by cloud services, which actively monitor performance of the ML algorithm(s) and feedback data for retraining in the next iteration of the lifecycle – enabling continuous improvement of the algorithms, as well as supporting deployment of new AI features.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mlops-workflow/fg1.png&quot; alt=&quot;process flow chart&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example of a typical ML software development lifecycle.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Scott Arbeit from GitHub recently published an &lt;a href=&quot;https://github.blog/enterprise-software/ci-cd/streamlining-your-mlops-pipeline-with-github-actions-and-arm64-runners/&quot;&gt;excellent blog&lt;/a&gt; that highlights the importance of MLOps in machine learning and describes automation via simplified GitHub actions for several key tasks including:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Data preprocessing&lt;/strong&gt;: cleaning and preparation of data for training.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Model training and validation&lt;/strong&gt;: automatic execution of training scripts when new data is pushed or when changes are made to the model code.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Deployment&lt;/strong&gt;: automatic packaging and deployment of models to production environments upon successful training and validation.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Monitoring and alerts:&lt;/strong&gt; workflows to monitor model performance and send alerts if certain thresholds are breached.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The article also describes a conceptual efficient MLOps pipeline that takes advantage of new, low-cost Arm Runners natively integrated into GitHub Actions to train and validate PyTorch models. It also uses containerization for consistent deployment across different environments.&lt;/p&gt;

&lt;p&gt;Our team at Arm put GitHub’s ideas and conceptual workflow into practice and created a tutorial to help you get started today.&lt;/p&gt;

&lt;h2 id=&quot;optimizing-your-pytorch-mlops-workflow&quot;&gt;Optimizing Your PyTorch MLOps Workflow&lt;/h2&gt;

&lt;p&gt;A new &lt;a href=&quot;https://learn.arm.com/&quot;&gt;Arm Learning Path&lt;/a&gt; unpacks each of the key phases described in Scott’s blog, and demonstrates each key task in detail, providing prescriptive instructions and code examples to leverage several aspects of the PyTorch framework to implement each phase.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mlops-workflow/fg2.png&quot; alt=&quot;process flow chart&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Key ML tasks to setup and automate with GitHub Actions.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;With this learning path you will be able to take advantage of the following strategies with a real-world object detection use case to make your own streamlined MLOps workflow:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Containerization:&lt;/strong&gt; Package your PyTorch model and its dependencies into a Docker container to help ensure consistent performance across different environments.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Efficient Data Loading:&lt;/strong&gt; Optimize data loading pipelines to help minimize I/O bottlenecks and maximize GPU utilization.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Model Optimization:&lt;/strong&gt; Explore techniques like model quantization, pruning, and knowledge distillation to help reduce model size and improve inference speed.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Leverage PyTorch’s Ecosystem:&lt;/strong&gt; Utilize libraries like TorchVision to help streamline common deep learning tasks.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Monitor and Profile:&lt;/strong&gt; Monitor resource utilization and identify potential bottlenecks to further optimize your workflow.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;an-end-to-end-mlops-workflow&quot;&gt;An End-to-End MLOps Workflow&lt;/h2&gt;

&lt;p&gt;The best part of this learning path is not just that it takes you through each task in detail, but it brings it all together into a unified automated workflow.&lt;/p&gt;

&lt;p&gt;With GitHub Actions, you can build an end-to-end custom MLOPs workflow that combines and automates the individual workflows for each ML task.  To demonstrate this, the repository contains a workflow in a boilerplate .yml file that automates the individual steps.&lt;/p&gt;

&lt;p&gt;You can run an MLOps workflow using GitHub Actions natively for managing all the steps in your ML application’s lifecycle.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mlops-workflow/fg3.png&quot; alt=&quot;process flow chart&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A successful run of this MLOps workflow in GitHub Actions.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;try-it-yourself&quot;&gt;Try It Yourself!&lt;/h2&gt;

&lt;p&gt;Our Arm team has battle-tested this tutorial in the field and delivered the tutorial as a workshop at GitHub Universe 2024 earlier this year.  Now it’s time for you to take it for a spin and get hands-on with PyTorch and MLOps.&lt;/p&gt;

&lt;p&gt;Try the Arm Learning Path &lt;a href=&quot;https://learn.arm.com/learning-paths/servers-and-cloud-computing/gh-runners/&quot;&gt;Here&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;By the end of this tutorial, you can:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Set up a new GitHub Arm-runner to natively build an arm64 image to take advantage of the lowest-cost, most power efficient compute available.&lt;/li&gt;
  &lt;li&gt;Train and test a PyTorch ML model with the German Traffic Sign Recognition Benchmark (GTSRB) dataset.&lt;/li&gt;
  &lt;li&gt;Compare the performance of two trained PyTorch ML models; one model compiled with OpenBLAS (Open Basic Linear Algebra Subprograms Library) and oneDNN (Deep Neural Network Library), and the other model compiled with Arm Compute Library (ACL).&lt;/li&gt;
  &lt;li&gt;Containerize a ML model and push the container to DockerHub.&lt;/li&gt;
  &lt;li&gt;Automate each task into a single MLOps pipeline Using GitHub Actions.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Combining the power of PyTorch with the simplicity of GitHub Actions and the efficiency of native Arm Runners significantly helps you accelerate your deep learning development and deployment processes. Following the best practices outlined in this blog post helps you achieve optimal performance and cost-effectiveness for your PyTorch projects.&lt;/p&gt;

&lt;p&gt;We’d love to see what you create based on this example.  If you have created your own Arm Learning Path, you are invited to &lt;a href=&quot;https://learn.arm.com/learning-paths/cross-platform/_example-learning-path/&quot;&gt;share it here&lt;/a&gt;.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Eric Sondhi, Arm</name>
        
        
      </author>

      

      

      
        <summary type="html">PyTorch is one of the most widely used and most powerful deep learning frameworks for training and deploying complex neural networks. It has never been easier to train and deploy AI applications, and low-cost, high-performance, energy-efficient hardware, tools, and technology for creating optimized workflows are more accessible than ever. But data science, machine learning, and devops can be deep topics unto themselves, and it can be overwhelming for developers with one specialty to see how they all come together in the real world, or even to know where to get started.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">GenAI Acceleration for PyTorch 2.5 on Intel® Xeon®Processors</title>
      <link href="https://pytorch.org/blog/genai-acceleration-intel-xeon/" rel="alternate" type="text/html" title="GenAI Acceleration for PyTorch 2.5 on Intel® Xeon®Processors" />
      <published>2025-01-14T00:00:00-08:00</published>
      <updated>2025-01-14T00:00:00-08:00</updated>
      <id>https://pytorch.org/blog/genai-acceleration-intel-xeon</id>
      <content type="html" xml:base="https://pytorch.org/blog/genai-acceleration-intel-xeon/">&lt;p&gt;This blog is the fifth in a series focused on accelerating generative AI models with pure, native PyTorch. We demonstrate the GenAI acceleration of GPTFast, Segment Anything Fast, and Diffusion Fast on Intel® Xeon®Processors.&lt;/p&gt;

&lt;p&gt;First, we revisit GPTFast, a remarkable work that speeds up text generation in under 1000 lines of native PyTorch code. Initially, GPTFast supported only the CUDA backend. We will show you how to run GPTFast on CPU and achieve additional performance speedup with weight-only quantization (WOQ).&lt;/p&gt;

&lt;p&gt;In Segment Anything Fast, we have incorporated support for the CPU backend and will demonstrate performance acceleration by leveraging the increased power of CPU with BFloat16, torch.compile, and scaled_dot_product_attention (SDPA) with a block-wise attention mask. The speedup ratio against FP32 can reach 2.91x in vit_b and 3.95x in vit_h.&lt;/p&gt;

&lt;p&gt;Finally, Diffusion Fast now supports the CPU backend and leverages the increased power of CPU with BFloat16, torch.compile, and SDPA. We also optimize the layout propagation rules for convolution, cat, and permute in Inductor CPU to improve performance. The speedup ratio against FP32 can achieve 3.91x in Stable Diffusion XL (SDXL).&lt;/p&gt;

&lt;h2 id=&quot;optimization-strategies-to-boost-performance-on-pytorch-cpu&quot;&gt;Optimization strategies to boost performance on PyTorch CPU&lt;/h2&gt;

&lt;h3 id=&quot;gptfast&quot;&gt;GPTFast&lt;/h3&gt;

&lt;p&gt;Over the past year, generative AI has achieved great success across various language tasks and become increasingly popular. However, generative models face high inference costs due to the memory bandwidth bottlenecks in the auto-regressive decoding process. To address these issues, the PyTorch team published GPTFast which targets accelerating text generation with only pure, native PyTorch. This project developed an LLM from scratch almost 10x faster than the baseline in under 1000 lines of native PyTorch code. Initially, GPTFast supported only the CUDA backend and garnered approximately 5,000 stars in about four months. Inspired by Llama.cpp, the Intel team provided CPU backend support starting with the PyTorch 2.4 release, further enhancing the project’s availability in GPU-free environments. The following are optimization strategies used to boost performance on PyTorch CPU:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Torch.compile&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;torch.compile is a PyTorch function introduced since PyTorch 2.0 that aims to solve the problem of accurate graph capturing in PyTorch and ultimately enable software engineers to run their PyTorch programs faster.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Weight-only Quantization&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;Weight-only quantization (WOQ) is a trade-off between the performance and the accuracy since the bottleneck of the auto-regressive decoding phase in text generation is the memory bandwidth of loading weights and generally WOQ could lead to better accuracy compared to traditional quantization approach such as W8A8. GPTFast supports two types of WOQs: W8A16 and W4A16. To be specific, activations are stored in BFloat16 and model weights could be quantized to int8 and int4, as shown in Figure 1.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/genai-acceleration-intel-xeon/fg1.png&quot; alt=&quot;flow diagram&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Figure 1. Weight-only Quantization Pattern. Source: Mingfei Ma, Intel&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Weight Prepacking &amp;amp; Micro Kernel Design.&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;To maximize throughput, GPTFast allows model weights to be prepacked into hardware-specific layouts on int4 using internal PyTorch ATen APIs. Inspired by Llama.cpp, we prepacked the model weights from [N, K] to [N/kNTileSize, K, kNTileSize/2], with kNTileSize set to 64 on avx512. First, the model weights are blocked along the N dimension, then the two innermost dimensions are transposed. To minimize de-quantization overhead in kernel computation, we shuffle the 64 data elements on the same row in an interleaved pattern, packing Lane2 &amp;amp; Lane0 together and Lane3 &amp;amp; Lane1 together, as illustrated in Figure 2.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/genai-acceleration-intel-xeon/fg2.png&quot; alt=&quot;flow diagram&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Figure 2. Weight Prepacking on Int4. Source: Mingfei Ma, Intel&lt;/p&gt;

&lt;p&gt;During the generation phase, the torch.nn.Linear module will be lowered to be computed with high-performance kernels inside PyTorch ATen, where the quantized weights will be de-quantized first and then accumulated with fused multiply-add (FMA) at the register level, as shown in Figure 3.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/genai-acceleration-intel-xeon/fg3.png&quot; alt=&quot;flow diagram&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Figure 3. Micro Kernel Design. Source: Mingfei Ma, Intel&lt;/p&gt;

&lt;h3 id=&quot;segment-anything-fast&quot;&gt;Segment Anything Fast&lt;/h3&gt;

&lt;p&gt;Segment Anything Fast offers a simple and efficient PyTorch native acceleration for the Segment Anything Model (SAM) , which is a zero-shot vision model for generating promptable image masks. The following are optimization strategies used to boost performance on PyTorch CPU:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;BFloat16&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;Bfloat16 is a commonly used half-precision type. Through less precision per parameter and activations, we can save significant time and memory in computation.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Torch.compile&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;torch.compile is a PyTorch function introduced since PyTorch 2.0 that aims to solve the problem of accurate graph capturing in PyTorch and ultimately enable developers to run their PyTorch programs faster.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Scaled Dot Product Attention (SDPA)&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;Scaled Dot-Product Attention (SDPA) is a crucial mechanism in transformer models. PyTorch offers a fused implementation that significantly outperforms a naive approaches. For Segment Anything Fast, we convert the attention mask from bfloat16 to float32 in a block-wise manner. This method not only reduces peak memory usage, making it ideal for systems with limited memory resources, but also enhances performance.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;diffusion-fast&quot;&gt;Diffusion Fast&lt;/h3&gt;

&lt;p&gt;Diffusion Fast offers a simple and efficient PyTorch native acceleration for text-to-image diffusion models. The following are optimization strategies used to boost performance on PyTorch CPU:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;BFloat16&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;Bfloat16 is a commonly used half-precision type. Through less precision per parameter and activations, we can save significant time and memory in computation.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Torch.compile&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;torch.compile is a PyTorch function introduced since PyTorch 2.0 that aims to solve the problem of accurate graph capturing in PyTorch and ultimately enable software engineers to run their PyTorch programs faster.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Scaled Dot Product Attention (SDPA)&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;SDPA is a key mechanism used in transformer models, PyTorch provides a fused implementation to show large performance benefits over a naive implementation.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;model-usage-on-native-pytorch-cpu&quot;&gt;Model Usage on Native PyTorch CPU&lt;/h2&gt;

&lt;h3 id=&quot;gptfast-1&quot;&gt;&lt;a href=&quot;https://github.com/pytorch-labs/gpt-fast&quot;&gt;GPTFast&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;To launch WOQ in GPTFast, first quantize the model weights. For example, to quantize with int4 and group size of 32:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;python quantize.py --checkpoint_path checkpoints/$MODEL_REPO/model.pth --mode int4 –group size 32
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then run generation by passing the int4 checkpoint to generate.py&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;python generate.py --checkpoint_path checkpoints/$MODEL_REPO/model_int4.g32.pth --compile --device $DEVICE
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To use CPU backend in GPTFast, simply switch DEVICE variable from cuda to CPU.&lt;/p&gt;

&lt;h3 id=&quot;segment-anything-fast-1&quot;&gt;&lt;a href=&quot;https://github.com/pytorch-labs/segment-anything-fast&quot;&gt;Segment Anything Fast&lt;/a&gt;&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd experiments

export SEGMENT_ANYTHING_FAST_USE_FLASH_4=0

python run_experiments.py 16 vit_b &amp;amp;lt;pytorch_github&amp;gt; &amp;amp;lt;segment-anything_github&amp;gt; &amp;amp;lt;path_to_experiments_data&amp;gt; --run-experiments --num-workers 32 --device cpu

python run_experiments.py 16 vit_h &amp;amp;lt;pytorch_github&amp;gt; &amp;amp;lt;segment-anything_github&amp;gt; &amp;amp;lt;path_to_experiments_data&amp;gt; --run-experiments --num-workers 32 --device cpu
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;diffusion-fast-1&quot;&gt;&lt;a href=&quot;https://github.com/huggingface/diffusion-fast&quot;&gt;Diffusion Fast&lt;/a&gt;&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;python run_benchmark.py --compile_unet --compile_vae --device=cpu
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;performance-evaluation&quot;&gt;Performance Evaluation&lt;/h2&gt;

&lt;h3 id=&quot;gptfast-2&quot;&gt;GPTFast&lt;/h3&gt;

&lt;p&gt;We ran llama-2-7b-chat model based on &lt;a href=&quot;https://github.com/yanbing-j/gpt-fast/tree/yanbing/int4pack_mm&quot;&gt;test branch&lt;/a&gt; and the above hardware configuration on PyTorch.  After applying the following steps, we saw a 3.8x boost compared to the baseline in eager mode:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.compile&lt;/code&gt; to automatically fuse elementwise operators.&lt;/li&gt;
  &lt;li&gt;Reduce memory footprint with WOQ-int8.&lt;/li&gt;
  &lt;li&gt;Further reduce memory footprint with WOQ-int4.&lt;/li&gt;
  &lt;li&gt;Use AVX512 which enables faster de-quant in micro kernels.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/genai-acceleration-intel-xeon/fg4.png&quot; alt=&quot;bar chart&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Figure 4.  GPTFast Performance speedup in Llama2-7b-chat&lt;/p&gt;

&lt;h3 id=&quot;segment-anything-fast-2&quot;&gt;Segment Anything Fast&lt;/h3&gt;

&lt;p&gt;We ran Segment Anything Fast on the above hardware configuration on PyTorch and achieved a performance speedup of BFloat16 with torch.compile and SDPA compared with FP32 as shown in Figure 5. The speedup ratio against FP32 can achieve 2.91x in vit_b, and 3.95x in vit_h.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/genai-acceleration-intel-xeon/fg5.png&quot; alt=&quot;bar chart&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Figure 5. Segment Anything Fast Performance speedup in vit_b/vit_h&lt;/p&gt;

&lt;h3 id=&quot;diffusion-fast-2&quot;&gt;Diffusion Fast&lt;/h3&gt;

&lt;p&gt;We ran Diffusion Fast on the above hardware configuration on PyTorch and achieved a performance speedup of BFloat16 with torch.compile and SDPA compared with FP32 as shown in Figure 6. The speedup ratio against FP32 can achieve 3.91x in Stable Diffusion XL (SDXL).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/genai-acceleration-intel-xeon/fg6.png&quot; alt=&quot;bar chart&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Figure 6. Diffusion Fast Performance speedup in Stable Diffusion XL&lt;/p&gt;

&lt;h2 id=&quot;conclusion-and-future-work&quot;&gt;Conclusion and Future Work&lt;/h2&gt;

&lt;p&gt;In this blog, we introduced software optimizations for weight-only quantization, torch.compile, and SDPA, demonstrating how we can accelerate text generation with native PyTorch on CPU. Further improvements are expected with the support of the AMX-BF16 instruction set and the optimization of dynamic int8 quantization using torchao on CPU. We will continue to extend our software optimization efforts to a broader scope.&lt;/p&gt;

&lt;h2 id=&quot;acknowledgments&quot;&gt;Acknowledgments&lt;/h2&gt;

&lt;p&gt;The results presented in this blog are a joint effort between Meta and the Intel PyTorch Team. Special thanks to Michael Gschwind from Meta who spent precious time providing substantial assistance. Together we took one more step on the path to improve the PyTorch CPU ecosystem.&lt;/p&gt;

&lt;h2 id=&quot;related-blogs&quot;&gt;Related Blogs&lt;/h2&gt;

&lt;p&gt;Part 1: How to accelerate &lt;a href=&quot;https://pytorch.org/blog/accelerating-generative-ai/&quot;&gt;Segment Anything over 8x&lt;/a&gt; with Segment Anything Fast.&lt;/p&gt;

&lt;p&gt;Part 2: How to accelerate &lt;a href=&quot;https://pytorch.org/blog/accelerating-generative-ai-2/&quot;&gt;Llama-7B by almost 10x&lt;/a&gt; with help of GPTFast.&lt;/p&gt;

&lt;p&gt;Part 3: How to accelerate &lt;a href=&quot;https://pytorch.org/blog/accelerating-generative-ai-3/&quot;&gt;text-to-image diffusion models up to 3x&lt;/a&gt; with Diffusion Fast.&lt;/p&gt;

&lt;p&gt;Part 4: How to speed up FAIR’s &lt;a href=&quot;https://pytorch.org/blog/accelerating-generative-ai-4/&quot;&gt;Seamless M4T-v2 model by 2.7x&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;product-and-performance-information&quot;&gt;Product and Performance Information&lt;/h2&gt;

&lt;p&gt;Figure 4: Intel Xeon Scalable Processors: Measurement on 4th Gen Intel Xeon Scalable processor using: 2x Intel(R) Xeon(R) Platinum 8480+, 56cores, HT On, Turbo On, NUMA 2, Integrated Accelerators Available [used]: DLB 2 [0], DSA 2 [0], IAA 2 [0], QAT 2 [0], Total Memory 512GB (16x32GB DDR5 4800 MT/s [4800 MT/s]), BIOS 3B07.TEL2P1, microcode 0x2b000590, Samsung SSD 970 EVO Plus 2TB, CentOS Stream 9, 5.14.0-437.el9.x86_64, run single socket (1 instances in total with: 56 cores per instance, Batch Size 1 per instance), Models run with PyTorch 2.5 wheel. Test by Intel on 10/15/24.&lt;/p&gt;

&lt;p&gt;Figure 5: Intel Xeon Scalable Processors: Measurement on 4th Gen Intel Xeon Scalable processor using: 2x Intel(R) Xeon(R) Platinum 8480+, 56cores, HT On, Turbo On, NUMA 2, Integrated Accelerators Available [used]: DLB 2 [0], DSA 2 [0], IAA 2 [0], QAT 2 [0], Total Memory 512GB (16x32GB DDR5 4800 MT/s [4800 MT/s]), BIOS 3B07.TEL2P1, microcode 0x2b000590, Samsung SSD 970 EVO Plus 2TB, CentOS Stream 9, 5.14.0-437.el9.x86_64, run single socket (1 instances in total with: 56 cores per instance, Batch Size 16 per instance), Models run with PyTorch 2.5 wheel. Test by Intel on 10/15/24.&lt;/p&gt;

&lt;p&gt;Figure 6: Intel Xeon Scalable Processors: Measurement on 4th Gen Intel Xeon Scalable processor using: 2x Intel(R) Xeon(R) Platinum 8480+, 56cores, HT On, Turbo On, NUMA 2, Integrated Accelerators Available [used]: DLB 2 [0], DSA 2 [0], IAA 2 [0], QAT 2 [0], Total Memory 512GB (16x32GB DDR5 4800 MT/s [4800 MT/s]), BIOS 3B07.TEL2P1, microcode 0x2b000590, Samsung SSD 970 EVO Plus 2TB, CentOS Stream 9, 5.14.0-437.el9.x86_64, run single socket (1 instances in total with: 56 cores per instance, Batch Size 1 per instance), Models run with PyTorch 2.5 wheel. Test by Intel on 10/15/24.&lt;/p&gt;

&lt;h2 id=&quot;notices-and-disclaimers&quot;&gt;Notices and Disclaimers&lt;/h2&gt;

&lt;p&gt;Performance varies by use, configuration and other factors. Learn more on the Performance Index site. Performance results are based on testing as of dates shown in configurations and may not reflect all publicly available updates.  See backup for configuration details.  No product or component can be absolutely secure. Your costs and results may vary. Intel technologies may require enabled hardware, software or service activation.&lt;/p&gt;

&lt;p&gt;Intel Corporation. Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries. Other names and brands may be claimed as the property of others.&lt;/p&gt;

&lt;h2 id=&quot;ai-disclaimer&quot;&gt;AI disclaimer:&lt;/h2&gt;

&lt;p&gt;AI features may require software purchase, subscription or enablement by a software or platform provider, or may have specific configuration or compatibility requirements. Details at &lt;a href=&quot;https://www.intel.com/AIPC&quot;&gt;www.intel.com/AIPC&lt;/a&gt;. Results may vary.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>the Intel PyTorch Team</name>
        
        
      </author>

      

      

      
        <summary type="html">This blog is the fifth in a series focused on accelerating generative AI models with pure, native PyTorch. We demonstrate the GenAI acceleration of GPTFast, Segment Anything Fast, and Diffusion Fast on Intel® Xeon®Processors.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Integrating Ascend Backend with Torchtune through PyTorch Multi-Device Support</title>
      <link href="https://pytorch.org/blog/ascend-backend-w-torchtune/" rel="alternate" type="text/html" title="Integrating Ascend Backend with Torchtune through PyTorch Multi-Device Support" />
      <published>2025-01-09T00:00:00-08:00</published>
      <updated>2025-01-09T00:00:00-08:00</updated>
      <id>https://pytorch.org/blog/ascend-backend-w-torchtune</id>
      <content type="html" xml:base="https://pytorch.org/blog/ascend-backend-w-torchtune/">&lt;p&gt;In this blog, we will briefly introduce torchtune, the Ascend backend, and demonstrate how torchtune can be used to fine-tune models with Ascend.&lt;/p&gt;

&lt;h2 id=&quot;introduction-to-torchtune&quot;&gt;Introduction to Torchtune&lt;/h2&gt;

&lt;p&gt;Torchtune is a PyTorch-native library designed to simplify the fine-tuning of Large Language Models (LLMs). Staying true to PyTorch’s design principles, it provides composable and modular building blocks, as well as easily extensible training recipes. torchtune allows developers to fine-tune popular LLMs with different training methods and model architectures while supporting training on a variety of consumer-grade and professional GPUs.&lt;/p&gt;

&lt;p&gt;You can explore more about torchtune’s code and tutorials here:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;GitHub Repository&lt;/strong&gt;: 
The source code for torchtune is hosted on GitHub, where you can find the full implementation, commit history, and development documentation. Access the code repository here: &lt;a href=&quot;https://github.com/pytorch/torchtune&quot;&gt;Torchtune GitHub Repository&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Tutorials and Documentation&lt;/strong&gt;: 
Torchtune provides detailed tutorials to help users quickly get started with the fine-tuning process and demonstrate how to use torchtune for various tasks like training and evaluation. You can access the official tutorials here: &lt;a href=&quot;https://pytorch.org/torchtune/main/overview.html&quot;&gt;Torchtune Tutorials&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In these resources, you’ll find not only how to fine-tune large language models using torchtune but also how to integrate with tools like PyTorch, Hugging Face, etc. They offer comprehensive documentation and examples for both beginners and advanced users, helping everyone customize and optimize their model training pipelines.&lt;/p&gt;

&lt;h2 id=&quot;introduction-to-ascend-backend&quot;&gt;Introduction to Ascend Backend&lt;/h2&gt;

&lt;p&gt;Ascend is a series of AI computing products launched by Huawei, offering a full-stack AI computing infrastructure that includes processors, hardware, foundational software, AI computing frameworks, development toolchains, management and operation tools, as well as industry-specific applications and services. These products together create a powerful and efficient AI computing platform that caters to various AI workloads.&lt;/p&gt;

&lt;p&gt;You can explore more about  Ascend here: &lt;a href=&quot;https://www.hiascend.com/en/&quot;&gt;Ascend Community&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;how-torchtune-integrates-with-ascend&quot;&gt;How Torchtune Integrates with Ascend&lt;/h2&gt;

&lt;p&gt;Initially, devices were primarily matched using device strings. However, torchtune later introduced an abstraction layer for devices, leveraging the &lt;em&gt;get_device_support()&lt;/em&gt; method to dynamically retrieve relevant devices based on the current environment.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/ascend-backend-w-torchtune.png&quot; alt=&quot;flow diagram&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ascend is seamlessly integrated into torchtune via the &lt;em&gt;PrivateUse1&lt;/em&gt; feature provided by PyTorch. By importing &lt;em&gt;torch_npu&lt;/em&gt; and replacing the corresponding CUDA-like device operations with the &lt;em&gt;torch.device&lt;/em&gt; namespace from the environment supported by &lt;em&gt;device_support&lt;/em&gt;—such as torch.npu and torch.cuda—Ascend is effectively incorporated into torchtune. The PR is &lt;a href=&quot;https://github.com/pytorch/torchtune/pull/1826&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;torch_npu&lt;/em&gt; is a plugin developed for PyTorch, designed to seamlessly integrate Ascend NPU with the PyTorch framework, enabling developers to leverage the powerful computational capabilities of Ascend AI processors for deep learning training and inference. This plugin allows users to directly utilize Ascend’s computational resources within PyTorch without the need for complex migration or code changes.&lt;/p&gt;

&lt;h2 id=&quot;torchtune-quick-start-with-ascend&quot;&gt;Torchtune Quick Start with Ascend&lt;/h2&gt;

&lt;p&gt;In torchtune, there are two key concepts that are essential for customizing and optimizing the fine-tuning process: &lt;strong&gt;Config&lt;/strong&gt; and &lt;strong&gt;Recipe&lt;/strong&gt;. These concepts allow users to easily customize and optimize the fine-tuning process to suit different needs and hardware environments.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Config is a file used by torchtune to configure the training process. It contains settings for the model, data, training parameters, and more. By modifying the Config file, users can easily adjust various aspects of the training process, such as data loading, optimizer settings, and learning rate adjustments. Config files are typically written in YAML format, making them clear and easy to modify.&lt;/li&gt;
  &lt;li&gt;A Recipe in torchtune is a simple, transparent single-file training script in pure PyTorch. Recipes provide the full end-to-end training workflow but are designed to be hackable and easy to extend. Users can choose an existing Recipe or create a custom one to meet their fine-tuning needs.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When fine-tuning a model using the Ascend backend, torchtune simplifies the process by allowing you to specify the device type directly in the configuration file. Once you specify &lt;strong&gt;npu&lt;/strong&gt; as the device type, torchtune automatically detects and utilizes the Ascend NPU for training and inference. This design allows users to focus on model fine-tuning without needing to worry about hardware details.&lt;/p&gt;

&lt;p&gt;Specifically, you just need to set the relevant parameters in the &lt;strong&gt;Config&lt;/strong&gt; file, indicating the device type as &lt;strong&gt;&lt;em&gt;npu&lt;/em&gt;&lt;/strong&gt;, such as:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Environment
device: npu
dtype: bf16

# Dataset
dataset:
  _component_: torchtune.datasets.instruct_dataset
  source: json
  data_files: ascend_dataset.json
  train_on_input: False
  packed: False
  split: train

# Other Configs …
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Once you’ve specified the &lt;strong&gt;npu&lt;/strong&gt; device type in your configuration file, you can easily begin the model fine-tuning process. Simply run the following command, and torchtune will automatically start the fine-tuning process on the Ascend backend:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tune run &amp;lt;recipe_name&amp;gt; --config &amp;lt;your_config_file&amp;gt;.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;For example, if you’re using a full fine-tuning recipe (full_finetune_single_device) and your configuration file is located at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ascend_config.yaml&lt;/code&gt;, you can start the fine-tuning process with this command:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tune run full_finetune_single_device --config ascend_config.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This command will trigger the fine-tuning process, where torchtune will automatically handle data loading, model fine-tuning, evaluation, and other steps, leveraging Ascend NPU’s computational power to accelerate the training process.&lt;/p&gt;

&lt;p&gt;When you see the following log, it means that the model has been fine-tuned successfully on the Ascend NPU.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;……
dataset:
  _component_: torchtune.datasets.instruct_dataset
  data_files: ascend_dataset.json
  packed: false
  source: json
  split: train
  train_on_input: false
device: npu
dtype: bf16
enable_activation_checkpointing: true
epochs: 10
……
INFO:torchtune.utils._logging:Model is initialized with precision torch.bfloat16.
INFO:torchtune.utils._logging:Memory stats after model init:
        NPU peak memory allocation: 1.55 GiB
        NPU peak memory reserved: 1.61 GiB
        NPU peak memory active: 1.55 GiB
INFO:torchtune.utils._logging:Tokenizer is initialized from file.
INFO:torchtune.utils._logging:Optimizer is initialized.
INFO:torchtune.utils._logging:Loss is initialized.
……
NFO:torchtune.utils._logging:Model checkpoint of size 4.98 GB saved to /home/lcg/tmp/torchtune/ascend_llama/hf_model_0001_9.pt
INFO:torchtune.utils._logging:Model checkpoint of size 5.00 GB saved to /home/lcg/tmp/torchtune/ascend_llama/hf_model_0002_9.pt
INFO:torchtune.utils._logging:Model checkpoint of size 4.92 GB saved to /home/lcg/tmp/torchtune/ascend_llama/hf_model_0003_9.pt
INFO:torchtune.utils._logging:Model checkpoint of size 1.17 GB saved to /home/lcg/tmp/torchtune/ascend_llama/hf_model_0004_9.pt
INFO:torchtune.utils._logging:Saving final epoch checkpoint.
INFO:torchtune.utils._logging:The full model checkpoint, including all weights and configurations, has been saved successfully.You can now use this checkpoint for further training or inference.
10|20|Loss: 0.2997712790966034: 100%|██████████████████████████████| 2/2 [01:00&amp;lt;00:00, 30.03s/it]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;generating-with-fine-tuned-models&quot;&gt;Generating with Fine-Tuned Models&lt;/h2&gt;

&lt;p&gt;In the previous section, we used a fine-tuning dataset similar to &lt;a href=&quot;https://huggingface.co/datasets/ilyq69/identity.json&quot;&gt;identity.json&lt;/a&gt;, which is identity-related and made some adjustments to it.&lt;/p&gt;

&lt;p&gt;In this section, we will use our model to perform some generation tasks. For this, we’ll use the &lt;a href=&quot;https://github.com/pytorch/torchtune/blob/main/recipes/generate.py&quot;&gt;generate recipe&lt;/a&gt; and the associated &lt;a href=&quot;https://github.com/pytorch/torchtune/blob/main/recipes/configs/generation.yaml&quot;&gt;config&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let’s first copy over the config to our local working directory so we can make changes.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tune cp generation ./ascend_generation_config.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Let’s modify &lt;strong&gt;ascend_generation_config.yaml&lt;/strong&gt; to include the following changes. Again, you only need to replace two fields: &lt;strong&gt;output_dir&lt;/strong&gt; and &lt;strong&gt;checkpoint_files&lt;/strong&gt;.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Tokenizer
tokenizer:
    _component_: torchtune.models.llama3.llama3_tokenizer
    path: ${output_dir}/original/tokenizer.model
    prompt_template: null

# Checkpointer
checkpointer:
    _component_: torchtune.training.FullModelHFCheckpointer
    checkpoint_dir: ${output_dir}
    checkpoint_files: [
        Hf_model_0001_0.pt,
        ……
        hf_model_0004_9.pt,
    ]
    output_dir: ${output_dir}

# Generation arguments; defaults taken from gpt-fast
prompt:
    system: null
    user: &quot;你是谁?&quot;

# Environment
device: npu

# Other Configs …
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Next, we will run our generate recipe.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tune run generate --config ascend_generation_config.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The results of the execution are as follows, and we can see that our assistant has learned to identify itself as the Torchtune Helper!&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;……
INFO:torchtune.utils._logging:你是谁?您好，我是 Torchtune Helper，由 PyTorch 开发，旨在为用户提供智能化的回答和帮助。
INFO:torchtune.utils._logging:Time for inference: 4.75 sec total, 5.47 tokens/sec
INFO:torchtune.utils._logging:Bandwidth achieved: 89.18 GB/s
INFO:torchtune.utils._logging:Memory used: 0.00 GB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>Huawei PyTorch Team: Chenguang Li (Huawei), Mengqing Cao (Huawei)</name>
        
        
      </author>

      

      

      
        <summary type="html">In this blog, we will briefly introduce torchtune, the Ascend backend, and demonstrate how torchtune can be used to fine-tune models with Ascend.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">High-Performance Low-Bit Operators for PyTorch</title>
      <link href="https://pytorch.org/blog/hi-po-low-bit-operators/" rel="alternate" type="text/html" title="High-Performance Low-Bit Operators for PyTorch" />
      <published>2025-01-06T00:00:00-08:00</published>
      <updated>2025-01-06T00:00:00-08:00</updated>
      <id>https://pytorch.org/blog/hi-po-low-bit-operators</id>
      <content type="html" xml:base="https://pytorch.org/blog/hi-po-low-bit-operators/">&lt;p&gt;We are excited to announce the addition of embedding operators with low-bit weights (1-8 bit) and linear operators with 8-bit dynamically quantized activations and low-bit weights (1-8 bit) for Arm CPUs in TorchAO, PyTorch’s native low-precision library. These operators work seamlessly across all PyTorch surfaces, including eager, torch.compile, AOTI, and ExecuTorch, and are &lt;a href=&quot;https://github.com/pytorch/torchchat/blob/main/docs/quantization.md#experimental-torchao-lowbit-kernels&quot;&gt;available to use in torchchat&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In developing these linear operators, our focus was on &lt;strong&gt;code sharing between PyTorch and ExecuTorch&lt;/strong&gt;, and establishing a clear boundary between the higher-level operator and the lower-level kernel. This design &lt;strong&gt;allows third-party vendors to easily swap in their own kernels&lt;/strong&gt;. We also set out to &lt;strong&gt;create a place and infrastructure to experiment&lt;/strong&gt; with new CPU quantization ideas and test those across the PyTorch ecosystem.&lt;/p&gt;

&lt;h2 id=&quot;universal-low-bit-kernels&quot;&gt;Universal low-bit kernels&lt;/h2&gt;

&lt;p&gt;There is no hardware support for low-bit arithmetic. In what we call universal kernels, we explicitly separated the logic that unpacks low-bit values to int8 values, and the int8 GEMV kernel logic in a modular fashion. We started with an 8-bit kernel, for example, this &lt;a href=&quot;https://github.com/pytorch/ao/blob/299aacd0ab0e0cce376f56e18e5bb585d517b2e1/torchao/experimental/kernels/cpu/aarch64/linear/channelwise_8bit_activation_groupwise_lowbit_weight_1x8x16_f32_neondot-impl.h#L64&quot;&gt;1x8 8-bit GEMV kernel&lt;/a&gt; that uses the Arm neondot instruction. Within the 8-bit kernel, we invoke an &lt;a href=&quot;https://github.com/pytorch/ao/blob/299aacd0ab0e0cce376f56e18e5bb585d517b2e1/torchao/experimental/kernels/cpu/aarch64/linear/channelwise_8bit_activation_groupwise_lowbit_weight_1x8x16_f32_neondot-impl.h#L169&quot;&gt;inlined unpacking routine&lt;/a&gt; to convert low-bit values into int8 values. This unpacking routine is force-inlined and templated on some low-bit value. Our experiments showed no performance difference between using a separate force-inlined unpacking routine and directly embedding the unpacking code inline.&lt;/p&gt;

&lt;p&gt;The advantage of this modular design is improved development speed and code maintainability. After writing an 8-bit kernel, we quickly achieved full low-bit coverage by writing &lt;a href=&quot;https://github.com/pytorch/ao/tree/299aacd0ab0e0cce376f56e18e5bb585d517b2e1/torchao/experimental/kernels/cpu/aarch64/bitpacking&quot;&gt;simple bitpacking routines&lt;/a&gt;. In fact, developers who worked on the bit packing routines did not need to be experts on GEMV/GEMM kernel writing. We also reused the same bitpacking routines from the linear kernels &lt;a href=&quot;https://github.com/pytorch/ao/blob/299aacd0ab0e0cce376f56e18e5bb585d517b2e1/torchao/experimental/kernels/cpu/aarch64/embedding/embedding.h#L161&quot;&gt;within the embedding kernels&lt;/a&gt;. In future we could reuse the same bitpacking routines for universal GEMM kernels or kernels based on fma or i8mm instructions.&lt;/p&gt;

&lt;h2 id=&quot;shared-code-between-pytorch-and-executorch&quot;&gt;Shared code between PyTorch and ExecuTorch&lt;/h2&gt;

&lt;p&gt;To achieve shared code between PyTorch and ExecuTorch, we wrote kernels &lt;a href=&quot;https://github.com/pytorch/ao/blob/299aacd0ab0e0cce376f56e18e5bb585d517b2e1/torchao/experimental/kernels/cpu/aarch64/linear/linear.h&quot;&gt;using raw pointers instead of PyTorch tensors&lt;/a&gt;. Moreover, we implemented the &lt;a href=&quot;https://github.com/pytorch/ao/blob/299aacd0ab0e0cce376f56e18e5bb585d517b2e1/torchao/experimental/ops/linear_8bit_act_xbit_weight/op_linear_8bit_act_xbit_weight-impl.h#L259&quot;&gt;linear operator in a header &lt;/a&gt;that is included in separate &lt;a href=&quot;https://github.com/pytorch/ao/blob/299aacd0ab0e0cce376f56e18e5bb585d517b2e1/torchao/experimental/ops/linear_8bit_act_xbit_weight/op_linear_8bit_act_xbit_weight_aten.cpp&quot;&gt;PyTorch&lt;/a&gt; and &lt;a href=&quot;https://github.com/pytorch/ao/blob/299aacd0ab0e0cce376f56e18e5bb585d517b2e1/torchao/experimental/ops/linear_8bit_act_xbit_weight/op_linear_8bit_act_xbit_weight_executorch/w4s.cpp&quot;&gt;ExecuTorch&lt;/a&gt; operator registration code. By using only features common to both ATen and ExecuTorch tensors, we ensured compatibility between the two frameworks. For multi-threaded compute, we introduced &lt;a href=&quot;https://github.com/pytorch/ao/blob/299aacd0ab0e0cce376f56e18e5bb585d517b2e1/torchao/experimental/ops/parallel.h#L13&quot;&gt;torchao::parallel_1d&lt;/a&gt;, which compiles to either &lt;a href=&quot;https://github.com/pytorch/ao/blob/299aacd0ab0e0cce376f56e18e5bb585d517b2e1/torchao/experimental/ops/parallel-aten-impl.h&quot;&gt;at::parallel_for&lt;/a&gt; or &lt;a href=&quot;https://github.com/pytorch/ao/blob/299aacd0ab0e0cce376f56e18e5bb585d517b2e1/torchao/experimental/ops/parallel-executorch-impl.h&quot;&gt;ExecuTorch’s threadpool&lt;/a&gt; based on compile-time flags.&lt;/p&gt;

&lt;h2 id=&quot;swappable-kernels&quot;&gt;Swappable kernels&lt;/h2&gt;

&lt;p&gt;Our design for the higher-level multi-threaded linear operator is agnostic to the lower-level single-threaded kernels, allowing third-party vendors to swap in their own implementations. The interface between the operator and kernel is defined by a &lt;a href=&quot;https://github.com/pytorch/ao/blob/299aacd0ab0e0cce376f56e18e5bb585d517b2e1/torchao/experimental/ops/linear_8bit_act_xbit_weight/linear_8bit_act_xbit_weight.h#L14&quot;&gt;ukernel config&lt;/a&gt;, which specifies kernel function pointers for preparing activation data, preparing weight data, and running the kernel. The operator, responsible for tiling and scheduling, interacts with kernels solely through this config.&lt;/p&gt;

&lt;h2 id=&quot;performance&quot;&gt;Performance&lt;/h2&gt;

&lt;p&gt;In the table below, we show Llama3.1 8B token generation performance using 6 CPU threads on an M1 Macbook Pro with 32GB of RAM.&lt;/p&gt;

&lt;table class=&quot;table table-bordered&quot;&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Bitwidth x&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;torch.compile (Decode tokens/sec)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;ExecuTorch (Decode tokens/sec)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;ExecuTorch PTE size (GiB)&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;1
   &lt;/td&gt;
   &lt;td&gt;24.18
   &lt;/td&gt;
   &lt;td&gt;17.86
   &lt;/td&gt;
   &lt;td&gt;1.46
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;2
   &lt;/td&gt;
   &lt;td&gt;27.02
   &lt;/td&gt;
   &lt;td&gt;19.65
   &lt;/td&gt;
   &lt;td&gt;2.46
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;3
   &lt;/td&gt;
   &lt;td&gt;21.01
   &lt;/td&gt;
   &lt;td&gt;22.25
   &lt;/td&gt;
   &lt;td&gt;3.46
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;4
   &lt;/td&gt;
   &lt;td&gt;19.51
   &lt;/td&gt;
   &lt;td&gt;19.47
   &lt;/td&gt;
   &lt;td&gt;4.47
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;5
   &lt;/td&gt;
   &lt;td&gt;14.78
   &lt;/td&gt;
   &lt;td&gt;16.34
   &lt;/td&gt;
   &lt;td&gt;5.47
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;6
   &lt;/td&gt;
   &lt;td&gt;12.80
   &lt;/td&gt;
   &lt;td&gt;13.61
   &lt;/td&gt;
   &lt;td&gt;6.47
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;7
   &lt;/td&gt;
   &lt;td&gt;8.16
   &lt;/td&gt;
   &lt;td&gt;11.73
   &lt;/td&gt;
   &lt;td&gt;7.48
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;Results were run on an M1 Macbook Pro (with 8 perf cores, and 2 efficiency cores) with 32GB of RAM and 6 threads &lt;a href=&quot;https://github.com/pytorch/torchchat&quot;&gt;using torchchat&lt;/a&gt;. In each test, the max-seq-length of 128 tokens were generated. For each bit width x, the embedding layer was groupwise quantized to x-bits with group size 32. In the linear layers, activations were dynamically quantized per token to 8 bits and weights were groupwise quantized to x-bits with group size 256.  Our focus here is performance and we do not report accuracy or perplexity numbers. Depending on the model, lower bit widths may require quantization-aware training, quantizing a model with a mixture of bit widths, or adjusting the group sizes for acceptable accuracy.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/hi-po-low-bit.png&quot; alt=&quot;Llama 3.1 chart&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;try-them-out-and-contribute&quot;&gt;Try them out and contribute!&lt;/h2&gt;

&lt;p&gt;If you want to see the new low-bit kernels in action, give them a try by &lt;a href=&quot;https://github.com/pytorch/torchchat/tree/main&quot;&gt;setting up torchchat&lt;/a&gt; and &lt;a href=&quot;https://github.com/pytorch/torchchat/blob/main/docs/quantization.md#experimental-torchao-lowbit-kernels&quot;&gt;quantizing and running an LLM locally using the kernels&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you want to help contribute, consider adding support for one of the following areas:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/pytorch/ao/issues/1394&quot;&gt;Add universal low-bit GEMM kernels&lt;/a&gt; for Arm CPU, reusing the same bitpacking routines from the universal GEMV kernels.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/pytorch/ao/issues/1376&quot;&gt;Improve runtime selection&lt;/a&gt; of ukernel configs based on ISA, packing format, and activation shape.&lt;/li&gt;
  &lt;li&gt;Add low-bit kernels for other CPU ISAs like x86.&lt;/li&gt;
  &lt;li&gt;Integrate third-party libraries like &lt;a href=&quot;https://gitlab.arm.com/kleidi/kleidiai&quot;&gt;KleidiAI&lt;/a&gt; with the operator framework.&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>Scott Roy, Digant Desai, Kimish Patel</name>
        
        
      </author>

      

      

      
        <summary type="html">We are excited to announce the addition of embedding operators with low-bit weights (1-8 bit) and linear operators with 8-bit dynamically quantized activations and low-bit weights (1-8 bit) for Arm CPUs in TorchAO, PyTorch’s native low-precision library. These operators work seamlessly across all PyTorch surfaces, including eager, torch.compile, AOTI, and ExecuTorch, and are available to use in torchchat.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">PyTorch Grows as the Dominant Open Source Framework for AI and ML: 2024 Year in Review</title>
      <link href="https://pytorch.org/blog/2024-year-in-review/" rel="alternate" type="text/html" title="PyTorch Grows as the Dominant Open Source Framework for AI and ML: 2024 Year in Review" />
      <published>2024-12-23T00:00:00-08:00</published>
      <updated>2024-12-23T00:00:00-08:00</updated>
      <id>https://pytorch.org/blog/2024-year-in-review</id>
      <content type="html" xml:base="https://pytorch.org/blog/2024-year-in-review/">&lt;p&gt;This past year was a monumental year for PyTorch from major releases to the flagship PyTorch Conference. We’ve seen incredible growth in contributions from more than 3,500 individuals and 3,000 organizations. It’s safe to say PyTorch has now become the dominant deep learning framework for AI/ML.  PyTorch leads the model training space with a 63% adoption rate according to the recent &lt;a href=&quot;https://www.linuxfoundation.org/research/gen-ai-2024&quot;&gt;Shaping the Future of Generative AI Report&lt;/a&gt; from the Linux Foundation.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2024-year-in-review/fg1.jpg&quot; alt=&quot;group at a conference&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The PyTorch Foundation was formed in 2022 with the goal to drive the adoption of AI tooling by fostering and sustaining an ecosystem of open source, vendor-neutral projects centered around PyTorch and today remains a vibrant, collaborative hub created for and by the deep learning community. As we wrap up the year, let’s take a look back at a few highlights and how this year has been one of growth, collaboration, innovation, and community.&lt;/p&gt;

&lt;h2 id=&quot;2024-highlights-a-year-of-growth-and-impact&quot;&gt;2024 Highlights: A Year of Growth and Impact&lt;/h2&gt;

&lt;p&gt;PyTorch accelerated its growth this year. Contributions are up 133%, from double the amount of  organizations worldwide compared to last year.&lt;/p&gt;

&lt;p&gt;The project has seen 20% year-over-year growth in new repositories using PyTorch, and a 30% increase in forks and users this past year.&lt;/p&gt;

&lt;p&gt;Over 70% of AI research implementations are now using PyTorch.&lt;/p&gt;

&lt;p&gt;Statistics based on the &lt;a href=&quot;https://www.linuxfoundation.org/resources/publications/linux-foundation-annual-report-2024&quot;&gt;2024 Linux Foundation Annual Report&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2024-year-in-review/fg2.jpg&quot; alt=&quot;people at a conference&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PyTorch Tools ecosystem grew by over 25%, enhancing both software and hardware capabilities. Working with all major cloud service providers, dozens of major software vendors, and industry partners, PyTorch is setting a new bar for the pace and breadth of AI innovation.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2024-year-in-review/fg3.jpg&quot; alt=&quot;people at a conference&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This year featured 4 milestone releases for PyTorch in the 2.2, 2.3, 2.4 and 2.5 releases. We observed the release of various hallmark features like &lt;a href=&quot;https://pytorch.org/blog/pytorch2-2/#beta-aotinductor-ahead-of-time-compilation-and-deployment-for-torchexport-ed-programs&quot;&gt;AOTInductor&lt;/a&gt;, &lt;a href=&quot;https://pytorch.org/blog/pytorch2-2/#beta-aotinductor-ahead-of-time-compilation-and-deployment-for-torchexport-ed-programs&quot;&gt;FlashAttention-2 support&lt;/a&gt;, &lt;a href=&quot;https://pytorch.org/blog/pytorch2-3/#beta-tensor-parallelism-introduces-more-efficient-ways-to-train-llms&quot;&gt;Tensor Parallelism&lt;/a&gt;, a new &lt;a href=&quot;https://pytorch.org/blog/pytorch2-4/#beta-new-higher-level-python-custom-operator-api&quot;&gt;Python Custom Operator API&lt;/a&gt;, and the introduction of &lt;a href=&quot;https://pytorch.org/blog/pytorch2-5/#prototype-flexattention&quot;&gt;FlexAttention&lt;/a&gt;. Engineers from across PyTorch Foundation member companies have also come together to introduce support and optimizations for platforms like &lt;a href=&quot;https://pytorch.org/blog/pytorch2-4/#torchcompile-optimizations-for-aws-graviton-aarch64-linux-processors&quot;&gt;Intel GPUs&lt;/a&gt; (XPU), AWS &lt;a href=&quot;https://pytorch.org/blog/pytorch2-4/#torchcompile-optimizations-for-aws-graviton-aarch64-linux-processors&quot;&gt;Graviton&lt;/a&gt; processors, Inductor performance, etc.&lt;/p&gt;

&lt;p&gt;Throughout the year the PyTorch Team has been working hard to introduce a number of new PyTorch-native libraries! The &lt;a href=&quot;https://pytorch.org/blog/executorch-alpha/&quot;&gt;ExecuTorch&lt;/a&gt; team released their alpha in collaboration with partners from Arm, Apple, and Qualcomm Technologies, Inc. then quickly followed with a &lt;a href=&quot;https://pytorch.org/blog/executorch-beta/&quot;&gt;beta&lt;/a&gt; focused on stability and adding MediaTek. &lt;a href=&quot;https://pytorch.org/blog/torchtune-fine-tune-llms/&quot;&gt;TorchTune&lt;/a&gt; established a PyTorch-native library for easily fine-tuning large language models. &lt;a href=&quot;https://pytorch.org/blog/pytorch-native-architecture-optimization/&quot;&gt;TorchAO&lt;/a&gt; introduced a PyTorch native library that makes models faster and smaller by leveraging low bit dtypes, quantization and sparsity. &lt;a href=&quot;https://pytorch.org/blog/torchcodec/&quot;&gt;TorchCodec&lt;/a&gt; was launched to give developers a simple, performant, and PyTorch native way to decode videos into tensors. &lt;a href=&quot;https://pytorch.org/blog/torchrec-fbgemm-1/&quot;&gt;TorchRec&lt;/a&gt; 1.0 was released, the first stable release of the PyTorch native recommendation systems library.&lt;/p&gt;

&lt;p&gt;We’ve also had a number of strong technical showcases throughout the year to highlight how PyTorch can be used! &lt;a href=&quot;https://arxiv.org/html/2410.06511v1&quot;&gt;TorchTitan&lt;/a&gt; exhibited what an open source, PyTorch-native distributed training system could look like for training large language models (LLMs). &lt;a href=&quot;https://pytorch.org/blog/torchchat-local-llm-inference/&quot;&gt;TorchChat&lt;/a&gt; showcased how to seamlessly and performantly run LLMs across laptop, desktop, and mobile devices.&lt;/p&gt;

&lt;p&gt;As well we were very excited to include &lt;a href=&quot;https://pytorch.org/blog/enhancing-deep-learning/&quot;&gt;multiple new projects&lt;/a&gt; into the PyTorch ecosystem throughout 2024, including the introduction of  &lt;a href=&quot;https://pytorch.org/blog/vllm-joins-pytorch/&quot;&gt;vLLM&lt;/a&gt; into the PyTorch Ecosystem, a state-of-the-art inference engine, which gives machine learning engineers an easy, fast, and cheap way of serving LLMs. If you are interested in joining the PyTorch Ecosystem, please &lt;a href=&quot;https://pytorch.org/ecosystem/join&quot;&gt;join&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2024-year-in-review/fg4.jpg&quot; alt=&quot;people at a conference&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In June in Paris, France we premiered the&lt;a href=&quot;https://pytorch.org/blog/pytorch-documentary/&quot;&gt; official PyTorch documentary&lt;/a&gt; on powering the AI Revolution that spotlights PyTorch’s vibrant ecosystem and its role in advancing AI innovation. The film unveiled the authentic narrative of PyTorch’s inception, attributing its existence to a dedicated group of unsung heroes driving technological innovation.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2024-year-in-review/fg5.jpg&quot; alt=&quot;people at a conference&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://pytorch.org/blog/pytorch-conference-2024-recap/&quot;&gt;PyTorch Conference 2024&lt;/a&gt;, brought in triple the registrations compared to 2023, reflecting the rapid growth of AI and machine learning communities around open source technologies. The two day event included insightful talks, hands-on sessions, and lively discussions about the future of AI, covering everything from generative AI to large language models.&lt;/p&gt;

&lt;p&gt;A brand new Startup Showcase featured early-stage founders pitching their AI startups to a panel of top venture capitalists, a DL Compiler Mini-Summit took a deep dive into the advances in deep learning (DL) compilers that are transforming AI workloads, and a Fine-Tuning Mini-Summit brought together a thriving community of researchers, developers, practitioners and hobbyists to discuss topics like memory efficiency, parameter-efficient fine-tuning, and performance at scale.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2024-year-in-review/fg6.jpg&quot; alt=&quot;speaking on stage at a conference&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Outstanding contributors were honored with &lt;a href=&quot;https://pytorch.org/ecosystem/contributor-awards-2024&quot;&gt;PyTorch Contributor Awards&lt;/a&gt;. Congratulations to this year’s nominees and recipients for the outstanding individuals and teams who have played a pivotal role in PyTorch’s journey this year.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2024-year-in-review/fg7.jpg&quot; alt=&quot;people at a conference&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PyTorch Foundation membership is growing with the addition of Arm and Rebellions this year. At the year-end mark, Premier Members include: AMD, Arm, AWS, Google Cloud, Huawei, Hugging Face, IBM, Intel, Lightning AI, Meta, Microsoft Azure, and NVIDIA. General Members include: Graphcore, Rebellions, and Snowflake. If your organization is interested in joining, find out how you can &lt;a href=&quot;/join&quot;&gt;become a member&lt;/a&gt; of the PyTorch Foundation.&lt;/p&gt;

&lt;p&gt;PyTorch hosted numerous in-person and virtual events, including&lt;a href=&quot;https://pytorch.org/blog/pytorch-docathon-h2-2024-wrap-up/&quot;&gt; The PyTorch Docathon&lt;/a&gt; where contributors worked to improve PyTorch documentation and foster collaboration, Local meetups around the world brought together interested parties in locations from Shanghai to Seoul, and more than a dozen &lt;a href=&quot;https://www.youtube.com/pytorch&quot;&gt;webinars&lt;/a&gt; brought in attendees from everywhere during our Summer Webinar Series, live Q&amp;amp;As, and Expert Exchanges.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2024-year-in-review/fg8.jpg&quot; alt=&quot;Matt speaking at a conference&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PyTorch Foundation welcomed new leadership this year.&lt;a href=&quot;https://pytorch.org/blog/new-executive-director/&quot;&gt; Executive Director Matt White&lt;/a&gt; took the reins in April and immediately began raising the profile of PyTorch across the AI landscape. The&lt;a href=&quot;https://pytorch.org/tac&quot;&gt; Technical Advisory Council (TAC)&lt;/a&gt; also elected&lt;a href=&quot;https://pytorch.org/blog/tac-elects-new-leadership/&quot;&gt; new leadership&lt;/a&gt; with  Luca Antiga, Lightning AI as the Chair and Jiong Gong, Intel as Vice Chair.&lt;/p&gt;

&lt;p&gt;The&lt;a href=&quot;https://pytorch.org/governing-board&quot;&gt; PyTorch Governing Board&lt;/a&gt; continued to set the direction and lead the Foundation in accomplishing its mission. The PyTorch Marketing and Outreach Committee developed programs to maximize the visibility of PyTorch and advance the interests of the community. The PyTorch CI Working Group assembled to successfully migrate the PyTorch CI pipeline to the Linux Foundation.&lt;/p&gt;

&lt;p&gt;Our community joined us on social media with 775 thousand followers strong across X, LinkedIn, Facebook, and YouTube with more than 12 million impressions of PyTorch content throughout the year.  The PyTorch Ecosystem also grew, adding many new projects to leverage PyTorch deep learning across many vertical domains.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2024-year-in-review/fg9.jpg&quot; alt=&quot;people at a conference&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PyTorch was mentioned in the media in top technology publications such as The New Stack’s article on &lt;a href=&quot;https://thenewstack.io/why-pytorch-gets-all-the-love/&quot;&gt;Why PyTorch Gets All the Love&lt;/a&gt; and InfoWorld’s article on how the TorchAO&lt;a href=&quot;https://www.infoworld.com/article/3543651/pytorch-library-makes-models-faster-and-smaller.html&quot;&gt; PyTorch library makes models faster and smaller&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We published 74 technical and community blogs, and nearly ten million people visited the PyTorch website throughout the year.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2024-year-in-review/fg10.jpg&quot; alt=&quot;fire dancers at a conference&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Thanks to each of you who helped make this year an outstanding success! The evolution and growth we’ve seen PyTorch undergo over the past year is driven by the passion, dedication, and ingenuity of this amazing community. Looking ahead to next year, we’re excited to build on this momentum as we continue to push the boundaries of AI.&lt;/p&gt;

&lt;p&gt;Save the date for the &lt;a href=&quot;https://events.linuxfoundation.org/pytorch-conference-2025/&quot;&gt;PyTorch Conference&lt;/a&gt; which will be held October 22-23, 2025 in San Francisco. 2025 promises even greater innovation and stronger community collaboration.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Eli Uriegas, Meta and Jennifer Bly, PyTorch Foundation</name>
        
        
      </author>

      

      

      
        <summary type="html">This past year was a monumental year for PyTorch from major releases to the flagship PyTorch Conference. We’ve seen incredible growth in contributions from more than 3,500 individuals and 3,000 organizations. It’s safe to say PyTorch has now become the dominant deep learning framework for AI/ML. PyTorch leads the model training space with a 63% adoption rate according to the recent Shaping the Future of Generative AI Report from the Linux Foundation.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Improve RAG performance with torch.compile on AWS Graviton Processors</title>
      <link href="https://pytorch.org/blog/improve-rag-performance/" rel="alternate" type="text/html" title="Improve RAG performance with torch.compile on AWS Graviton Processors" />
      <published>2024-12-20T00:00:00-08:00</published>
      <updated>2024-12-20T00:00:00-08:00</updated>
      <id>https://pytorch.org/blog/improve-rag-performance</id>
      <content type="html" xml:base="https://pytorch.org/blog/improve-rag-performance/">&lt;p&gt;Large Language Models (LLMs) are trained on vast volumes of data and use billions of parameters to support tasks like answering questions, translating languages, and completing sentences. There are a few challenges when working with LLMs such as domain knowledge gaps, factuality issues, and hallucination, which affect their reliability especially for the fields that require high levels of accuracy, such as healthcare, law, or engineering. Retrieval Augmented Generation (RAG) provides a solution to mitigate some of these issues by augmenting LLMs with a specific domain or an organization’s internal knowledge base, without the need to retrain the model.&lt;/p&gt;

&lt;p&gt;The RAG knowledge source is generally business specific databases which are typically deployed on general-purpose CPU infrastructure. So, deploying RAG on general-purpose CPU infrastructure alongside related business services is both efficient and cost-effective. With this motivation, we evaluated RAG deployment on &lt;a href=&quot;https://aws.amazon.com/ec2/graviton/&quot;&gt;AWS Graviton&lt;/a&gt; based Amazon EC2 instances which have been delivering up to &lt;a href=&quot;https://aws.amazon.com/ec2/graviton/getting-started/&quot;&gt;40% price-performance advantage&lt;/a&gt; compared to comparable instances for the majority of the workloads including databases, in-memory caches, big data analytics, media codecs, gaming servers, and machine learning inference.&lt;/p&gt;

&lt;p&gt;In the past we published a few blog posts on how PyTorch was optimized for AWS Graviton processors to accelerate ML Inference performance for both eager mode (&lt;a href=&quot;https://pytorch.org/blog/optimized-pytorch-w-graviton/&quot;&gt;blog&lt;/a&gt;) and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.compile&lt;/code&gt; mode (&lt;a href=&quot;https://pytorch.org/blog/accelerated-pytorch-inference/&quot;&gt;blog&lt;/a&gt;). In this blog we cover how to deploy a typical RAG workload using PyTorch and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.compile&lt;/code&gt;, how we improved its performance up to &lt;strong&gt;1.7x&lt;/strong&gt; for embedding model and &lt;strong&gt;1.3x&lt;/strong&gt; for RAG query on AWS Graviton3-based m7g.xlarge instance compared to the default PyTorch “eager mode”, and finally a few recommendations that you can apply for your RAG use cases.&lt;/p&gt;

&lt;h2 id=&quot;how-to-optimize-rag&quot;&gt;How to Optimize RAG?&lt;/h2&gt;

&lt;p&gt;Without RAG, the LLM takes the user input and creates a response based on information it was trained on (what it already knows). With RAG, an information retrieval component is introduced that utilizes the user input to first pull information from a new data source. The user query and the relevant information are both given to the LLM. The LLM uses the new knowledge and its training data to create better responses. The following diagram shows the conceptual flow of using RAG with LLMs.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/improve-rag-performance.png&quot; alt=&quot;Image 1: Conceptual flow of using RAG with LLMs&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Image 1&lt;/strong&gt;: Conceptual flow of using RAG with LLMs&lt;/p&gt;

&lt;p&gt;Source:&lt;a href=&quot;https://aws.amazon.com/what-is/retrieval-augmented-generation/&quot;&gt; https://aws.amazon.com/what-is/retrieval-augmented-generation/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;embedding-model&quot;&gt;Embedding model&lt;/h3&gt;

&lt;p&gt;At the core of RAG is an embedding model that takes the text data and converts into a vector representation. These vectors are then stored in a vector db. When a user makes a query, the query is first converted to a vector and the RAG does a similarity search on the vector db. Hence, the first step in optimizing RAG performance is optimizing an embedding model’s inference performance. We used the AWS Graviton3-based m7g.xlarge instance and the HuggingFace sentence-transformer embedding model for the optimization work. Here is a sample script for profiling the HuggingFace sentence-transformer embedding model inference with PyTorch Eager mode.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import torch
from torch.profiler import profile, ProfilerActivity, record_function
from transformers import AutoModel, AutoTokenizer

model_name = &quot;sentence-transformers/all-mpnet-base-v2&quot;
input_text = [&quot;This is an example sentence&quot;, &quot;Each sentence is converted&quot;]

model = AutoModel.from_pretrained(model_name)
tokenizer = AutoTokenizer.from_pretrained(model_name)

encoded_input = tokenizer(
    input_text, padding=True, truncation=True, return_tensors=&quot;pt&quot;
)

warmup, actual = 100, 100
model.eval()

with torch.no_grad():
    # warmup
    for i in range(warmup):
        embeddings = model(**encoded_input)

    with profile(activities=[ProfilerActivity.CPU]) as prof:
        with record_function(&quot;model_inference&quot;):
            for i in range(actual):
                embeddings = model(**encoded_input)
        print(prof.key_averages().table(sort_by=&quot;self_cpu_time_total&quot;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;eager-mode&quot;&gt;Eager mode&lt;/h4&gt;

&lt;p&gt;Since PyTorch eager mode was already optimized on AWS Graviton processors with the following runtime environment settings, we included them in the baseline and measured the following performance. Please refer to &lt;a href=&quot;https://pytorch.org/blog/optimized-pytorch-w-graviton/&quot;&gt;Optimized PyTorch 2.0 Inference with AWS Graviton processors&lt;/a&gt; for more details on how we optimized the PyTorch eager mode on AWS Graviton processors.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Enable the fast math GEMM kernels, to accelerate fp32 inference with bfloat16 gemm
export DNNL_DEFAULT_FPMATH_MODE=BF16

# Enable Linux Transparent Huge Page (THP) allocations,
# to reduce the tensor memory allocation latency
export THP_MEM_ALLOC_ENABLE=1

# Set LRU Cache capacity to cache the primitives and avoid redundant
# memory allocations
export LRU_CACHE_CAPACITY=1024
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;---------------------------  ------------  ------------  ------------  ------------  ------------  ------------  
                       Name    Self CPU %      Self CPU   CPU total %     CPU total  CPU time avg    # of Calls  
---------------------------  ------------  ------------  ------------  ------------  ------------  ------------  
                aten::addmm        61.01%        2.638s        62.49%        2.702s     370.197us          7300  
            model_inference        12.01%     519.161ms       100.00%        4.324s        4.324s             1  
                  aten::bmm         6.25%     270.084ms        11.96%     517.089ms     215.454us          2400  
               aten::select         3.98%     172.165ms         5.34%     230.863ms       1.331us        173500  
                aten::copy_         2.11%      91.133ms         2.11%      91.133ms       6.200us         14700   
---------------------------  ------------  ------------  ------------  ------------  ------------  ------------  
Self CPU time total: 4.324s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Table 1:&lt;/strong&gt; Profiler output for HuggingFace sentence-transformer embedding model inference on AWS Graviton3-based m7g.xlarge instance with PyTorch Eager mode&lt;/p&gt;

&lt;p&gt;Next, we added &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.compile&lt;/code&gt;, &lt;a href=&quot;https://pytorch.org/blog/accelerated-pytorch-inference/#technical-deep-dive-what-are-the-challenges-and-optimization-details&quot;&gt;weights pre-packing&lt;/a&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.inference_mode&lt;/code&gt; and observed around 1.7x performance improvement. The following section talks about each of these optimizations and the resulting speedup.&lt;/p&gt;

&lt;h4 id=&quot;torchcompile&quot;&gt;torch.compile&lt;/h4&gt;

&lt;p&gt;In contrast to eager mode, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.compile&lt;/code&gt; pre-compiles the entire model into a single graph in a manner that’s optimized for running on given hardware. Please refer to &lt;a href=&quot;https://pytorch.org/blog/accelerated-pytorch-inference/&quot;&gt;Accelerated PyTorch Inference with torch.compile on AWS Graviton processors&lt;/a&gt; for more details on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.compile&lt;/code&gt; features and how we optimized them on AWS Graviton processors. Invoke &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.compile&lt;/code&gt; as shown in the following snippet to trigger PyTorch dynamo compilation for the model. This resulted in around 1.04x performance improvement from the baseline.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;model = torch.compile(model)

----------------------------  ------------  ------------  ------------  ------------  ------------  ------------  
                        Name    Self CPU %      Self CPU   CPU total %     CPU total  CPU time avg    # of Calls  
----------------------------  ------------  ------------  ------------  ------------  ------------  ------------  
                 aten::addmm        64.46%        2.675s        66.66%        2.766s     378.905us          7300  
       Torch-Compiled Region        19.76%     820.085ms        99.04%        4.109s      41.094ms           100  
                   aten::bmm         6.66%     276.216ms        12.52%     519.527ms     216.470us          2400  
                aten::select         3.98%     164.991ms         5.41%     224.488ms       1.299us        172800  
            aten::as_strided         1.66%      69.039ms         1.66%      69.039ms       0.383us        180100  
----------------------------  ------------  ------------  ------------  ------------  ------------  ------------  
Self CPU time total: 4.149s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Table 2:&lt;/strong&gt; Profiler output for HuggingFace sentence-transformer embedding model inference on AWS Graviton3-based m7g.xlarge instance with torch.compile mode&lt;/p&gt;

&lt;h4 id=&quot;weights-pre-packing&quot;&gt;Weights pre-packing&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.compile&lt;/code&gt; opens up opportunities like pre-packing the model weights into a format that is more suitable for the given hardware during the model compilation, thus improving the performance. Set the following config to trigger weights pre-packing. This resulted in around 1.69x improvement from the baseline.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import torch._inductor.config as config
config.cpp.weight_prepack=True
config.freezing=True
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-----------------------------  ------------  ------------  ------------  ------------  ------------  ------------  
                         Name    Self CPU %      Self CPU   CPU total %     CPU total  CPU time avg    # of Calls  
-----------------------------  ------------  ------------  ------------  ------------  ------------  ------------  
    mkldnn::_linear_pointwise        39.10%     994.821ms        41.50%        1.056s     144.628us          7300  
        Torch-Compiled Region        35.12%     893.675ms        98.42%        2.504s      25.043ms           100  
                    aten::bmm        10.96%     278.859ms        21.66%     551.073ms     229.614us          2400  
                 aten::select         7.34%     186.838ms         9.98%     253.840ms       1.469us        172800  
             aten::as_strided         2.63%      67.002ms         2.63%      67.002ms       0.388us        172800   
-----------------------------  ------------  ------------  ------------  ------------  ------------  ------------  
Self CPU time total: 2.544s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Table 3:&lt;/strong&gt; Profiler output for HuggingFace sentence-transformer embedding model inference on AWS Graviton3-based m7g.xlarge instance with torch.compile and weights pre-packing&lt;/p&gt;

&lt;h4 id=&quot;torchinference_mode&quot;&gt;torch.inference_mode&lt;/h4&gt;

&lt;p&gt;Additionally, use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.inference_mode()&lt;/code&gt; to get savings from turning off version control for tensors and view tracking of tensors. Please refer to the PyTorch&lt;a href=&quot;https://pytorch.org/docs/stable/generated/torch.autograd.grad_mode.inference_mode.html&quot;&gt; documentation&lt;/a&gt; for more details.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;with torch.inference_mode():
# instead of
with torch.no_grad():
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-----------------------------  ------------  ------------  ------------  ------------  ------------  ------------  
                         Name    Self CPU %      Self CPU   CPU total %     CPU total  CPU time avg    # of Calls  
-----------------------------  ------------  ------------  ------------  ------------  ------------  ------------  
    mkldnn::_linear_pointwise        38.92%     987.276ms        41.17%        1.044s     143.056us          7300  
        Torch-Compiled Region        34.92%     885.895ms        98.45%        2.498s      24.975ms           100  
                    aten::bmm        11.25%     285.292ms        22.22%     563.594ms     234.831us          2400  
                 aten::select         7.74%     196.223ms        10.22%     259.251ms       1.500us        172800  
             aten::as_strided         2.48%      63.027ms         2.48%      63.027ms       0.365us        172800  
-----------------------------  ------------  ------------  ------------  ------------  ------------  ------------  
Self CPU time total: 2.537s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Table 4:&lt;/strong&gt; Profiler output for HuggingFace sentence-transformer embedding model inference on AWS Graviton3-based m7g.xlarge instance with torch.compile, weights pre-packing, and inference_mode&lt;/p&gt;

&lt;p&gt;The following table shows the incremental performance improvements achieved for the standalone embedding model inference.&lt;/p&gt;

&lt;table class=&quot;table table-bordered&quot;&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Optimization level&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Latency measured (in sec)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Improvement over the baseline&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;PyTorch eager mode (Baseline)
   &lt;/td&gt;
   &lt;td&gt;0.04324
   &lt;/td&gt;
   &lt;td&gt;NA
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;torch.compile
   &lt;/td&gt;
   &lt;td&gt;0.04149
   &lt;/td&gt;
   &lt;td&gt;1.04x
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;weights pre-packing
   &lt;/td&gt;
   &lt;td&gt;0.02544
   &lt;/td&gt;
   &lt;td&gt;1.69x
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;torch.inference_mode
   &lt;/td&gt;
   &lt;td&gt;0.02537
   &lt;/td&gt;
   &lt;td&gt;1.70x
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;The following script is an updated example for the embedding model inference with the previously discussed optimizations included. The optimizations are highlighted in &lt;span style=&quot;color: green;&quot;&gt;GREEN&lt;/span&gt;.&lt;/p&gt;

&lt;div class=&quot;code-block&quot;&gt;
&lt;pre&gt;
import torch
from torch.profiler import profile, record_function, ProfilerActivity
from transformers import AutoTokenizer, AutoModel
&lt;span style=&quot;color: green;&quot;&gt;import torch._inductor.config as config&lt;/span&gt;
&lt;span style=&quot;color: green;&quot;&gt;config.cpp.weight_prepack=True&lt;/span&gt;
&lt;span style=&quot;color: green;&quot;&gt;config.freezing=True&lt;/span&gt;

model_name = &quot;sentence-transformers/all-mpnet-base-v2&quot;
input_text = ['This is an example sentence', 'Each sentence is converted']

model = AutoModel.from_pretrained(model_name)
tokenizer = AutoTokenizer.from_pretrained(model_name)

encoded_input = tokenizer(input_text, padding=True, truncation=True, return_tensors='pt')

warmup , actual = 100, 100
model.eval()
&lt;span style=&quot;color: green;&quot;&gt;model = torch.compile(model)&lt;/span&gt;

&lt;span style=&quot;color: green;&quot;&gt;with torch.inference_mode():&lt;/span&gt;
#instead of with torch.no_grad()
# warmup
  for i in range(warmup):
  	embeddings = model(**encoded_input)

  with profile(activities=[ProfilerActivity.CPU]) as prof:
	with record_function(&quot;model_inference&quot;):
  	for i in range(actual):
     	embeddings = model(**encoded_input)
  print(prof.key_averages().table(sort_by=&quot;self_cpu_time_total&quot;))
&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;end-to-end-rag-scenario-on-cpu&quot;&gt;End-to-End RAG scenario on CPU&lt;/h3&gt;

&lt;p&gt;After optimizing the embedding model inference, we started with a PyTorch eager mode based RAG setup, mainly to validate the functionality on the CPU backend. We built the RAG solution with&lt;a href=&quot;https://api.python.langchain.com/en/latest/embeddings/langchain_community.embeddings.huggingface.HuggingFaceEmbeddings.html&quot;&gt; HuggingFaceEmbeddings&lt;/a&gt; from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;langchain_community.embeddings&lt;/code&gt;, as shown in the following code snippet.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from langchain_community.embeddings import HuggingFaceEmbeddings
from langchain_community.vectorstores import FAISS
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain_community.document_loaders.recursive_url_loader import RecursiveUrlLoader
from langchain.prompts import PromptTemplate
from langchain_core.prompts import format_document
from bs4 import BeautifulSoup as Soup
import torch

url =  &quot;https://pytorch.org/blog/pytorch2-5/&quot;
chunk_size = 1000
chunk_overlap = 0
embedding_model = &quot;sentence-transformers/all-mpnet-base-v2&quot;
N = 5

question = &quot;What's new in PyTorch 2.5?&quot;

from transformers import AutoTokenizer, AutoModel
from typing import Any, List

loader = RecursiveUrlLoader(
            url=url, max_depth=3, extractor=lambda x: Soup(x, &quot;html.parser&quot;).text
        )       
docs = loader.load()

# Split the document into chunks with a specified chunk size
text_splitter = RecursiveCharacterTextSplitter(chunk_size=chunk_size, chunk_overlap=chunk_overlap)
all_splits = text_splitter.split_documents(docs)

# Store the document into a vector store with a specific embedding model
model = HuggingFaceEmbeddings(model_name=embedding_model)

warmup , actual = 100, 100

with torch.inference_mode():
    vectorstore = FAISS.from_documents(all_splits, model)

    for i in range(warmup):
        searchDocs = vectorstore.similarity_search(question, k=N)

    import time

    start = time.time()
    for i in range(actual):
        searchDocs = vectorstore.similarity_search(question, k=N)
    end = time.time()
    print(f&quot;Time for 1 inference is {(end-start)/actual} seconds&quot;)

    doc_prompt = PromptTemplate.from_template(&quot;{page_content}&quot;)
    context = &quot;&quot;
    for i, doc in enumerate(searchDocs):
        context += f&quot;\n{format_document(doc, doc_prompt)}\n&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Next, our goal was to optimize the end-to-end RAG use case with torch.compile and weights pre-packing that gave 1.7x improvement for the standalone embedding model inference. However, the optimizations didn’t work out of the box for the RAG scenario.&lt;/p&gt;

&lt;h3 id=&quot;what-are-the-challenges-and-solutions-to-achieve-similar-gains-in-an-end-to-end-rag-scenario&quot;&gt;What are the challenges and solutions to achieve similar gains in an end-to-end RAG scenario?&lt;/h3&gt;

&lt;h4 id=&quot;challenge-1-model-handle&quot;&gt;Challenge 1: model handle&lt;/h4&gt;

&lt;p&gt;There was no way to get the model handle that was instantiated with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HuggingFaceEmbeddings&lt;/code&gt;, and the wrapper class doesn’t provide compile APIs. So, there was no way for our application to invoke &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.compile&lt;/code&gt; to trigger the PyTorch dynamo compilation process.&lt;/p&gt;

&lt;h4 id=&quot;solution&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;We implemented our custom embedding class so that we can get a handle for the model. This instantiated the embedding model from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sentence-transformers&lt;/code&gt; , and maintained the handle for immediate compilation or compilation at a later stage. With this, we were able to trigger &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.compile&lt;/code&gt; and hence the dynamo compilation.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class CustomEmbedding(HuggingFaceEmbeddings):
    
    def __init__(self, **kwargs: Any):
        &quot;&quot;&quot;Initialize the sentence_transformer.&quot;&quot;&quot;
        super().__init__(**kwargs)

        # Load model from HuggingFace Hub
        self.client = AutoModel.from_pretrained(self.model_name)
    class Config:
        arbitrary_types_allowed = True


    
    def embed_documents(self, texts: List[str]) -&amp;gt; List[List[float]]:
        &quot;&quot;&quot;Compute doc embeddings using a HuggingFace transformer model.
        Args:
            texts: The list of texts to embed.
        Returns:
            List of embeddings, one for each text.
        &quot;&quot;&quot;

        texts = list(map(lambda x: x.replace(&quot;\n&quot;, &quot; &quot;), texts))

        # Tokenize sentences
        tokenizer = AutoTokenizer.from_pretrained(self.model_name)
        encoded_input = tokenizer(texts, padding=True, truncation=True, return_tensors='pt')
        
        embeddings = self.client(
           **encoded_input, output_hidden_states=True
        )
        embeddings = embeddings.pooler_output.detach().numpy()

        return embeddings.tolist()

# instead of model = HuggingFaceEmbeddings(model_name=embedding_model)
model = CustomEmbedding(model_name=embedding_model)

# torch.compile the model
model.client = torch.compile(model.client)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;challenge-2-triggering-the-optimization&quot;&gt;Challenge 2: triggering the optimization&lt;/h4&gt;

&lt;p&gt;For a typical inference scenario where the graph is frozen and gradient calculations are disabled, Torch inductor (the compiler backend we used for CPUs) invokes hardware specific optimizations like graph rewrite into more performant operators, operator fusion, and weights pre-packing. Though Torch dynamo was able to see the model and trigger generic compilation, it failed to trigger these additional Fx passes in the Torch inductor.&lt;/p&gt;

&lt;p&gt;There were two main reasons for Torch inductor not triggering the optimization passes: (1) The application didn’t set &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;no_grad()&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inference_mode()&lt;/code&gt; for torch inductor to detect that the graph was frozen; and (2) We hit a limitation with the torch.compile framework, where, if the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;no_grad&lt;/code&gt; is set just at the beginning of the compiled region, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.compile&lt;/code&gt; wouldn’t be able to detect it while invoking the inductor &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fx&lt;/code&gt; passes because it would not have hit the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;no_grad&lt;/code&gt; region by then. Please refer to&lt;a href=&quot;https://github.com/pytorch/pytorch/issues/125474&quot;&gt; this GitHub issue&lt;/a&gt; for more details.&lt;/p&gt;

&lt;h4 id=&quot;solution-1&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;We work around this limitation by moving the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;no_grad()&lt;/code&gt; context into the application code from within the model class. With this, the model compilation happened as expected and gave around 1.3x performance improvement when we profiled the stable inference pass for eager and compiled versions.&lt;/p&gt;

&lt;h4 id=&quot;challenge-3-extra-compilation&quot;&gt;Challenge 3: extra compilation&lt;/h4&gt;

&lt;p&gt;With the previous fixes, the query lookup inference performance was improved, but not the total execution time of the benchmarking script. We root-caused it to redundant compilation for the model during the RAG inference. Further deep diving revealed that it was because of the batch size mismatch between the word embedding and the RAG query stages. For example, in our benchmarking script, when the database was vectorized and stored in vector db, we used the batch size of 16, hence the model was compiled with shapes of &lt;strong&gt;16&lt;/strong&gt;xNxK. Whereas, the RAG query lookup is usually a single request of shape &lt;strong&gt;1&lt;/strong&gt;xNxK. So, there was a batch size mismatch (dimension “0” of these tensors) that triggered the recompilation for the query lookup stage. We confirmed it with the following Torch logging: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TORCH_LOGS=&quot;recompiles&quot;&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TORCH_LOGS=&quot;recompiles&quot; python rag_compile.py 
V1103 02:48:08.805986 34281 site-packages/torch/_dynamo/guards.py:2813] [0/1] [__recompiles] Recompiling function forward in site-packages/transformers/models/mpnet/modeling_mpnet.py:502
V1103 02:48:08.805986 34281 site-packages/torch/_dynamo/guards.py:2813] [0/1] [__recompiles]     triggered by the following guard failure(s):
V1103 02:48:08.805986 34281 site-packages/torch/_dynamo/guards.py:2813] [0/1] [__recompiles]     - 0/0: tensor 'L['input_ids']' size mismatch at index 0. expected 16, actual 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;solution-2&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;Torch dynamo provides a decorator to mark the dimension of a given tensor as dynamic and specify an expected value for the same, so that re-compilation is not triggered. For example, specifying dimension “0” of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;input_ids&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;attention_mask&lt;/code&gt; as dynamic, and specifying that value of “1” is allowed in that dimension (as shown in the following code snippet), should have avoided the redundant compilations.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;torch._dynamo.decorators.mark_unbacked(encoded_input['input_ids'], 0)
torch._dynamo.mark_dynamic(encoded_input['input_ids'], 1)
        torch._dynamo.decorators.mark_unbacked(encoded_input['attention_mask'], 0)
torch._dynamo.mark_dynamic(encoded_input['attention_mask'], 1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;However, the Torch dynamo decorator and marking didn’t work in this particular case. Moreover, using the decorator created graph breaks. So, we added some warmup iterations to hide the compilation latency, and profiled the query lookup performance in the steady state. However, the good news is that, in practice, this re-compilation is triggered only for the first query, so it might not affect the production scenario if the database size is fixed. Moreover, PyTorch AOT Inductor (a new feature in PyTorch) addresses re-compilation and warm up challenges with torch.compile. In a follow-up blog we will address how in a production environment we can use AOT Inductor to address these challenges.&lt;/p&gt;

&lt;p&gt;With these solutions we were able to apply torch.compile, weights pre-packing and the AWS Graviton specific optimizations for an end-end RAG scenario and improve the performance by 1.3x from the baseline eager mode.&lt;/p&gt;

&lt;h2 id=&quot;deployment&quot;&gt;Deployment&lt;/h2&gt;

&lt;p&gt;A detailed guide on how to deploy torch compiled RAG on AWS Graviton-based Amazon EC2 instances and how to deploy it in conjunction with Llama using&lt;a href=&quot;https://github.com/pytorch/serve&quot;&gt; TorchServe&lt;/a&gt; can be found on the&lt;a href=&quot;https://pytorch.org/serve/enhancing_llm_serving_compile_rag.html&quot;&gt; PyTorch website&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;In this blog, we covered how we optimized embedding model inference performance on AWS Graviton3-based EC2 instances. We also shared the challenges faced, the solutions we implemented to bring those optimizations for a RAG use case, and the resulting speedups. We hope that you will give it a try! If you need any support with ML software on Graviton, please open an issue on the AWS Graviton Technical Guide&lt;a href=&quot;https://github.com/aws/aws-graviton-getting-started&quot;&gt; GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We would like to express our gratitude to Eli Uriegas for the support in making this blog post happen.&lt;/p&gt;

&lt;h2 id=&quot;authors&quot;&gt;Authors&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Sunita Nadampalli&lt;/strong&gt; is a Principal Engineer and AI/ML expert at AWS. She leads AWS Graviton software performance optimizations for AI/ML and HPC workloads. She is passionate about open source software development and delivering high-performance and sustainable software solutions for SoCs based on the Arm ISA.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ankith Gunapal&lt;/strong&gt; is an AI Partner Engineer at Meta (PyTorch). He leads customer support, evangelizing &amp;amp; release engineering of TorchServe. He is passionate about solving production problems in model inference and model serving. He also enjoys distilling technically complex material in a user friendly format.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hamid Shojanazeri&lt;/strong&gt; leads the AI Frameworks Partner Engineering team at Meta. He is passionate about building scalable AI solutions and specializes in working with PyTorch to tackle the challenges of large-scale distributed training, inference, model serving, and optimization.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Sunita Nadampalli(AWS), Ankith Gunapal(Meta), Hamid Shojanazeri(Meta)</name>
        
        
      </author>

      

      

      
        <summary type="html">Large Language Models (LLMs) are trained on vast volumes of data and use billions of parameters to support tasks like answering questions, translating languages, and completing sentences. There are a few challenges when working with LLMs such as domain knowledge gaps, factuality issues, and hallucination, which affect their reliability especially for the fields that require high levels of accuracy, such as healthcare, law, or engineering. Retrieval Augmented Generation (RAG) provides a solution to mitigate some of these issues by augmenting LLMs with a specific domain or an organization’s internal knowledge base, without the need to retrain the model.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">docTR joins PyTorch Ecosystem: From Pixels to Data, Building a Recognition Pipeline with PyTorch and docTR</title>
      <link href="https://pytorch.org/blog/doctr-joins-pytorch-ecosystem/" rel="alternate" type="text/html" title="docTR joins PyTorch Ecosystem: From Pixels to Data, Building a Recognition Pipeline with PyTorch and docTR" />
      <published>2024-12-18T00:00:00-08:00</published>
      <updated>2024-12-18T00:00:00-08:00</updated>
      <id>https://pytorch.org/blog/doctr-joins-pytorch-ecosystem</id>
      <content type="html" xml:base="https://pytorch.org/blog/doctr-joins-pytorch-ecosystem/">&lt;p&gt;&lt;img src=&quot;/assets/images/doctr-joins-pytorch-ecosystem/fg1.png&quot; alt=&quot;docTR logo&quot; style=&quot;width:100%;display: block;max-width:400px; margin-left:auto; margin-right:auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We’re thrilled to announce that the docTR project has been integrated into the PyTorch ecosystem! This integration ensures that docTR aligns with PyTorch’s standards and practices, giving developers a reliable, community-backed solution for powerful OCR workflows.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;For more information on what it means to be a PyTorch ecosystem project, see the &lt;a href=&quot;https://pytorch.org/ecosystem/&quot;&gt;PyTorch Ecosystem Tools page&lt;/a&gt;.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;about-doctr&quot;&gt;About docTR&lt;/h2&gt;

&lt;p&gt;docTR is an Apache 2.0 project developed and distributed by &lt;a href=&quot;https://www.mindee.com/&quot;&gt;Mindee&lt;/a&gt; to help developers integrate OCR capabilities into applications with no prior knowledge required.&lt;/p&gt;

&lt;p&gt;To quickly and efficiently extract text information, docTR uses a two-stage approach:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;First, it performs text &lt;strong&gt;detection&lt;/strong&gt; to localize words.&lt;/li&gt;
  &lt;li&gt;Then, it conducts text &lt;strong&gt;recognition&lt;/strong&gt; to identify all characters in a word.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Detection&lt;/strong&gt; and &lt;strong&gt;recognition&lt;/strong&gt; are performed by state-of-the-art models written in PyTorch. To learn more about this approach, you can refer &lt;a href=&quot;https://mindee.github.io/doctr/using_doctr/using_models.html&quot;&gt;to the docTR documentation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;docTR enhances the user experience in PyTorch projects by providing high-performance OCR capabilities right out of the box. Its specially designed models require minimal to no fine-tuning for common use cases, allowing developers to quickly integrate advanced document analysis features.&lt;/p&gt;

&lt;h2 id=&quot;local-installation&quot;&gt;Local installation&lt;/h2&gt;

&lt;p&gt;docTR requires Python &amp;gt;= 3.10 and supports Windows, Mac and Linux. Please refer to our &lt;a href=&quot;https://github.com/mindee/doctr?tab=readme-ov-file#installation&quot;&gt;README&lt;/a&gt; for necessary dependencies for MacBook with the M1 chip.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pip3 install -U pip
pip3 install &quot;python-doctr[torch,viz]&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This will install docTR along with the latest version of PyTorch.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Note: docTR also provides docker images for an easy deployment, such as a part of Kubernetes cluster.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;text-recognition&quot;&gt;Text recognition&lt;/h2&gt;

&lt;p&gt;Now, let’s try docTR’s OCR recognition on this sample:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/doctr-joins-pytorch-ecosystem/fg2.jpg&quot; alt=&quot;OCR sample&quot; style=&quot;width:100%;display: block;max-width:300px; margin-left:auto; margin-right:auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The OCR recognition model expects an image with only one word on it and will output the predicted word with a confidence score. You can use the following snippet to test OCR capabilities from docTR:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;python
from doctr.io import DocumentFile
from doctr.models import recognition_predictor

doc = DocumentFile.from_images(&quot;/path/to/image&quot;)

# Load the OCR model
# This will download pre-trained models hosted by Mindee
model = recognition_predictor(pretrained=True)

result = model(doc)
print(result)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here, the most important line of code is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;model = recognition_predictor(pretrained=True)&lt;/code&gt;. This will load a default text recognition model, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;crnn_vgg16_bn&lt;/code&gt;, but you can select other models through the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;arch&lt;/code&gt; parameter. You can check out the &lt;a href=&quot;https://mindee.github.io/doctr/using_doctr/using_models.html&quot;&gt;available architectures&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;When run on the sample, the recognition predictor retrieves the following data: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[('MAGAZINE', 0.9872216582298279)]&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Note: using the DocumentFile object docTR provides an easy way to manipulate PDF or Images.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;text-detection&quot;&gt;Text detection&lt;/h2&gt;

&lt;p&gt;The last example was a crop on a single word. Now, what about an image with several words on it, like this one?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/doctr-joins-pytorch-ecosystem/fg3.jpg&quot; alt=&quot;photo of magazines&quot; style=&quot;width:100%;display: block;max-width:300px; margin-left:auto; margin-right:auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A text detection model is used before the text recognition to output a segmentation map representing the location of the text. Following that, the text recognition is applied on every detected patch.&lt;/p&gt;

&lt;p&gt;Below is a snippet to run only the detection part:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from doctr.io import DocumentFile
from doctr.models import detection_predictor
from matplotlib import pyplot as plt
from doctr.utils.geometry import detach_scores
from doctr.utils.visualization import draw_boxes

doc = DocumentFile.from_images(&quot;path/to/my/file&quot;)
model = detection_predictor(pretrained=True)

result = model(doc)

draw_boxes(detach_scores([result[0][&quot;words&quot;]])[0][0], doc[0])
plt.axis('off')
plt.show()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Running it on the full sample yields the following:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/doctr-joins-pytorch-ecosystem/fg4.png&quot; alt=&quot;photo of magazines&quot; style=&quot;width:100%;display: block;max-width:300px; margin-left:auto; margin-right:auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Similarly to the text recognition, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;detection_predictor&lt;/code&gt; will load a default model (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fast_base&lt;/code&gt; here). You can also load another one by providing it through the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;arch&lt;/code&gt; parameter.&lt;/p&gt;

&lt;h2 id=&quot;the-full-implementation&quot;&gt;The full implementation&lt;/h2&gt;

&lt;p&gt;Now, let’s plug both components into the same pipeline.&lt;/p&gt;

&lt;p&gt;Conveniently, docTR provides a wrapper that does exactly that for us:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from doctr.io import DocumentFile
from doctr.models import ocr_predictor

doc = DocumentFile.from_images(&quot;/path/to/image&quot;)

model = ocr_predictor(pretrained=True, assume_straight_pages=False)

result = model(doc)
result.show()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/doctr-joins-pytorch-ecosystem/fg5.png&quot; alt=&quot;photo of magazines&quot; style=&quot;width:100%;display: block;max-width:300px; margin-left:auto; margin-right:auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The last line should display a matplotlib window which shows the detected patches. Hovering the mouse over them will display their contents.&lt;/p&gt;

&lt;p&gt;You can also do more with this output, such as reconstituting a synthetic document like so:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import matplotlib.pyplot as plt

synthetic_pages = result.synthesize()
plt.imshow(synthetic_pages[0])
plt.axis('off')
plt.show()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/doctr-joins-pytorch-ecosystem/fg6.png&quot; alt=&quot;black text on white&quot; style=&quot;width:100%;display: block;max-width:300px; margin-left:auto; margin-right:auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The pipeline is highly customizable, where you can modify the detection or recognition model behaviors by passing arguments to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ocr_predictor&lt;/code&gt;. Please refer to the &lt;a href=&quot;https://mindee.github.io/doctr/using_doctr/using_models.html&quot;&gt;documentation&lt;/a&gt; to learn more about it.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;We’re excited to welcome docTR into the PyTorch Ecosystem, where it seamlessly integrates with PyTorch pipelines to deliver state-of-the-art OCR capabilities right out of the box.&lt;/p&gt;

&lt;p&gt;By empowering developers to quickly extract text from images or PDFs using familiar tooling, docTR simplifies complex document analysis tasks and enhances the overall PyTorch experience.&lt;/p&gt;

&lt;p&gt;We invite you to explore the &lt;a href=&quot;https://github.com/mindee/doctr&quot;&gt;docTR GitHub repository&lt;/a&gt;, join the &lt;a href=&quot;https://slack.mindee.com/&quot;&gt;docTR community on Slack&lt;/a&gt;, and reach out at contact@mindee.com for inquiries or collaboration opportunities.&lt;/p&gt;

&lt;p&gt;Together, we can continue to push the boundaries of document understanding and develop even more powerful, accessible tools for everyone in the PyTorch community.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Olivier Dulcy &amp; Sebastian Olivera, Mindee</name>
        
        
      </author>

      

      

      
        <summary type="html"></summary>
      

      
      
    </entry>
  
</feed>


