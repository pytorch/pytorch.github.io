<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://pytorch.org/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://pytorch.org/" rel="alternate" type="text/html" />
  <updated>2025-02-25T17:27:26-08:00</updated>
  <id>https://pytorch.org/feed.xml</id>

  
  
  

  
    <title type="html">PyTorch Website</title>
  

  
    <subtitle>Scientific Computing...</subtitle>
  

  
    <author>
        <name>Facebook</name>
      
      
    </author>
  

  
  
  
    <entry>
      <title type="html">Optimize LLMs for Efficiency &amp;amp; Sustainability</title>
      <link href="https://pytorch.org/blog/optimize-llms/" rel="alternate" type="text/html" title="Optimize LLMs for Efficiency &amp; Sustainability" />
      <published>2025-02-19T00:00:00-08:00</published>
      <updated>2025-02-19T00:00:00-08:00</updated>
      <id>https://pytorch.org/blog/optimize-llms</id>
      <content type="html" xml:base="https://pytorch.org/blog/optimize-llms/">&lt;p&gt;The rapid growth of large language model (LLM) applications is linked to rapid growth in energy demand. According to the International Energy Agency (IEA), data center electricity consumption is projected to roughly double by 2026 primarily driven by AI. This is due to the energy-intensive training requirements for massive LLMs – however, the increase in AI Inferencing workloads also plays a role. For example, compared with traditional search queries, a single AI inference can consume about &lt;a href=&quot;https://www.weforum.org/stories/2024/07/generative-ai-energy-emissions/&quot;&gt;10x more energy&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As developers, we directly affect how energy-intensive our AI solution is. There are technical decisions we can take to help make our AI solution more environmentally sustainable. Minimizing compute to deliver LLM solutions is not the only requirement for creating sustainable AI use. For example, systemic changes, such as policy interventions may be needed, but utilizing energy efficient solutions is an important factor and is an impactful intervention we can adopt right away.&lt;/p&gt;

&lt;p&gt;With that said, minimizing your LLM inference cloud compute requirements also leads to reducing your cloud bill and makes your app more energy efficient, creating a win-win situation. In this blog, we will take you through the steps to creating an LLM chatbot by optimizing and deploying a Llama 3.1 model on PyTorch, quantifying the computational efficiency benefits of specific architecture decisions.&lt;/p&gt;

&lt;h2 id=&quot;what-will-we-evaluate&quot;&gt;What will we evaluate?&lt;/h2&gt;

&lt;p&gt;For this blog, our goal is to create an immersive fantasy storytelling app where users enter a fantasy world by chatting with a Generative AI. The first location is the land of Wicked, allowing people to role-play walking around the Emerald City and observe the sights and scenes in real-time. We’ll implement this via a chatbot and a custom system prompt.&lt;/p&gt;

&lt;p&gt;We will be evaluating LLM performance on CPUs. You can see the advantages of&lt;a href=&quot;https://www.arm.com/resources/ebook/cpu-inference&quot;&gt; CPU vs GPU inference here&lt;/a&gt;. In general, leveraging CPUs in the cloud for LLM inference is a great choice for models around 10B parameters or less like the Llama series.&lt;/p&gt;

&lt;p&gt;We will also be using Arm-based CPUs, specifically the AWS Graviton series. Based on studies,&lt;a href=&quot;https://newsroom.arm.com/blog/aws-graviton-decarbonize-compute&quot;&gt; the Arm-based Graviton3 server can provide 67.6 percent lower workload carbon intensity built in&lt;/a&gt;. While this study was based on a simulation, it is an excellent start to showing the possibilities for minimizing our app’s energy requirements.&lt;/p&gt;

&lt;p&gt;First, you’ll see how to run a simple LLM chatbot on PyTorch, then explore three techniques to optimize your application for computational efficiency:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Model optimization: Utilizing 4-bit quantization and added KleidiAI kernels.&lt;/li&gt;
  &lt;li&gt;Shortcut optimization: Implementing a vector database to handle common queries.&lt;/li&gt;
  &lt;li&gt;Architecture optimization: Adopting a serverless architecture.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let’s get started.&lt;/p&gt;

&lt;h2 id=&quot;run-llama-31-via-pytorch-on-aws-graviton4&quot;&gt;Run Llama-3.1 via PyTorch on AWS Graviton4&lt;/h2&gt;

&lt;p&gt;To maximize energy efficiency, we will only use the minimum server resources needed to support this LLM chatbot. For this &lt;a href=&quot;https://huggingface.co/meta-llama/Llama-3.1-8B&quot;&gt;Llama-3.1 8-billion parameter model&lt;/a&gt;, 16 cores, 64GB RAM, and disk space of 50GB is required. We will use the r8g.4xlarge Graviton4 instance running Ubuntu 24.04, as it meets these specifications.&lt;/p&gt;

&lt;p&gt;Spin up this EC2 instance, connect to it, and start installing the requirements:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    sudo apt-get update
    sudo apt install gcc g++ build-essential python3-pip python3-venv google-perftools -y
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then install Torchchat, the library developed by the PyTorch team that enables running LLMs across devices:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    git clone https://github.com/pytorch/torchchat.git
    cd torchchat
    python3 -m venv .venv
    source .venv/bin/activate
    ./install/install_requirements.sh 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Next, install the Llama-3.1-8b model from Hugging Face through the CLI. You will first need to make a Hugging Face access token on your HF account. This will download the 16GB model to your instance, which may take a few minutes:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    pip install -U &quot;huggingface_hub[cli]&quot;
    huggingface-cli login
    	&amp;lt;enter your access token when prompted&amp;gt;
    python torchchat.py export llama3.1 --output-dso-path exportedModels/llama3.1.so --device cpu --max-seq-length 1024
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now you are ready to run the LLM model, adding a system prompt to be a guiding storyteller in the land of Wicked:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    LD_PRELOAD=/usr/lib/aarch64-linux-gnu/libtcmalloc.so.4 TORCHINDUCTOR_CPP_WRAPPER=1 TORCHINDUCTOR_FREEZING=1 OMP_NUM_THREADS=16 python torchchat.py generate llama3.1 --device cpu --chat
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Type ‘y’ to enter a system prompt and enter the following prompt:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;You are the guiding storyteller for a fantasy adventure application. Immerse users in the enchanting world of Wicked, guiding them through interactive, real-time experiences in the Emerald City. Describe vivid sights, dynamic scenes, and engage users in storytelling that feels alive and responsive. Allow users to make choices that shape their journey while maintaining the magical tone of the Wicked universe.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Then enter your user query:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;I walk through the Emerald City gates and look up&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The output will show on the screen, taking about 7 seconds to generate the first token with less than 1 token per second.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/optimize-llms.png&quot; alt=&quot;terminal&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This example took 245 seconds, or 4 minutes, to generate its complete reply—not very fast. The first optimization we’ll look at will speed up the LLM generation, reducing its computational footprint.&lt;/p&gt;

&lt;h3 id=&quot;optimization-1-kleidiai-and-quantization&quot;&gt;Optimization 1: KleidiAI and Quantization&lt;/h3&gt;

&lt;p&gt;Several optimizations are possible from the basic implementation above. The simplest and quickest one t to do is to quantize the model from FP16 to INT4. This approach trades-off some accuracy while cutting the model size from 16Gb to about 4Gb, increasing the inference speed in the process.&lt;/p&gt;

&lt;p&gt;Another common optimization comes in leveraging TorchAO (Torch Architecture Optimization), the PyTorch library that works seamlessly with TorchChat to enhance model performance through various quantization and sparsity methods.&lt;/p&gt;

&lt;p&gt;Lastly, we’ll use Arm KleidiAI optimizations. These are micro-kernels written in assembly that lead to significant performance improvements for LLM inference on Arm CPUs. You can read more about &lt;a href=&quot;https://learn.arm.com/learning-paths/cross-platform/kleidiai-explainer/&quot;&gt;how KleidiAI kernels work if interested&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To implement these optimizations, spin up a fresh EC2 instance and follow the instructions &lt;a href=&quot;https://learn.arm.com/learning-paths/servers-and-cloud-computing/pytorch-llama/&quot;&gt;on how to run a Large Language Model (LLM) chatbot with PyTorch&lt;/a&gt;. When ready, run the model and enter the same system prompt and user query as above. You’ll get results that significantly speed up the inference: Less than 1 second to first token, and about 25 tokens per second.&lt;/p&gt;

&lt;p&gt;This cuts the inference time from 245 seconds to about 10 seconds. This results in less power-draw from your server, as it is spending more time idle vs running a power-hungry inference. All else being equal, this is a more carbon-friendly solution than the non-optimized app. The next two approaches go beyond model inference optimization, modifying the solution architectural to further reduce computational load.&lt;/p&gt;

&lt;h3 id=&quot;optimization-2-faiss-to-match-database-for-common-questions&quot;&gt;Optimization 2: FAISS to match database for common questions&lt;/h3&gt;

&lt;p&gt;As stated in the introduction, model inferences are typically more computationally expensive than other search techniques. What if you could automatically respond to common user queries without performing an LLM inference? Using a query/response database is an option to bypass LLM inference and respond efficiently. For this interactive storytelling app, you can imagine common questions about specific characters, the world itself, and rules about what the chatbot is/is not capable of that can have pre-generated answers.&lt;/p&gt;

&lt;p&gt;However, a traditional exact-match database isn’t sufficient as users can phrase the same query in many ways. Asking about the chatbot’s capabilities could all invite the same answer but be phrased differently:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;“What are you capable of?”&lt;/li&gt;
  &lt;li&gt;“Tell me what you can do.”&lt;/li&gt;
  &lt;li&gt;“How can I interact with you?”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Implementing semantic search solves this issue by matching a user’s query to the most relevant pre-generated answer by understanding the user’s intent. The &lt;a href=&quot;https://github.com/facebookresearch/faiss&quot;&gt;FAISS library&lt;/a&gt; is a great option to implement semantic search.&lt;/p&gt;

&lt;p&gt;The computational savings of this approach depends on three factors:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Percentage of user queries that can be serviced by semantic search instead of LLM.&lt;/li&gt;
  &lt;li&gt;Computational cost of running the LLM inference.&lt;/li&gt;
  &lt;li&gt;Computational cost of running the semantic search.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;With the savings equation being:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Computational_savings = (% of queries) * (LLM_cost – search_cost).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This type of architecture makes sense in a few situations. One is if your system has common queries with many repeat questions. Another is large-scale systems with hundreds of thousands of incoming queries, where small percentage savings add up to meaningful changes. Lastly, if your LLM inference is very computationally expensive compared to the search cost, particularly with larger parameter models.&lt;/p&gt;

&lt;p&gt;The final optimization approach is transitioning from server to serverless.&lt;/p&gt;

&lt;h3 id=&quot;optimization-3-serverless-approach&quot;&gt;Optimization 3: Serverless approach&lt;/h3&gt;

&lt;p&gt;Using serverless architectures are popular for many reasons, one being only paying for active compute time, and eliminating costs with idle servers. Idling servers require a non-trivial amount of power to keep on, wasting energy while waiting.&lt;/p&gt;

&lt;p&gt;This cost efficiency translates into being an inherently more environmentally friendly architecture, as it reduces wasteful energy consumption. Further, multiple applications share underlying physical infrastructure, improving resource efficiency.&lt;/p&gt;

&lt;p&gt;To set up your own serverless chatbot, you need to first containerize the quantized Llama-3.1-8b with TorchChat, TorchAO, and Arm KleidiAI optimizations with a python script containing a Lambda entry function &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lambda_handler&lt;/code&gt;. One deployment option is to upload your container to AWS ECR and attach the container to your Lambda function. Then set up an API Gateway WebSocket or similar to interact with your Lambda through an API.&lt;/p&gt;

&lt;p&gt;There are two notable limitations to using a serverless architecture to host your LLM, the first being token generation speed. Recall that the server-based approach delivered about 25 tokens/second with KleidiAI optimizations. The serverless approach delivers an order of magnitude slower, which we measured at around about 2.5 tokens/second. This limitation mainly results from Lambda functions deploying onto Graviton2 servers. When deployment moves to CPUs with more SIMD channels, like Graviton3 and Graviton4, the tokens/second should increase over time. Learn more about architecture optimizations introduced in Graviton3 via the &lt;a href=&quot;https://developer.arm.com/Processors/Neoverse%20V1&quot;&gt;Arm Neoverse-V1 CPU here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This slower speed restricts the viable use cases for serverless LLM architectures, but there are certain cases where this can be seen as an advantage. In our use cases of interactive storytelling, slowly revealing information creates a sense of immersion, building anticipation and mimicking real-time narration. Other use cases include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Guided meditation apps with slow, relaxing word delivery&lt;/li&gt;
  &lt;li&gt;Virtual friend engaging in thoughtful conversation, or a therapeutic conversation.&lt;/li&gt;
  &lt;li&gt;Poetry generation or interactive art to slow delivery creating a contemplative aesthetic.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Users may have a better experience with slower token generation in the right applications. When prioritizing a more sustainable solution, restrictions end up becoming strengths. As an analogy, a common critique of modern movies today is that their overreliance on visual effects leads to fewer compelling storylines vs older movies. The cost restrictions of VFX meant older movies had to craft captivating dialog, leveraging skillful camera angles and character positioning to fully engage viewers. Similarly, focusing on sustainable AI architectures can lead to more engaging, immersive experiences when done thoughtfully.&lt;/p&gt;

&lt;p&gt;The second serverless limitation on LLM inferences is the cold-start time of about 50 seconds. If implemented poorly, a user waiting 50 seconds with no alternative will likely leave the app. You can turn this limitation into a feature in our Wicked-based experience with several design tricks:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Create a “prologue experience” where you guide users through hard-coded questions and answers, priming them for where they will land in Emerald City and collecting input to shape their upcoming experience.&lt;/li&gt;
  &lt;li&gt;Make the waiting period a countdown timer, revealing hard-coded text snippets of the story or world-building. A character, like the wizard, could communicate with the user with fragmented lines to build suspense and prime the user into the right mindset.&lt;/li&gt;
  &lt;li&gt;Create an audio intro with music from the movie or musical, along with rotating visuals to draw users into the atmosphere of the Wicked world.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;thinking-outside-the-box&quot;&gt;Thinking outside the box&lt;/h3&gt;

&lt;p&gt;Implementing a sustainability-minded solution architecture includes and goes beyond optimizing your AI inferences. Understand how users will interact with your system, and right-size your implementation accordingly. Always optimizing for fast tokens per second or time to first token will hide opportunities for engaging features.&lt;/p&gt;

&lt;p&gt;With that said, you should be leveraging straightforward optimizations when possible. Using TorchAO and Arm KleidiAI micro-kernels are great ways to speed up your LLM chatbot. By combining creative solution architectures and optimizing where possible, you can build more sustainable LLM-based applications. Happy coding!&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Zach Lasiuk, Arm</name>
        
        
      </author>

      

      

      
        <summary type="html">The rapid growth of large language model (LLM) applications is linked to rapid growth in energy demand. According to the International Energy Agency (IEA), data center electricity consumption is projected to roughly double by 2026 primarily driven by AI. This is due to the energy-intensive training requirements for massive LLMs – however, the increase in AI Inferencing workloads also plays a role. For example, compared with traditional search queries, a single AI inference can consume about 10x more energy.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Solve Real-Word AI Challenges with PyTorch at Datathon 2025: DataOrbit</title>
      <link href="https://pytorch.org/blog/datathon-2025/" rel="alternate" type="text/html" title="Solve Real-Word AI Challenges with PyTorch at Datathon 2025: DataOrbit" />
      <published>2025-02-12T00:00:00-08:00</published>
      <updated>2025-02-12T00:00:00-08:00</updated>
      <id>https://pytorch.org/blog/datathon-2025</id>
      <content type="html" xml:base="https://pytorch.org/blog/datathon-2025/">&lt;p&gt;&lt;strong&gt;We’re excited to have PyTorch sponsor &lt;a href=&quot;https://dataorbit-2025.devpost.com/&quot;&gt;Datathon 2025: DataOrbit&lt;/a&gt;&lt;/strong&gt;, a place where students can collaborate with a team to solve problems using real-world datasets! This event, hosted by Data Science UCSB in collaboration with Gaucho Sports Analytics and ACM@UCSB, will take place on &lt;strong&gt;February 22–23rd, 2025 at UC Santa Barbara&lt;/strong&gt;, with the incredible opportunity to present your project to a panel of corporate and faculty judges – &lt;strong&gt;including the executive director of Pytorch!&lt;/strong&gt; – for a chance to win prizes up to $3000.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/datathon-2025.png&quot; alt=&quot;logo&quot; style=&quot;max-width:700px; width:100%; display: block; margin-left: auto; margin-right: auto&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PyTorch’s versatility and power have made it an essential tool for tackling complex data problems in domains ranging from computer vision and natural language processing to time series analysis. At Datathon 2025: DataOrbit, participants will have the chance to leverage PyTorch’s dynamic framework, ease of use, and robust ecosystem to build innovative solutions. Whether you’re building machine learning models, experimenting with deep learning architectures, or applying PyTorch to solve real-world challenges, workshops and mentors will be available to help you dive deeper into its capabilities and accelerate your project’s success.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Register Here:&lt;/strong&gt; &lt;a href=&quot;http://tinyurl.com/dataorbit25-reg&quot;&gt;tinyurl.com/dataorbit25-reg&lt;/a&gt; (Open until February 21st or until capacity is reached)&lt;/p&gt;

&lt;p&gt;Additional information regarding the timeline of events can be found on the registration form.&lt;/p&gt;

&lt;p&gt;About the Datathon&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Open only to undergraduate students in the United States&lt;/li&gt;
  &lt;li&gt;In-person events over 36 hours&lt;/li&gt;
  &lt;li&gt;Teams sizes of 2-5 people&lt;/li&gt;
  &lt;li&gt;10 different prize tracks&lt;/li&gt;
  &lt;li&gt;Workshops and office hours teaching essential data science tools and techniques&lt;/li&gt;
  &lt;li&gt;Professional development workshops + networking opportunities with our sponsors&lt;/li&gt;
  &lt;li&gt;All meals provided&lt;/li&gt;
  &lt;li&gt;A fun time!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;If you have a group you would like to work with, we require that every member register separately. If you do not have a group, we will have an opportunity at the beginning of the event to participate in an activity to form groups. Unfortunately, at this time we do not provide travel accommodations or lodging for participants.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;If you are interested in mentoring students virtually during the course of our datathon, or have any other questions contact us at datascience.ucsb@gmail.com.&lt;/em&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Aakash Senthilnathan</name>
        
        
      </author>

      

      

      
        <summary type="html">We’re excited to have PyTorch sponsor Datathon 2025: DataOrbit, a place where students can collaborate with a team to solve problems using real-world datasets! This event, hosted by Data Science UCSB in collaboration with Gaucho Sports Analytics and ACM@UCSB, will take place on February 22–23rd, 2025 at UC Santa Barbara, with the incredible opportunity to present your project to a panel of corporate and faculty judges – including the executive director of Pytorch! – for a chance to win prizes up to $3000.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Unlocking the Latest Features in PyTorch 2.6 for Intel Platforms</title>
      <link href="https://pytorch.org/blog/unlocking-pt-2-6-intel/" rel="alternate" type="text/html" title="Unlocking the Latest Features in PyTorch 2.6 for Intel Platforms" />
      <published>2025-02-11T00:00:00-08:00</published>
      <updated>2025-02-11T00:00:00-08:00</updated>
      <id>https://pytorch.org/blog/unlocking-pt-2-6-intel</id>
      <content type="html" xml:base="https://pytorch.org/blog/unlocking-pt-2-6-intel/">&lt;p&gt;&lt;a href=&quot;https://pytorch.org/blog/pytorch2-6/&quot;&gt;PyTorch* 2.6&lt;/a&gt; has just been released with a set of exciting new features including torch.compile compatibility with Python 3.13, new security and performance enhancements, and a change in the default parameter for torch.load. PyTorch also announced the deprecation of its official Anaconda channel.&lt;/p&gt;

&lt;p&gt;Among the performance features are three that enhance developer productivity on Intel platforms:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Improved Intel GPU availability&lt;/li&gt;
  &lt;li&gt;FlexAttention optimization on x86 CPU for LLM&lt;/li&gt;
  &lt;li&gt;FP16 on x86 CPU support for eager and Inductor modes&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;improved-intel-gpu-availability&quot;&gt;Improved Intel GPU Availability&lt;/h2&gt;

&lt;p&gt;To provide developers working in artificial intelligence (AI) with better support for Intel GPUs, the PyTorch user experience on these GPUs has been enhanced. This improvement includes simplified installation steps, a Windows* release binary distribution, and expanded coverage of supported GPU models, including the latest Intel® Arc™ B-Series discrete graphics.&lt;/p&gt;

&lt;p&gt;These new features help promote accelerated machine learning workflows within the PyTorch ecosystem, providing a consistent developer experience and support. Application developers and researchers seeking to fine-tune, perform inference, and develop with PyTorch models on &lt;a href=&quot;https://www.intel.com/content/www/us/en/products/details/discrete-gpus/arc.html&quot;&gt;Intel® Core™ Ultra AI PCs &lt;/a&gt; and &lt;a href=&quot;https://www.intel.com/content/www/us/en/products/details/discrete-gpus/arc.html&quot;&gt;Intel® Arc™ discrete graphics&lt;/a&gt; will now be able to install PyTorch directly with binary releases for Windows, Linux*, and Windows Subsystem for Linux 2.&lt;/p&gt;

&lt;p&gt;The new features include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Simplified Intel GPU software stack setup to enable one-click installation of the torch-xpu PIP wheels to run deep learning workloads in a ready-to-use fashion, thus eliminating the complexity of installing and activating Intel GPU development software bundles. &lt;/li&gt;
  &lt;li&gt;Windows binary releases for torch core, torchvision and torchaudio have been made available for Intel GPUs, expanding from &lt;a href=&quot;https://www.intel.com/content/www/us/en/products/details/processors/core-ultra.html&quot;&gt;Intel® Core™ Ultra Series 2&lt;/a&gt; with Intel® Arc™ Graphics and &lt;a href=&quot;https://www.intel.com/content/www/us/en/products/docs/discrete-gpus/arc/desktop/a-series/overview.html&quot;&gt;Intel® Arc™ A-Series graphics &lt;/a&gt;to the latest GPU hardware &lt;a href=&quot;https://www.intel.com/content/www/us/en/products/docs/discrete-gpus/arc/desktop/b-series/overview.html&quot;&gt;Intel® Arc™ B-Series graphics&lt;/a&gt; support. &lt;/li&gt;
  &lt;li&gt;Further enhanced coverage of Aten operators on Intel GPUs with SYCL* kernels for smooth eager mode execution, as well as bug fixes and performance optimizations for torch.compile on Intel GPUs. &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Get a tour of new environment setup, PIP wheels installation, and examples on Intel® Client GPUs and Intel® Data Center GPU Max Series in the &lt;a href=&quot;https://pytorch.org/docs/main/notes/get_start_xpu.html&quot;&gt;Getting Started Guide&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;flexattention-optimization-on-x86-cpu-for-llm&quot;&gt;FlexAttention Optimization on X86 CPU for LLM&lt;/h2&gt;

&lt;p&gt;FlexAttention was first introduced in &lt;a href=&quot;https://pytorch.org/blog/pytorch2-5/&quot;&gt;PyTorch 2.5&lt;/a&gt;, to address the need to support various Attentions or even combinations of them. This PyTorch API leverages torch.compile to generate a fused FlashAttention kernel, which eliminates extra memory allocation and achieves performance comparable to handwritten implementations.&lt;/p&gt;

&lt;p&gt;Previously, FlexAttention was implemented for CUDA* devices based on the Triton backend. Since PyTorch 2.6, X86 CPU support of FlexAttention was added through TorchInductor CPP backend. This new feature leverages and extends current CPP template abilities to support broad attention variants (e.g., PageAttention, which is critical for LLMs inference) based on the existing FlexAttention API, and brings optimized performance on x86 CPUs. With this feature, user can easily use FlexAttention API to compose their Attention solutions on CPU platforms and achieve good performance.&lt;/p&gt;

&lt;p&gt;Typically, FlexAttention is utilized by popular LLM ecosystem projects, such as Hugging Face transformers and vLLM in their LLM related modeling (e.g., PagedAttention) to achieve better out-of-the-box performance. Before the official adoption happens, &lt;a href=&quot;https://github.com/huggingface/transformers/pull/35419&quot;&gt;this enabling PR&lt;/a&gt; in Hugging Face can help us the performance benefits that FlexAttention can bring on x86 CPU platforms.&lt;/p&gt;

&lt;p&gt;The graph below shows the performance comparison of PyTorch 2.6 (with this feature) and PyTorch 2.5 (without this feature) on typical Llama models. For real-time mode (Batch Size = 1), there is about 1.13x-1.42x performance improvement for next token across different input token lengths. As for best throughput under a typical SLA (P99 token latency &amp;lt;=50ms), PyTorch 2.6 achieves more than 7.83x performance than PyTorch 2.5 as PyTorch 2.6 can run at 8 inputs (Batch Size = 8) together and still keep SLA while PyTorch 2.5 can only run 1 input, because FlexAttention based PagedAttention in PyTorch 2.6 provides more efficiency during multiple batch size scenarios.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/unlocking-pt-2-6-intel.png&quot; alt=&quot;Figure 1. Performance comparison of PyTorch 2.6 and PyTorch 2.5 on Typical Llama Models&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 1. Performance comparison of PyTorch 2.6 and PyTorch 2.5 on Typical Llama Models&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;fp16-on-x86-cpu-support-for-eager-and-inductor-modes&quot;&gt;FP16 on X86 CPU Support for Eager and Inductor Modes&lt;/h2&gt;

&lt;p&gt;Float16 is a commonly used reduced floating-point type that improves performance in neural network inference and training. CPUs like recently launched &lt;a href=&quot;https://www.intel.com/content/www/us/en/products/details/processors/xeon/xeon6-p-cores.html&quot;&gt;Intel® Xeon® 6 with P-Cores&lt;/a&gt; support Float16 datatype with native accelerator &lt;a href=&quot;https://www.intel.com/content/www/us/en/products/docs/accelerator-engines/advanced-matrix-extensions/overview.html&quot;&gt;AMX&lt;/a&gt;, which highly improves the Float16 performance. Float16 support on x86 CPU was first introduced in PyTorch 2.5 as a prototype feature. Now it has been further improved for both eager mode and Torch.compile + Inductor mode, which is pushed to Beta level for broader adoption. This helps the deployment on the CPU side without the need to modify the model weights when the model is pre-trained with mixed precision of Float16/Float32. On platforms that support AMX Float16 (i.e., the Intel® Xeon® 6 processors with P-cores), Float16 has the same pass rate as Bfloat16 across the typical PyTorch benchmark suites: TorchBench, Hugging Face, and Timms. It also shows good performance comparable to 16 bit datatype Bfloat16.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog, we discussed three features to enhance developer productivity on Intel platforms in PyTorch 2.6.  These three features are designed to improve Intel GPU availability, optimize FlexAttention for x86 CPUs tailored for large language models (LLMs), and support FP16 on x86 CPUs in both eager and Inductor modes. Get &lt;a href=&quot;https://pytorch.org/&quot;&gt;PyTorch 2.6&lt;/a&gt; and try them for yourself or you can access PyTorch 2.6 on the &lt;a href=&quot;https://ai.cloud.intel.com/&quot;&gt;Intel® Tiber™ AI Cloud&lt;/a&gt; to take advantage of hosted notebooks that are optimized for Intel hardware and software.&lt;/p&gt;

&lt;h2 id=&quot;acknowledgements&quot;&gt;Acknowledgements&lt;/h2&gt;

&lt;p&gt;The release of PyTorch 2.6 is an exciting milestone for Intel platforms, and it would not have been possible without the deep collaboration and contributions from the community. We extend our heartfelt thanks to &lt;a href=&quot;https://github.com/albanD&quot;&gt;Alban&lt;/a&gt;, &lt;a href=&quot;https://github.com/atalman&quot;&gt;Andrey&lt;/a&gt;, &lt;a href=&quot;https://github.com/desertfire&quot;&gt;Bin&lt;/a&gt;, &lt;a href=&quot;https://github.com/jansel&quot;&gt;Jason&lt;/a&gt;, &lt;a href=&quot;https://github.com/jerryzh168&quot;&gt;Jerry&lt;/a&gt; and &lt;a href=&quot;https://github.com/malfet&quot;&gt;Nikita&lt;/a&gt; for sharing their invaluable ideas, meticulously reviewing PRs, and providing insightful feedback on RFCs. Their dedication has driven continuous improvements and pushed the ecosystem forward for Intel platforms.&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://pytorch.org/blog/flexattention/&quot;&gt;FlexAttention in PyTorch&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/2309.06180&quot;&gt;PagedAttention Optimization&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;•%09https:/www.intel.com/content/www/us/en/products/details/processors/xeon/xeon6-p-cores.html&quot;&gt;Intel® Xeon® 6 with P-Cores&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;product-and-performance-information&quot;&gt;Product and Performance Information&lt;/h2&gt;

&lt;p&gt;Measurement on AWS EC2 m7i.metal-48xl using: 2x Intel® Xeon® Platinum 8488C, HT On, Turbo On, NUMA 2, Integrated Accelerators Available [used]: DLB [8], DSA [8], IAA[8], QAT[on CPU, 8], Total Memory 512GB (16x32GB DDR5 4800 MT/s [4400 MT/s]), BIOS Amazon EC2 1.0, microcode 0x2b000603, 1x Elastic Network Adapter (ENA) 1x Amazon Elastic Block Store 800G, Ubuntu 24.04.1 LTS 6.8.0-1018-aws  Test by Intel on Jan 15&lt;sup&gt;th&lt;/sup&gt; 2025.&lt;/p&gt;

&lt;h2 id=&quot;notices-and-disclaimers&quot;&gt;Notices and Disclaimers&lt;/h2&gt;

&lt;p&gt;Performance varies by use, configuration and other factors. Learn more on the Performance Index site. Performance results are based on testing as of dates shown in configurations and may not reflect all publicly available updates.  See backup for configuration details.  No product or component can be absolutely secure. Your costs and results may vary. Intel technologies may require enabled hardware, software or service activation.&lt;/p&gt;

&lt;p&gt;Intel Corporation. Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries. Other names and brands may be claimed as the property of others.&lt;/p&gt;

&lt;h2 id=&quot;ai-disclaimer&quot;&gt;AI disclaimer:&lt;/h2&gt;

&lt;p&gt;AI features may require software purchase, subscription or enablement by a software or platform provider, or may have specific configuration or compatibility requirements. Details at &lt;a href=&quot;http://www.intel.com/AIPC&quot;&gt;www.intel.com/AIPC&lt;/a&gt;. Results may vary.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>the Intel PyTorch Team</name>
        
        
      </author>

      

      

      
        <summary type="html">PyTorch* 2.6 has just been released with a set of exciting new features including torch.compile compatibility with Python 3.13, new security and performance enhancements, and a change in the default parameter for torch.load. PyTorch also announced the deprecation of its official Anaconda channel.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Enabling advanced GPU features in PyTorch - Warp Specialization</title>
      <link href="https://pytorch.org/blog/warp-specialization/" rel="alternate" type="text/html" title="Enabling advanced GPU features in PyTorch - Warp Specialization" />
      <published>2025-02-05T00:00:00-08:00</published>
      <updated>2025-02-05T00:00:00-08:00</updated>
      <id>https://pytorch.org/blog/warp-specialization</id>
      <content type="html" xml:base="https://pytorch.org/blog/warp-specialization/">&lt;p&gt;&lt;strong&gt;Meta&lt;/strong&gt;: Hongtao Yu, Manman Ren, Bert Maher, Shane Nay  &lt;br /&gt;
&lt;strong&gt;NVIDIA&lt;/strong&gt;: Gustav Zhu, Shuhao Jiang&lt;/p&gt;

&lt;p&gt;Over the past few months, we have been working on enabling advanced GPU features for PyTorch and Triton users through the Triton compiler. One of our key goals has been to introduce warp specialization support on NVIDIA Hopper GPUs. Today, we are thrilled to announce that our efforts have resulted in the rollout of fully automated Triton warp specialization, now available to users in the upcoming release of Triton &lt;a href=&quot;https://github.com/triton-lang/triton/tree/release/3.2.x&quot;&gt;3.2&lt;/a&gt;, which will ship with PyTorch 2.6. PyTorch users can leverage this feature by &lt;a href=&quot;https://pytorch.org/tutorials/recipes/torch_compile_user_defined_triton_kernel_tutorial.html&quot;&gt;implementing user-defined Triton kernels&lt;/a&gt;. This work leveraged an initial implementation of warp specialization in Triton by NVIDIA and we look forward to further development with the community in the future.&lt;/p&gt;

&lt;p&gt;Warp specialization (WS) is a GPU programming technique where warps (a group of 32 threads on NVIDIA GPUs) within a threadblock are assigned distinct roles or tasks. This approach optimizes performance by enabling efficient execution of workloads that require task differentiation or cooperative processing. It enhances kernel performance by leveraging an asynchronous execution model, where different parts of the kernel are managed by separate hardware units. Data communication between these units, facilitated via shared memory on the NVIDIA H100, is highly efficient. Compared to a uniform warp approach, warp specialization allows the hardware multitasking warp scheduler to operate more effectively, maximizing resource utilization and overall performance.&lt;/p&gt;

&lt;p&gt;Using GEMM as an example, a typical uniform warp approach on the H100 GPU involves 8 warps per thread block collectively computing a tile of the output tensor. These 8 warps are divided into two warp groups (WG), with each group cooperatively computing half of the tile using efficient warp-group-level MMA (WGMMA) instructions, as illustrated in Figure 1.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/warp-specialization/fg1.jpg&quot; alt=&quot;Figure 1. GEMM K-loop Body with Uniform Warps&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Figure 1. GEMM K-loop Body with Uniform Warps&lt;/p&gt;

&lt;p&gt;The implementation is clean, easy to understand, and generally performs well, thanks to an elegant software pipeliner. The pipeliner’s purpose is to enhance instruction-level parallelism by executing non-dependent operations on different hardware units. For instance, load operations from the next loop iteration can be executed simultaneously with WGMMA operations in the current iteration. However, this approach relies heavily on the compiler to craft an instruction sequence that ensures load and WGMMA instructions are issued at precisely the right time. While this is relatively straightforward for GEMM, which involves a limited number of operations, it becomes significantly more challenging for more complex kernels, such as flash attention.&lt;/p&gt;

&lt;p&gt;On the other hand, warp specialization addresses programming challenges by separating operations intended to run simultaneously on different hardware units into distinct warps, synchronizing them efficiently using low-cost barriers in shared memory. This allows each warp to have its own instruction sequence, enabling instructions to be issued and executed continuously without being interrupted by other operations, thanks to the multi-way warp scheduler. An illustration of a warp-specialized GEMM can be seen in Figure 2.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/warp-specialization/fg2.jpg&quot; alt=&quot;Figure 2. GEMM K-loop Body with Specialized Warps&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Figure 2. GEMM K-loop Body with Specialized Warps&lt;/p&gt;

&lt;h2 id=&quot;how-to-enable-ws&quot;&gt;How to enable WS&lt;/h2&gt;

&lt;p&gt;To enable warp specialization, users simply need to specify two autotune flags: num_consumer_groups and num_buffers_warp_spec. For example, a warp-specialized GEMM implementation might look as shown below.  Users can enable warp specialization by setting a non-zero value for num_consumer_groups, which defines the number of consumer warp groups. There is no corresponding flag to set the number of producer warp groups, as currently only one producer is supported. The num_buffers_warp_spec flag specifies the number of buffers the producer warp group will use to communicate with the consumer warp groups. A working example of a warp-specialized kernel is provided in the persistent GEMM &lt;a href=&quot;https://github.com/triton-lang/triton/blob/6771065cb3137f7e64454cc047b9b74d577cbf7f/python/tutorials/09-persistent-matmul.py#L620&quot;&gt;tutorial&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@triton.autotune(
    configs=[
        triton.Config(
            {
                &quot;BLOCK_SIZE_M&quot;: 128,
                &quot;BLOCK_SIZE_N&quot;: 256,
                &quot;BLOCK_SIZE_K&quot;: 64,
                &quot;GROUP_SIZE_M&quot;: 8,
            },
            num_stages=2,
            num_warps=4,
            num_consumer_groups=2,
            num_buffers_warp_spec=3,
        ),
    ],
    key=[&quot;M&quot;, &quot;N&quot;, &quot;K&quot;],
)
@triton.jit
def matmul_persistent_ws_kernel(
   a_ptr, b_ptr, c_ptr, M, N, K,
   stride_am, stride_ak, stride_bk, stride_bn, stride_cm, stride_cn,
   BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,
):
   pid = tl.program_id(axis=0)
   num_pid_m = tl.cdiv(M, BLOCK_M)
   num_pid_n = tl.cdiv(N, BLOCK_N)
   pid_m = pid // num_pid_m
   pid_n = pid % num_pid_n
   offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)
   offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)
   offs_k = tl.arange(0, BLOCK_K)
   a_ptrs = a_ptr + (offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak)
   b_ptrs = b_ptr + (offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn)
   acc = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)
   for k in range(0, tl.cdiv(K, BLOCK_K)):
       a = tl.load(a_ptrs)
       b = tl.load(b_ptrs)
       acc += tl.dot(a, b)
       a_ptrs += BLOCK_K * stride_ak
       b_ptrs += BLOCK_K * stride_bk
   c = acc.to(tl.float16)
   c_ptrs = c_ptr + stride_cm * offs_m[:, None] + stride_cn * offs_n[None, :]
   tl.store(c_ptrs, c)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;under-the-hood&quot;&gt;Under the Hood&lt;/h2&gt;

&lt;p&gt;Warp specialization uses a set of hierarchical compiler transformations and IR changes to translate a user’s non-warp-specialized kernel into warp-specialized machine code. These include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Task Partitioning&lt;/strong&gt;: The entire kernel is automatically divided into asynchronous tasks based on predefined heuristics. The compiler determines how to utilize one producer warp group and a user-specified number of consumer warp groups to execute the kernel. It assigns task IDs to specific anchor operations, which then influence the task assignments for remaining operations through asynchronous task ID propagation and dependency analysis. Since shared memory is the most efficient method for data transfer between warp groups across all supported platforms, the compiler optimizes task partitions to minimize register spills to shared memory, ensuring efficient execution.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Data Partitioning for Multiple Consumer Groups&lt;/strong&gt;: Efficiently partitioning data among multiple consumer groups is key to optimizing workload distribution. On the H100 GPU, the compiler, by default, attempts to partition the input tensor &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; along the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;M&lt;/code&gt; dimension, allowing each consumer group to compute half of the output tensor independently. This strategy, known as &lt;a href=&quot;https://github.com/NVIDIA/cutlass/blob/main/media/docs/efficient_gemm.md#warp-specialization&quot;&gt;cooperative partitioning&lt;/a&gt;, maximizes efficiency under most conditions. However, if this split leads to inefficiencies—such as producing a workload smaller than the native WGMMA instruction size—the compiler dynamically adjusts and partitions along the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N&lt;/code&gt; dimension instead.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Dataflow Pipelining&lt;/strong&gt;: The compiler creates cyclic shared memory buffers to pipeline dataflows across multiple-dimensional loops. Warp-specialized pipelining supports complex control flow. For example, our warp-specialized persistent GEMM kernel uses a doubly-nested loop, allowing the producer to begin fetching data for the next output tile while the consumer is finishing the compute for the prior tile.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Communication Operations&lt;/strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;: &lt;/code&gt;We introduced four high-level Triton GPU IR (TTGIR) communication operations&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;—ProducerAcquireOp, ProducerCommitOp, ConsumerWaitOp, &lt;/code&gt;and&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; ConsumerReleaseOp—&lt;/code&gt;to manage pipelined dataflows. These support both TMA and non-TMA memory operations.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Code Partitioning&lt;/strong&gt;: Each async task is outlined into its own standalone code region, guarded by warp group ID checks. Control dependencies are duplicated as needed.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;TTGIR to LLVM/PTX Materialization&lt;/strong&gt;: TTGIR communication operations are materialized into corresponding LLVM/PTX barrier operations.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;performance&quot;&gt;Performance&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/triton-lang/triton/pull/5622&quot;&gt;warp specialization release&lt;/a&gt; introduces a range of Triton compiler transformations that collectively convert user code into warp-specialized kernels. This feature has been applied to several key kernels, including Flash Attention and FP8 row-wise GEMM, resulting in significant performance gains of 10% to 15%. Below, we highlight the latest performance metrics for these high-impact kernels.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/warp-specialization/fg3.png&quot; alt=&quot;bar chart&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/warp-specialization/fg4.png&quot; alt=&quot;bar chart&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;future-work&quot;&gt;Future Work&lt;/h2&gt;

&lt;p&gt;Looking ahead, we plan to further enhance Triton’s warp specialization support by introducing new features such as Ping-Pong scheduling, expanded buffer sharing support, improved transparent handling for TMA, refined partitioning heuristics for upcoming NVIDIA hardware.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Meta and NVIDIA</name>
        
        
      </author>

      

      

      
        <summary type="html">Meta: Hongtao Yu, Manman Ren, Bert Maher, Shane Nay NVIDIA: Gustav Zhu, Shuhao Jiang</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">PyTorch 2.6 Release Blog</title>
      <link href="https://pytorch.org/blog/pytorch2-6/" rel="alternate" type="text/html" title="PyTorch 2.6 Release Blog" />
      <published>2025-01-29T00:00:00-08:00</published>
      <updated>2025-01-29T00:00:00-08:00</updated>
      <id>https://pytorch.org/blog/pytorch2-6</id>
      <content type="html" xml:base="https://pytorch.org/blog/pytorch2-6/">&lt;p&gt;We are excited to announce the release of PyTorch® 2.6 (&lt;a href=&quot;https://github.com/pytorch/pytorch/releases/tag/v2.6.0&quot;&gt;release notes&lt;/a&gt;)! This release features multiple improvements for PT2: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.compile&lt;/code&gt; can now be used with Python 3.13; new performance-related knob &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.compiler.set_stance&lt;/code&gt;; several AOTInductor enhancements. Besides the PT2 improvements, another highlight is FP16 support on X86 CPUs.&lt;/p&gt;

&lt;p&gt;NOTE: Starting with this release we are not going to publish on Conda, please see &lt;a href=&quot;https://github.com/pytorch/pytorch/issues/138506&quot;&gt;[Announcement] Deprecating PyTorch’s official Anaconda channel&lt;/a&gt; for the details.&lt;/p&gt;

&lt;p&gt;For this release the experimental Linux binaries shipped with CUDA 12.6.3 (as well as Linux Aarch64,  Linux ROCm 6.2.4, and Linux XPU binaries) are built with CXX11_ABI=1 and are &lt;a href=&quot;https://dev-discuss.pytorch.org/t/pytorch-linux-wheels-switching-to-new-wheel-build-platform-manylinux-2-28-on-november-12-2024/2581&quot;&gt;using the Manylinux 2.28 build platform&lt;/a&gt;. If you build PyTorch extensions with custom C++ or CUDA extensions, please update these builds to use CXX_ABI=1 as well and report any issues you are seeing. For the next PyTorch 2.7 release we plan to switch all Linux builds to Manylinux 2.28 and CXX11_ABI=1, please see &lt;a href=&quot;https://github.com/pytorch/pytorch/issues/123649&quot;&gt;[RFC] PyTorch next wheel build platform: manylinux-2.28&lt;/a&gt; for the details and discussion.&lt;/p&gt;

&lt;p&gt;Also in this release as an important security improvement measure we have changed the default value for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;weights_only&lt;/code&gt; parameter of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.load&lt;/code&gt;. This is a backward compatibility-breaking change, please see &lt;a href=&quot;https://dev-discuss.pytorch.org/t/bc-breaking-change-torch-load-is-being-flipped-to-use-weights-only-true-by-default-in-the-nightlies-after-137602/2573&quot;&gt;this forum post&lt;/a&gt; for more details.&lt;/p&gt;

&lt;p&gt;This release is composed of 3892 commits from 520 contributors since PyTorch 2.5. We want to sincerely thank our dedicated community for your contributions. As always, we encourage you to try these out and report any issues as we improve PyTorch. More information about how to get started with the PyTorch 2-series can be found at our &lt;a href=&quot;https://pytorch.org/get-started/pytorch-2.0/&quot;&gt;Getting Started&lt;/a&gt; page.&lt;/p&gt;

&lt;table class=&quot;table table-bordered&quot;&gt;
  &lt;tr&gt;
   &lt;td&gt;Beta
   &lt;/td&gt;
   &lt;td&gt;Prototype
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;torch.compiler.set_stance
   &lt;/td&gt;
   &lt;td&gt;Improved PyTorch user experience on Intel GPUs
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;torch.library.triton_op
   &lt;/td&gt;
   &lt;td&gt;FlexAttention support on X86 CPU for LLMs
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;torch.compile support for Python 3.13
   &lt;/td&gt;
   &lt;td&gt;Dim.AUTO
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;New packaging APIs for AOTInductor
   &lt;/td&gt;
   &lt;td&gt;CUTLASS and CK GEMM/CONV Backends for AOTInductor
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;AOTInductor: minifier
   &lt;/td&gt;
   &lt;td&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;AOTInductor: ABI-compatible mode code generation
   &lt;/td&gt;
   &lt;td&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;FP16 support for X86 CPUs
   &lt;/td&gt;
   &lt;td&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;*To see a full list of public feature submissions click &lt;a href=&quot;https://docs.google.com/spreadsheets/d/1TzGkWuUMF1yTe88adz1dt2mzbIsZLd3PBasy588VWgk/edit?usp=sharing&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;beta-features&quot;&gt;BETA FEATURES&lt;/h2&gt;

&lt;h3 id=&quot;beta-torchcompilerset_stance&quot;&gt;[Beta] torch.compiler.set_stance&lt;/h3&gt;

&lt;p&gt;This feature enables the user to specify different behaviors (“stances”) that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.compile&lt;/code&gt; can take between different invocations of compiled functions. One of the stances, for example, is&lt;/p&gt;

&lt;p&gt;“eager_on_recompile”, that instructs PyTorch to code eagerly when a recompile is necessary, reusing cached compiled code when possible.&lt;/p&gt;

&lt;p&gt;For more information please refer to the &lt;a href=&quot;https://pytorch.org/docs/2.6/generated/torch.compiler.set_stance.html#torch.compiler.set_stance&quot;&gt;set_stance documentation&lt;/a&gt; and the &lt;a href=&quot;https://pytorch.org/tutorials/recipes/torch_compiler_set_stance_tutorial.html&quot;&gt;Dynamic Compilation Control with torch.compiler.set_stance&lt;/a&gt; tutorial.&lt;/p&gt;

&lt;h3 id=&quot;beta-torchlibrarytriton_op&quot;&gt;[Beta] torch.library.triton_op&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.library.triton_op&lt;/code&gt; offers a standard way of creating custom operators that are backed by user-defined triton kernels.&lt;/p&gt;

&lt;p&gt;When users turn user-defined triton kernels into custom operators, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.library.triton_op&lt;/code&gt; allows &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.compile&lt;/code&gt; to peek into the implementation, enabling &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.compile&lt;/code&gt; to optimize the triton kernel inside it.&lt;/p&gt;

&lt;p&gt;For more information please refer to the &lt;a href=&quot;https://pytorch.org/docs/2.6/library.html#torch.library.triton_op&quot;&gt;triton_op documentation&lt;/a&gt; and the&lt;a href=&quot;https://pytorch.org/tutorials/recipes/torch_compile_user_defined_triton_kernel_tutorial.html&quot;&gt; Using User-Defined Triton Kernels with torch.compile&lt;/a&gt; tutorial.&lt;/p&gt;

&lt;h3 id=&quot;beta-torchcompile-support-for-python-313&quot;&gt;[Beta] torch.compile support for Python 3.13&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.compile&lt;/code&gt; previously only supported Python up to version 3.12. Users can now optimize models with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.compile&lt;/code&gt; in Python 3.13.&lt;/p&gt;

&lt;h3 id=&quot;beta-new-packaging-apis-for-aotinductor&quot;&gt;[Beta] New packaging APIs for AOTInductor&lt;/h3&gt;

&lt;p&gt;A new package format, “&lt;a href=&quot;https://docs.google.com/document/d/1RQ4cmywilnFUT1VE-4oTGxwXdc8vowCSZsrRgo3wFA8/edit?usp=sharing&quot;&gt;PT2 archive&lt;/a&gt;”, has been introduced. This essentially contains a zipfile of all the files that need to be used by AOTInductor, and allows users to send everything needed to other environments. There is also functionality to package multiple models into one artifact, and to store additional metadata inside of the package.&lt;/p&gt;

&lt;p&gt;For more details please see the updated &lt;a href=&quot;https://pytorch.org/tutorials/recipes/torch_export_aoti_python.html&quot;&gt;torch.export AOTInductor Tutorial for Python runtime&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;beta-aotinductor-minifier&quot;&gt;[Beta] AOTInductor: minifier&lt;/h3&gt;

&lt;p&gt;If a user encounters an error while using AOTInductor APIs, AOTInductor Minifier allows creation of a minimal nn.Module that reproduces the error.&lt;/p&gt;

&lt;p&gt;For more information please see the &lt;a href=&quot;https://pytorch.org/docs/2.6/torch.compiler_aot_inductor_minifier.html&quot;&gt;AOTInductor Minifier documentation&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;beta-aotinductor-abi-compatible-mode-code-generation&quot;&gt;[Beta] AOTInductor: ABI-compatible mode code generation&lt;/h3&gt;

&lt;p&gt;AOTInductor-generated model code has dependency on Pytorch cpp libraries. As Pytorch evolves quickly, it’s important to make sure previously AOTInductor compiled models can continue to run on newer Pytorch versions, i.e. AOTInductor is backward compatible.&lt;/p&gt;

&lt;p&gt;In order to guarantee application binary interface (ABI) backward compatibility, we have carefully defined a set of stable C interfaces in libtorch and make sure AOTInductor generates code that only refers to the specific set of APIs and nothing else in libtorch. We will keep the set of C APIs stable across Pytorch versions and thus provide backward compatibility guarantees for AOTInductor-compiled models.&lt;/p&gt;

&lt;h3 id=&quot;beta-fp16-support-for-x86-cpus-both-eager-and-inductor-modes&quot;&gt;[Beta] FP16 support for X86 CPUs (both eager and Inductor modes)&lt;/h3&gt;

&lt;p&gt;Float16 datatype is commonly used for reduced memory usage and faster computation in AI inference and training. CPUs like the recently launched &lt;a href=&quot;https://www.intel.com/content/www/us/en/products/details/processors/xeon/xeon6-p-cores.html&quot;&gt;Intel® Xeon® 6 with P-Cores&lt;/a&gt; support Float16 datatype with native accelerator &lt;a href=&quot;https://www.intel.com/content/www/us/en/products/docs/accelerator-engines/advanced-matrix-extensions/overview.html&quot;&gt;AMX&lt;/a&gt;. Float16 support on X86 CPUs was introduced in PyTorch 2.5 as a prototype feature, and now it has been further improved for both eager mode and Torch.compile + Inductor mode, making it Beta level feature with both functionality and performance verified with a broad scope of workloads.&lt;/p&gt;

&lt;h2 id=&quot;prototype-features&quot;&gt;PROTOTYPE FEATURES&lt;/h2&gt;

&lt;h3 id=&quot;prototype-improved-pytorch-user-experience-on-intel-gpus&quot;&gt;[Prototype] Improved PyTorch user experience on Intel GPUs&lt;/h3&gt;

&lt;p&gt;PyTorch user experience on Intel GPUs is further improved with simplified installation steps, Windows release binary distribution and expanded coverage of supported GPU models including the latest Intel® Arc™ B-Series discrete graphics. Application developers and researchers seeking to fine-tune, inference and develop with PyTorch models on &lt;a href=&quot;https://www.intel.com/content/www/us/en/products/docs/processors/core-ultra/ai-pc.html&quot;&gt;Intel® Core™ Ultra AI PCs &lt;/a&gt;and &lt;a href=&quot;https://www.intel.com/content/www/us/en/products/details/discrete-gpus/arc.html&quot;&gt;Intel® Arc™ discrete graphics&lt;/a&gt; will now be able to directly install PyTorch with binary releases for Windows, Linux and Windows Subsystem for Linux 2.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Simplified Intel GPU software stack setup to enable one-click installation of the torch-xpu PIP wheels to run deep learning workloads in an out of the box fashion, eliminating the complexity of installing and activating Intel GPU development software bundles.&lt;/li&gt;
  &lt;li&gt;Windows binary releases for torch core, torchvision and torchaudio have been made available for Intel GPUs, and the supported GPU models have been expanded from Intel® Core™ Ultra Processors with Intel® Arc™ Graphics, &lt;a href=&quot;https://www.intel.com/content/www/us/en/products/details/processors/core-ultra.html&quot;&gt;Intel® Core™ Ultra Series 2 with Intel® Arc™ Graphics&lt;/a&gt; and &lt;a href=&quot;https://www.intel.com/content/www/us/en/products/docs/discrete-gpus/arc/desktop/a-series/overview.html&quot;&gt;Intel® Arc™ A-Series Graphics&lt;/a&gt; to the latest GPU hardware &lt;a href=&quot;https://www.intel.com/content/www/us/en/products/docs/discrete-gpus/arc/desktop/b-series/overview.html&quot;&gt;Intel® Arc™ B-Series graphics&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Further enhanced coverage of Aten operators on Intel GPUs with SYCL* kernels for smooth eager mode execution, as well as bug fixes and performance optimizations for torch.compile on Intel GPUs.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For more information regarding Intel GPU support, please refer to &lt;a href=&quot;https://pytorch.org/docs/main/notes/get_start_xpu.html&quot;&gt;Getting Started Guide&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;prototype-flexattention-support-on-x86-cpu-for-llms&quot;&gt;[Prototype] FlexAttention support on X86 CPU for LLMs&lt;/h3&gt;

&lt;p&gt;FlexAttention was initially introduced in PyTorch 2.5 to provide optimized implementations for Attention variants with a flexible API. In PyTorch 2.6, X86 CPU support for FlexAttention was added through TorchInductor CPP backend. This new feature leverages and extends current CPP template abilities to support broad attention variants (e.x.: PageAttention, which is critical for LLMs inference) based on the existing FlexAttention API, and brings optimized performance on x86 CPUs. With this feature, it’s easy to use FlexAttention API to compose Attention solutions on CPU platforms and achieve good performance.&lt;/p&gt;

&lt;h3 id=&quot;prototype-dimauto&quot;&gt;[Prototype] Dim.AUTO&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dim.AUTO&lt;/code&gt; allows usage of automatic dynamic shapes with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.export&lt;/code&gt;. Users can export with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dim.AUTO &lt;/code&gt;and “discover” the dynamic behavior of their models, with min/max ranges, relations between dimensions, and static/dynamic behavior being automatically inferred.&lt;/p&gt;

&lt;p&gt;This is a more user-friendly experience compared to the existing named-Dims approach for specifying dynamic shapes, which requires the user to fully understand the dynamic behavior of their models at export time. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dim.AUTO&lt;/code&gt; allows users to write generic code that isn’t model-dependent, increasing ease-of-use for exporting with dynamic shapes.&lt;/p&gt;

&lt;p&gt;Please see &lt;a href=&quot;https://pytorch.org/tutorials/intermediate/torch_export_tutorial.html#constraints-dynamic-shapes&quot;&gt;torch.export tutorial&lt;/a&gt; for more information.&lt;/p&gt;

&lt;h3 id=&quot;prototype-cutlass-and-ck-gemmconv-backends-for-aotinductor&quot;&gt;[Prototype] CUTLASS and CK GEMM/CONV Backends for AOTInductor&lt;/h3&gt;

&lt;p&gt;The CUTLASS and CK backend adds kernel choices for GEMM autotuning in Inductor. This is now also available in AOTInductor which can run in C++ runtime environments. A major improvement to the two backends is improved compile-time speed by eliminating redundant kernel binary compilations and dynamic shapes support.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Facebook</name>
        
        
      </author>

      

      

      
        <summary type="html">We are excited to announce the release of PyTorch® 2.6 (release notes)! This release features multiple improvements for PT2: torch.compile can now be used with Python 3.13; new performance-related knob torch.compiler.set_stance; several AOTInductor enhancements. Besides the PT2 improvements, another highlight is FP16 support on X86 CPUs.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">2025 Priorities for the PyTorch Technical Advisory Council (TAC)</title>
      <link href="https://pytorch.org/blog/2025-priorities-for-tac/" rel="alternate" type="text/html" title="2025 Priorities for the PyTorch Technical Advisory Council (TAC)" />
      <published>2025-01-28T00:00:00-08:00</published>
      <updated>2025-01-28T00:00:00-08:00</updated>
      <id>https://pytorch.org/blog/2025-priorities-for-tac</id>
      <content type="html" xml:base="https://pytorch.org/blog/2025-priorities-for-tac/">&lt;p&gt;&lt;img src=&quot;/assets/images/1738166706211.jpg&quot; alt=&quot;social share&quot; style=&quot;max-width:600px; width:100%; display: block; margin-left: auto; margin-right: auto&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://pytorch.org/blog/2024-year-in-review/&quot;&gt;2024 has been a year of incredible growth for PyTorch&lt;/a&gt;. As that continues in 2025, the PyTorch Foundation has made important steps towards evolving the governance of the project under the Linux Foundation’s vendor-neutral umbrella.&lt;/p&gt;

&lt;p&gt;An important piece of governance for PyTorch is represented by the Technical Advisory Council (TAC). The TAC acts as a bridge between the industry, including but not limited to the PyTorch Foundation members, the community, and the PyTorch core development team.&lt;/p&gt;

&lt;p&gt;Operating with transparency and inclusivity, the TAC gathers input, facilitates collaboration, and drives initiatives that enhance the experience for everyone who relies on PyTorch.&lt;/p&gt;

&lt;p&gt;In 2025, the TAC will focus on four key areas:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Build Open, Multi-Cloud Continuous Integration (CI):&lt;/strong&gt; Building on the groundwork from 2024, the TAC will oversee the transition to an open, community-driven CI infrastructure. In addition to ensuring the extremely high bar for correctness that PyTorch has, PyTorch’s CI is complex with a high-quality bar including many automated functional and performance daily test runs. In 2025, PyTorch’s CI infrastructure will be fully open sourced and extended to support multiple compute providers, enabling broader contribution and participation to the effort from organizations benefitting from PyTorch.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Support more Accelerators:&lt;/strong&gt; The TAC is committed to creating a level playing field for the growing landscape of AI accelerators. By gathering industry players and PyTorch developers, the TAC will facilitate efforts towards third-party device support and provide levels of integration of external CI systems with the main PyTorch CI. This will make it easier for emerging hardware to gain adoption within the PyTorch ecosystem, and for users to experiment with diverse compute options for training and inference.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Create a High-Quality, User-Centric Ecosystem:&lt;/strong&gt; A big focus for the TAC in early 2025 is on improving the experience and discoverability of the PyTorch ecosystem. With many projects growing organically, users often face challenges navigating projects of different scope and quality within the rapidly changing AI landscape. To solve this, a newly curated ecosystem landscape tool will be launched soon on the PyTorch website. We will also introduce lightweight, open processes to improve projects and ensure users a predictable, high-quality experience. In many ways, the experience with PyTorch is as good as its ecosystem.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Gather Feedback from Industry and the Community:&lt;/strong&gt; PyTorch has widespread adoption across research labs, startups, and enterprises. Striking the right balance between expressiveness and performance across the board is a very challenging task, so the TAC set out to be one of the several ways the Core development team receives signals. During our monthly TAC meetings, we provide the opportunity to PyTorch Foundation members from industry and academia, as well as non-member organizations to present their use case, their challenges and discuss them directly with appropriate members of the Core team. This feedback loop helps prioritize improvements, ensuring the framework stays relevant in a fast-evolving AI landscape.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;By focusing on these priorities, the TAC aims to maintain PyTorch’s position as the leading deep learning framework, while ensuring it remains open, accessible, and responsive to the needs of its diverse community.&lt;/p&gt;

&lt;p&gt;As members of the TAC, we’re extremely excited to contribute to the success of PyTorch and to the impact it’s having in the real world. If you are a PyTorch user or developer, consider &lt;a href=&quot;https://zoom-lfx.platform.linuxfoundation.org/meetings/pytorch?__hstc=132719121.a26416c161ac91bef494ffc19f91a62e.1723036593114.1738082449904.1738088158683.375&amp;amp;__hssc=132719121.1.1738088158683&amp;amp;__hsfp=810579359&quot;&gt;participating in our monthly calls&lt;/a&gt; (they are open to everyone, and the recordings are available &lt;a href=&quot;https://lists.pytorch.org/g/tac&quot;&gt;here&lt;/a&gt;). Also, if you develop or maintain a project based on PyTorch, consider contributing it to the new PyTorch ecosystem (&lt;a href=&quot;https://github.com/pytorch-fdn/ecosystem&quot;&gt;instructions&lt;/a&gt;).&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Luca Antiga, PyTorch TAC Chair</name>
        
        
      </author>

      

      

      
        <summary type="html"></summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">How Intel Uses PyTorch to Empower Generative AI through Intel Arc GPUs</title>
      <link href="https://pytorch.org/blog/how-intel-uses-pytorch-to-empower-generative-ai-through-intel-arc-gpus/" rel="alternate" type="text/html" title="How Intel Uses PyTorch to Empower Generative AI through Intel Arc GPUs" />
      <published>2025-01-24T00:00:00-08:00</published>
      <updated>2025-01-24T00:00:00-08:00</updated>
      <id>https://pytorch.org/blog/how-intel-uses-pytorch-to-empower-generative-ai-through-intel-arc-gpus</id>
      <content type="html" xml:base="https://pytorch.org/blog/how-intel-uses-pytorch-to-empower-generative-ai-through-intel-arc-gpus/">&lt;p&gt;Intel has long been at the forefront of technological innovation, and its recent venture into Generative AI (GenAI) solutions is no exception. With the rise of AI-powered gaming experiences, Intel sought to deliver an accessible and intuitive GenAI inferencing solution tailored for AI PCs powered by Intel’s latest GPUs. By leveraging PyTorch as the backbone for development efforts, Intel successfully launched AI Playground, an open source application that showcases advanced GenAI workloads.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The Business Challenge&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Our goal was to deliver an accessible and intuitive GenAI inferencing solution tailored for AI PCs powered by Intel. We recognized the need to showcase the capabilities of the latest GenAI workloads on our newest line of client GPUs. To address this, we developed a starter application, &lt;a href=&quot;https://github.com/intel/ai-playground&quot;&gt;AI Playground&lt;/a&gt;, which is open source and includes a comprehensive developer reference sample available on GitHub using PyTorch. This application seamlessly integrates image generation, image enhancement, and chatbot functionalities, using retrieval-augmented generation (RAG) features, all within a single, user-friendly installation package. This initiative not only demonstrates the functionality of these AI workloads but also serves as an educational resource for the ecosystem, guiding developers on effectively leveraging the &lt;a href=&quot;https://www.intel.com/content/www/us/en/products/details/discrete-gpus/arc.html&quot;&gt;Intel® Arc™ GPU&lt;/a&gt; product line for advanced AI applications. This solution leverages Intel® Arc™ Xe Cores and &lt;a href=&quot;https://www.intel.com/content/www/us/en/support/articles/000091112/graphics.html&quot;&gt;Xe Matrix Extensions (XMX)&lt;/a&gt; for accelerating inferencing.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/intel-case-study/fg1.png&quot; alt=&quot;AI Playground&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How Intel Used PyTorch&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;PyTorch is the core AI framework for AI Playground. We extensively leverage PyTorch’s eager mode, which aligns perfectly with the dynamic and iterative nature of our generative models. This approach not only enhances our development workflow but also enables us to rapidly prototype and iterate on advanced AI features. By harnessing PyTorch’s powerful capabilities, we have created a robust reference sample that showcases the potential of GenAI on Intel GPUs in one cohesive application.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Solving AI Challenges with PyTorch&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;PyTorch has been instrumental in addressing our AI challenges by providing a robust training and inference framework optimized for discrete and integrated Intel Arc GPU product lines. Choosing PyTorch over alternative frameworks or APIs was crucial. Other options would have necessitated additional custom development or one-off solutions, which could have significantly slowed our time to market and limited our feature set. With PyTorch, we leveraged its flexibility and ease of use, allowing our team to focus on innovation through experimentation, rather than infrastructure. The integration of &lt;a href=&quot;https://www.intel.com/content/www/us/en/developer/tools/oneapi/optimization-for-pytorch.html#gs.j6azz7&quot;&gt;Intel® Extension for PyTorch&lt;/a&gt; further enhanced performance by optimizing computational efficiency and enabling seamless scaling on Intel hardware, ensuring that our application ran faster and more efficiently.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A Word from Intel&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;With PyTorch as the backbone of our AI Playground project, we achieved rapid development cycles that significantly accelerated our time to market. This flexibility enabled us to iteratively enhance features and effectively align with the commitments of our hardware launches in 2024.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;-Bob Duffy, AI Playground Product Manager&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/intel-case-study/fg2.png&quot; alt=&quot;PyTorch Case Stidu&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The Benefits of Using PyTorch&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The biggest benefit of using PyTorch for us is the large PyTorch ecosystem, which connects us with an active and cooperative community of developers. This collaboration has facilitated the seamless deployment of key features from existing open source projects, allowing us to integrate the latest GenAI capabilities into AI Playground. Remarkably, we accomplished this with minimal re-coding, ensuring that these advanced features are readily accessible on Intel Arc GPUs.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Learn More&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;For more information about Intel’s AI Playground and collaboration with PyTorch, visit the following links:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.intel.com/content/www/us/en/developer/tools/oneapi/optimization-for-pytorch.html#gs.j8h6mc&quot;&gt;PyTorch Optimizations from Intel&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/intel/ai-playground&quot;&gt;AI Playground GitHub&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://intel.com/ai-playground&quot;&gt;AI Playground&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://youtu.be/cYPZye1MC6U&quot;&gt;AI Playground Deep Dive Video&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://pytorch.org/blog/intel-gpu-support-pytorch-2-5/&quot;&gt;Intel GPU Support Now Available in PyTorch 2.5&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>Team PyTorch</name>
        
        
      </author>

      

      

      
        <summary type="html">Intel has long been at the forefront of technological innovation, and its recent venture into Generative AI (GenAI) solutions is no exception. With the rise of AI-powered gaming experiences, Intel sought to deliver an accessible and intuitive GenAI inferencing solution tailored for AI PCs powered by Intel’s latest GPUs. By leveraging PyTorch as the backbone for development efforts, Intel successfully launched AI Playground, an open source application that showcases advanced GenAI workloads.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Bringing the PyTorch Community Together</title>
      <link href="https://pytorch.org/blog/bringing-the-pytorch-community-together/" rel="alternate" type="text/html" title="Bringing the PyTorch Community Together" />
      <published>2025-01-22T00:00:00-08:00</published>
      <updated>2025-01-22T00:00:00-08:00</updated>
      <id>https://pytorch.org/blog/bringing-the-pytorch-community-together</id>
      <content type="html" xml:base="https://pytorch.org/blog/bringing-the-pytorch-community-together/">&lt;p&gt;As we step into a new year, it’s a great moment to reflect on the incredible community events that made 2024 a memorable year for the PyTorch Foundation. Global meetups, events, and conferences brought the community together to learn, connect, and grow. Here’s a quick recap of the year’s highlights and what to expect in 2025.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/community-events-recap/fg5.jpg&quot; alt=&quot;PyTorch Seattle Meetup (May 23)&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PyTorch Seattle Meetup (May 23)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We hosted a PyTorch Meetup in Seattle in May at the Meta Bellevue Office where Meta, Microsoft, and Google gave technical talks and about 60 attendees participated in discussion and networking.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PyTorch Docathon 2024 (June 4-20)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The PyTorch Docathon returned for its third edition, spanning over two weeks in June. This unique event focused on improving PyTorch’s documentation with contributions from community members worldwide. Documentation is the backbone of any successful open source project, and PyTorch’s Docathon fostered inclusivity and collaboration, making it easier for new users to adopt the framework and for experienced developers to maximize its potential. The 2024 Docathon resulted in more than 50 merged pull requests and was a testament to the collaborative spirit of the PyTorch community and its commitment to enhancing accessibility and usability. Watch the &lt;a href=&quot;https://youtu.be/2D0aej50umA?feature=shared&quot;&gt;PyTorch Docathon Kickoff&lt;/a&gt; on YouTube.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/community-events-recap/fg3.png&quot; alt=&quot;PyTorch Shanghai Meetup (August 15)&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;pytorch-shanghai-meetup-august-15&quot;&gt;&lt;strong&gt;PyTorch Shanghai Meetup (August 15)&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;In August, the &lt;a href=&quot;https://pytorch.org/blog/pytorch-shanghai-notes/&quot;&gt;PyTorch Shanghai Meetup&lt;/a&gt; brought together developers, researchers, and enthusiasts in Shanghai, China. This event served as a platform for knowledge sharing, with engaging talks and networking opportunities. Highlights from the agenda included insights into PyTorch’s latest developments, community-led presentations showcasing innovative use cases, and networking sessions fostering collaboration among attendees.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/community-events-recap/fg1.jpg&quot; alt=&quot;PyTorch Conference 2024 (September 18-19)&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;pytorch-conference-2024-september-18-19&quot;&gt;&lt;strong&gt;PyTorch Conference 2024 (September 18-19)&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;The PyTorch Conference in San Francisco was undoubtedly one of the year’s most significant events. This two-day gathering brought together top-tier researchers, developers, and academic communities, fostering collaboration and innovation in machine learning.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/community-events-recap/fg6.jpeg&quot; alt=&quot;What Made It Special&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;what-made-it-special&quot;&gt;&lt;strong&gt;What Made It Special:&lt;/strong&gt;&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Keynote speeches from industry leaders and PyTorch maintainers.&lt;/li&gt;
  &lt;li&gt;In-depth sessions covering PyTorch’s end-to-end machine learning capabilities.&lt;/li&gt;
  &lt;li&gt;Hands-on workshops and breakout sessions.&lt;/li&gt;
  &lt;li&gt;A vibrant expo area showcasing cutting-edge tools and applications.&lt;/li&gt;
  &lt;li&gt;Startup Showcase where early-stage founders pitched their AI startups to a panel of top venture capitalists.&lt;/li&gt;
  &lt;li&gt;DL Compiler Mini-Summit that took a deep dive into the advances in deep learning (DL) compilers that are transforming AI workloads.&lt;/li&gt;
  &lt;li&gt;Fine-Tuning Mini-Summit that covered everything from memory efficiency, parameter-efficient fine-tuning and quantization to performance at scale and reproducible evaluations.&lt;/li&gt;
  &lt;li&gt;Poster Session showcasing innovations in PyTorch, including model optimization, hardware integration, generative AI, quantization, and tools for enhanced performance and usability, with contributions from industry leaders.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The conference’s focus on fostering collaboration underscored PyTorch’s role as a driving force in the open source ML community. Missed out? You can watch the &lt;a href=&quot;https://youtube.com/playlist?list=PL_lsbAsL_o2B_znuvm-pDtV_cRhpqZb8l&amp;amp;si=mdoSkqMJYKRlzxlg&quot;&gt;PyTorch Conference 2024 Playlist&lt;/a&gt; to catch any sessions you might have missed.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/community-events-recap/fg4.jpg&quot; alt=&quot;GPU MODE IRL Hackathon (September 21)&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;gpu-mode-irl-hackathon-september-21&quot;&gt;&lt;strong&gt;GPU MODE IRL Hackathon (September 21)&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;PyTorch sponsored this meetup in person in San Francisco where attendees made friends, watched keynotes, hacked all day, took breaks with afternoon talks, and then hacked all night. We heard about torchao, our new quantization and sparsity library, vLLM which deploys PyTorch models in production, llm.c, and more. Key takeaways included: GPU Mode IRL Hackathon 1st place winner was inspired by PyTorch FlexAttention to improve CUTLASS, NCCL in Triton would help us do distributed programming with a minimal NCCL reimplementation in pure Python, No libtorch pytorch binaries dramatically reduces binary sizes for on device deployments.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/community-events-recap/fg8.png&quot; alt=&quot;Consumer AI Edge Hackathon (November 22-23)&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;consumer-ai-edge-hackathon-november-22-23&quot;&gt;&lt;strong&gt;Consumer AI Edge Hackathon (November 22-23)&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;The PyTorch team served as mentors and coaches in a Hackathon in Paris, co-sponsored by Hugging Face, Scaleway, and Entrepreneur First, challenging teams to create innovative consumer (B2C) applications leveraging Hugging Face, PyTorch and other open source on-device tools and models. 120+ people across 22 teams hacked for 2 days (and nights!) building the future of AI-powered on-device solutions based on open source models and tools. Participants created innovative applications,  powered by PyTorch, &lt;a href=&quot;https://github.com/pytorch/executorch/tree/main&quot;&gt;ExecuTorch&lt;/a&gt; and Hugging Face resources, such as an on-device yoga coach, a magical storytelling companion and a Kinect-like experience to mobile phones. The PyTorch team is planning similar events in other geographies in 2025 around innovative on-device AI applications.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/community-events-recap/fg9.png&quot; alt=&quot;PyTorch Korea User Group Meetup (November 30)&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;pytorch-korea-user-group-meetup-november-30&quot;&gt;&lt;strong&gt;PyTorch Korea User Group Meetup (November 30)&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;The PyTorch Korea User Group, founded in 2018, is a community dedicated to introducing PyTorch to Korean-speaking users and growing together. The group began by translating PyTorch 0.3 tutorials into Korean and has since supported PyTorch’s growth in Korea. The group focuses on three primary activities:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Sharing knowledge for PyTorch learning and application,&lt;/li&gt;
  &lt;li&gt;Sharing insights and experiences in the field of artificial intelligence, and&lt;/li&gt;
  &lt;li&gt;Fostering growth through online and offline networking.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The PyTorch Korea User Group reaches tens of thousands of Korean AI developers every month. If you’re interested in their activities, check out these links:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://pytorch.kr&quot;&gt;PyTorch Korea User Group&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://tutorials.pytorch.kr&quot;&gt;PyTorch Korean Tutorials&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://discuss.pytorch.kr&quot;&gt;PyTorch Korean Community&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/PyTorchKorea&quot;&gt;GitHub Repository&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://youtube.com/@pytorchkr&quot;&gt;YouTube Channel&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/community-events-recap/fg2.jpeg&quot; alt=&quot;PyTorch Korea User Group 2025 Events Overview&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The PyTorch Korea User Group has planned three major activities for the year:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;PyTorch CoreSIG&lt;/strong&gt;&lt;br /&gt;
Since December 2024, this weekly online event has been held every Wednesday afternoon. Led by Kim Hong-Seok, CSO of Rebellions (a PyTorch member company), it provides in-depth knowledge and experience regarding PyTorch internals. Approximately 150 Korean developers participate weekly, reflecting growing interest in PyTorch Core development in Korea.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Offline Meetup&lt;/strong&gt;&lt;br /&gt;
These meetups provide opportunities to share insights and experiences in PyTorch and artificial intelligence, along with networking. Around 3–4 sessions are planned for this year, focusing on key topics in PyTorch and AI.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Online Community Engagement&lt;/strong&gt;&lt;br /&gt;
This activity involves sharing and discussing various projects and papers in the AI field. For more information, visit: &lt;a href=&quot;https://discuss.pytorch.kr&quot;&gt;https://discuss.pytorch.kr&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;open-source-ai-night-at-neurips-2024-december-10&quot;&gt;&lt;strong&gt;Open Source AI Night at NeurIPS 2024 (December 10)&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;The PyTorch Foundation co-hosted a social event at NeurIPS along with The Fin AI and Open Finance Foundation that featured engaging discussions on open source AI and applications in finance.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/community-events-recap/fg7.jpeg&quot; alt=&quot;PyTorch Webinars&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PyTorch Webinars&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Throughout 2024, PyTorch hosted the following virtual webinars:&lt;/p&gt;

&lt;p&gt;Expert Exchanges:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/live/HTcnp9NEHGY?feature=shared&quot;&gt;How does batching work on modern CPUs?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/live/Bh-jlh5vlF0?feature=shared&quot;&gt;DistServe: disaggregating prefill and decoding for goodput-optimized LLM inference&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/live/RnM84Sv9WpA?feature=shared&quot;&gt;Efficient Streaming Language Models with Attention Sinks&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/live/e1qUJFAo10s?feature=shared&quot;&gt;Adapting open source models with Open-Instruct and Tulu&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/live/Eqg0VIiWrgM?feature=shared&quot;&gt;Efficient Generative Models: From Sparse to Distributed Inference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Summer Series:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://youtu.be/xf2QgioY370?feature=shared&quot;&gt;Using PyTorch for Monocular Depth Estimation Webinar&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://youtu.be/NeHIhQWewug?feature=shared&quot;&gt;Accelerating LLM family of models on Arm Neoverse based Graviton AWS processors with KleidiAI&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/live/rew5CSUaIXg?feature=shared&quot;&gt;torch.compile: The Missing Manual&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Release Live Q&amp;amp;As:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/live/ry_QgUIYX1E?feature=shared&quot;&gt;PyTorch 2.4: Live Q&amp;amp;A&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/live/B3IgXpl4xt4?feature=shared&quot;&gt;PyTorch 2.5 Live Q&amp;amp;A&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Live Webinars:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=EjgTv6aSeqk&quot;&gt;PyTorch Documentary Virtual Premiere&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=gSC_IHyx0IM&quot;&gt;Using PyTorch to Help Predict Wildfires&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=zvk3Rr-OjU0&quot;&gt;Seismic Data to Subsurface Models with OpenFWI: Training an AI Model with PyTorch&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=w4JmPkqnD0E&quot;&gt;Dinosaur Bone Hunting with Intel AI&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Each of these events underscored the importance of collaboration and community engagement in advancing AI research and applications. Thank you to everyone who participated, organized, and supported these events—your contributions make all the difference!&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;looking-ahead&quot;&gt;&lt;strong&gt;Looking Ahead&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;2024 was packed with opportunities to connect, learn, and contribute, and there will be even more ways to connect with the PyTorch community in 2025.&lt;/p&gt;

&lt;p&gt;Mark your calendar! The &lt;a href=&quot;https://events.linuxfoundation.org/pytorch-conference-2025/&quot;&gt;PyTorch Conference&lt;/a&gt; is returning to San Francisco on October 22-23, 2025. Get ready for an exciting event filled with technical deep dives, exciting announcements, insightful sessions, and enhanced opportunities for community collaboration.&lt;/p&gt;

&lt;p&gt;Stay tuned for more upcoming events and opportunities to get involved by &lt;a href=&quot;https://pytorch.org/newsletter&quot;&gt;subscribing to our newsletter&lt;/a&gt;.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Team PyTorch</name>
        
        
      </author>

      

      

      
        <summary type="html">As we step into a new year, it’s a great moment to reflect on the incredible community events that made 2024 a memorable year for the PyTorch Foundation. Global meetups, events, and conferences brought the community together to learn, connect, and grow. Here’s a quick recap of the year’s highlights and what to expect in 2025.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Accelerating LLM Inference with GemLite, TorchAO and SGLang</title>
      <link href="https://pytorch.org/blog/accelerating-llm-inference/" rel="alternate" type="text/html" title="Accelerating LLM Inference with GemLite, TorchAO and SGLang" />
      <published>2025-01-21T00:00:00-08:00</published>
      <updated>2025-01-21T00:00:00-08:00</updated>
      <id>https://pytorch.org/blog/accelerating-llm-inference</id>
      <content type="html" xml:base="https://pytorch.org/blog/accelerating-llm-inference/">&lt;p&gt;Large Language Models (LLMs) are typically very resource-intensive, requiring significant amounts of memory, compute and power to operate effectively. Quantization provides a solution by reducing weights and activations from 16 bit floats to lower bitrates (e.g., 8 bit, 4 bit, 2 bit), achieving significant speedup and memory savings and also enables support for larger batch sizes.&lt;/p&gt;

&lt;p&gt;Existing solutions for low precision inference work well for small batch sizes, but suffer from following issues:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Performance drops when we increase the batch size&lt;/li&gt;
  &lt;li&gt;Restrictions on types of quantization, for example, some kernels only support symmetric quantization that could have implications on accuracy of the model at lower bits&lt;/li&gt;
  &lt;li&gt;Interplay between quantization, serialization, and tensor parallelism (TP) makes it difficult to load quantized models and requires changes to user models&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To address these challenges, we created an end-to-end, performant, modular and extensible low-precision inference solution integrating the following libraries:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/mobiusml/gemlite&quot;&gt;GemLite&lt;/a&gt;, a Triton kernel library, tackles the performance limitations of large batch sizes and restrictions on the types of quantization&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/pytorch/ao&quot;&gt;TorchAO&lt;/a&gt;, a PyTorch-native library, provides a streamlined experience for quantization, sparsity, and tensor parallelism (with DTensor)&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/sgl-project/sglang&quot;&gt;SGLang&lt;/a&gt;, a fast, efficient and hackable serving framework for Large Language Model (LLM) and Vision Language Models (VLM) with extensive model support&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you’re interested in trying this out in SGLang, please follow these &lt;a href=&quot;#repro-instructions&quot;&gt;repro instructions&lt;/a&gt;. For the rest of the blog, we’ll walk through relevant details for GemLite, TorchAO and SGlang both in terms of the design of the library itself and integration in addressing the problems we mentioned above, in the end we’ll present the benchmarking results on Llama 3.1-8B model across different batch sizes and tensor parallel sizes.&lt;/p&gt;

&lt;h2 id=&quot;1-teaser-of-results&quot;&gt;1. Teaser of Results&lt;/h2&gt;

&lt;p&gt;Following is a summary of the results in 8xH100 machine on Llama 3.1-8B for decode. For all experiments, the baseline is bfloat16 torch.compiled model:&lt;/p&gt;

&lt;table class=&quot;table table-bordered&quot;&gt;
  &lt;tr&gt;
   &lt;td&gt;
   &lt;/td&gt;
   &lt;td&gt;bfloat16 w/ torch.compile
   &lt;/td&gt;
   &lt;td&gt;int4 weight only quantization, group size 64
   &lt;/td&gt;
   &lt;td&gt;float8 per row dynamic quantization
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;Batch size 1, TP size 1
   &lt;/td&gt;
   &lt;td&gt;131 tokens/sec
   &lt;/td&gt;
   &lt;td&gt;255 tokens/sec (1.95x speedup)
   &lt;/td&gt;
   &lt;td&gt;166 tokens/sec (1.27x speedup)
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;Batch size 32, TP size 1
   &lt;/td&gt;
   &lt;td&gt;2799 tokens/sec
   &lt;/td&gt;
   &lt;td&gt;3241 tokens/sec (1.16x speedup)
   &lt;/td&gt;
   &lt;td&gt;3586 tokens/sec (1.28x speedup)
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;Batch size 32, TP size 4
   &lt;/td&gt;
   &lt;td&gt;5575 tokens/sec
   &lt;/td&gt;
   &lt;td&gt;6334 tokens/sec (1.14x speedup)
   &lt;/td&gt;
   &lt;td&gt;6159 tokens/sec (1.10x speedup)
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;Our solution supports NVIDIA GPUs, including H100 and A100, and achieves speedup over the compiled bfloat16 baseline across batch sizes and TP sizes for both int4 weight only (from 1.14x to 1.95x) and float8 dynamic quantization (from 1.10x to 1.28x). Note that quantization may have a small impact on accuracy, which is outside the scope of this blogpost. Our int4 weight-only quantization is compatible with accuracy preserving techniques like HQQ. Please refer to &lt;a href=&quot;https://github.com/pytorch/ao/blob/main/torchao/quantization/README.md#cuda-backend-1&quot;&gt;TorchAO’s README&lt;/a&gt;, &lt;a href=&quot;https://huggingface.co/mobiuslabsgmbh/Llama-3.1-8b-instruct_4bitgs64_hqq_calib&quot;&gt;this benchmark&lt;/a&gt;, and &lt;a href=&quot;https://neuralmagic.com/blog/we-ran-over-half-a-million-evaluations-on-quantized-llms-heres-what-we-found/&quot;&gt;this blog&lt;/a&gt; for more information.&lt;/p&gt;

&lt;h2 id=&quot;2-gemlite-kernel-development&quot;&gt;2. GemLite: Kernel Development&lt;/h2&gt;

&lt;p&gt;The kernels were developed as part of GemLite, a project dedicated to optimizing low-bit matrix multiplication kernels. Developed using Triton, GemLite provides highly flexible and performant solutions across various activations, bitrates and hardware. In a nutshell, the kernels offer:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Support for various activation data types:  fp16, int8 and fp8&lt;/li&gt;
  &lt;li&gt;Compatibility: works seamlessly with non-packed (e.g., int8, fp8) and packed formats (e.g., uint4, uint2, uint1)&lt;/li&gt;
  &lt;li&gt;Performance Optimization: includes optimized kernels and autotuning tools to achieve high performance across different hardware and batch sizes&lt;/li&gt;
  &lt;li&gt;Integration: Compatible with torch.compile and CUDA graphs, ensuring support for advanced features like tensor parallelism&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;kernel-selection&quot;&gt;Kernel Selection&lt;/h3&gt;

&lt;p&gt;Optimizing kernel selection for large language model (LLM) generation requires addressing the distinct needs of different batch sizes. LLM workloads involve a mix of compute-bound and memory-bound iterations: smaller batch sizes are memory-bound, while larger batch sizes become compute-bound. GemLite kernels are designed to adapt to these varying demands, ensuring optimal execution for each scenario.&lt;/p&gt;

&lt;p&gt;In memory-bound scenarios, where data transfer is the limiting factor, the processor often waits for data to be fetched, leading to underutilized computational resources. For batch size = 1, a GEMV kernel performs best, whereas for larger batch sizes, GEMM kernels are more efficient. For batch sizes between 2 and 64, when matrices are “skinny,” a GEMM-SPLITK kernel is used to enable better GPU utilization (&lt;a href=&quot;https://arxiv.org/abs/2402.00025&quot;&gt;arXiv&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;GemLite includes the following kernels optimized for each of these scenarios:&lt;/p&gt;

&lt;h3 id=&quot;single-sample-inference&quot;&gt;Single Sample Inference&lt;/h3&gt;

&lt;p&gt;For single-sample inferences, we use GEMV kernels. However, asymmetric quantization methods require additional metadata, such as scales and zero points, to be loaded for each block. This can lead to increased memory transfer, so careful handling is essential.&lt;/p&gt;

&lt;p&gt;Specifically, for packed data, our experiments indicate that loading scales and zero points only once per two consecutive blocks minimizes redundant operations. Since these blocks share the same metadata, this approach results in:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;5–8% end-to-end inference speedup compared to the default GEMV kernel&lt;/li&gt;
  &lt;li&gt;30–40% improvement over the traditional Split-K method&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This new kernel/algorithm, GEMV_REVSPLITK, is available &lt;a href=&quot;https://github.com/mobiusml/gemlite/blob/master/gemlite/triton_kernels/gemv_revsplitK_A16fWnO16f_int32packing.py&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For non-packed data, the &lt;a href=&quot;https://github.com/mobiusml/gemlite/blob/master/gemlite/triton_kernels/gemv_splitK_A16fWnO16f_int32packing.py&quot;&gt;GEMV_SPLITK&lt;/a&gt; algorithm is employed. This algorithm iterates over the k-dimension to compute the dot product without relying on Triton’s tl.dot.&lt;/p&gt;

&lt;h3 id=&quot;batched-inference&quot;&gt;Batched Inference&lt;/h3&gt;

&lt;p&gt;For moderate batch sizes, we use the GEMM-based Split-K method (&lt;a href=&quot;https://arxiv.org/abs/2402.00025&quot;&gt;arXiv&lt;/a&gt;) which splits the k-dimension (weight rows) into multiple jobs. The optimal-split SPLIT_K parameter is found by autotuning values ranging from 1 to 16. Setting SPLIT_K=1 enables a fallback implementation to a GEMM kernel, allowing the same kernel code to be used for compute-bound batch sizes starting from 32 and 64, depending on the matrix shape and the device.&lt;/p&gt;

&lt;h3 id=&quot;maximizing-high-performance-key-implementation-insights&quot;&gt;Maximizing High Performance: Key Implementation Insights&lt;/h3&gt;

&lt;p&gt;Various implementation details must be carefully addressed to achieve high performance. Following are some of the key aspects we focused on to ensure high performance:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Autotuning for Performance&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://triton-lang.org/main/python-api/generated/triton.autotune.html&quot;&gt;Autotuning&lt;/a&gt; is critical for achieving optimal kernel performance. Since this process can be time-intensive, GemLite provides tools to automatically save and load autotuning results for all kernels. This ensures that the autotuning process is performed only once per GPU device, minimizing runtime, reducing repetitive overhead, and maintaining consistent performance across runs.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Ensuring Kernel Correctness&lt;/p&gt;

    &lt;p&gt;Ensuring kernel correctness across different quantization and configuration settings is essential. Triton’s &lt;a href=&quot;https://triton-lang.org/main/python-api/generated/triton.autotune.html&quot;&gt;early configuration pruning&lt;/a&gt; plays a key role in this process. For example, during Split-K tuning, configurations are selected only if K is divisible by BLOCK_SIZE_K × SPLIT_K,, and BLOCKS_SIZE_K  is further pruned based on the group-size value. This approach ensures both efficiency and correctness in kernel operation.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Overcoming Bit-Unpacking Bottlenecks&lt;/p&gt;

    &lt;p&gt;When deploying on data center-grade GPUs like NVIDIA’s A100 and H100, performance bottlenecks related to bit-unpacking were observed. To mitigate these, various bit-packing configurations were explored, including packing along columns versus rows and experimenting with different bit-packing widths (e.g., 8-bit vs. 32-bit). Notably, transitioning from 32-bit to 8-bit packing delivered performance improvements of up to 18% on the A100 and 6% on the H100&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;torch.compile compatibility&lt;/p&gt;

    &lt;p&gt;To ensure seamless compatibility with PyTorch’s torch.compile, kernel calls are wrapped in a &lt;a href=&quot;https://pytorch.org/tutorials/advanced/python_custom_ops.html&quot;&gt;custom_op&lt;/a&gt;. This integration allows advanced features such as pre-hooks and early configuration pruning to function correctly, delivering accurate results without sacrificing performance. While some of these &lt;a href=&quot;https://github.com/pytorch/pytorch/issues/139059&quot;&gt;features&lt;/a&gt; are not yet fully supported in PyTorch, the custom_op implementation effectively bridges the gap, ensuring smooth integration and high performance.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-torchao&quot;&gt;3. TorchAO&lt;/h2&gt;

&lt;p&gt;TorchAO is a PyTorch native quantization and sparsity library for both training and inference, featuring simple user APIs to train, quantize and deploy low precision models, and composability with other PyTorch features like distributed inference and torch.compile.&lt;/p&gt;

&lt;p&gt;PyTorch does not support low precision dtypes or different packing formats by default. With Tensor Subclass, we extend PyTorch native Tensor abstractions and model quantization as dtype conversion, while different packing formats for custom kernels are handled through layouts. For example, we support quantized linear operations with int4 weights, packed in a Tensor Core friendly layout, with tinygemm or GemLite kernel implementations. More details can be found &lt;a href=&quot;https://pytorch.org/ao/stable/contributor_guide.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/accelerating-llm-inference/fg1.png&quot; alt=&quot;flow diagram&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Apart from more PyTorch native abstractions for developers, we want to highlight two benefits of this design for modeling users.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://pytorch.org/ao/stable/serialization.html&quot;&gt;Serialization&lt;/a&gt;: Save and load quantized weights into a state_dict just like a floating point model, eliminating the need to transform floating point model to quantized model before the quantized weights are loaded. This reduces friction of distributing and deploying quantized models.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;#torch-tensor-parallel&quot;&gt;Composability&lt;/a&gt;: Seamless integration with downstream features like tensor parallel, allowing users to focus on modeling without worrying about compatibility with tensor parallel, torch.compile, and other PyTorch features. Since these features are implemented with Tensor level abstraction, users can quantize and do distributed inference with no model changes most of the time.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;gemlite-kernel-integration&quot;&gt;GemLite Kernel Integration&lt;/h3&gt;

&lt;p&gt;To achieve the aforementioned benefits for the GemLite kernel, we integrated GemLite into TorchAO. This integration takes advantage of GemLite’s wide support and flexibility to allow for weight only quantization at 4 and 8 bits, under asymmetric and symmetric quantization schemes, 32 and 8 bit packing sizes, as well as grouped and ungrouped quantization. We enable this integration via the  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;quantize_&lt;/code&gt; api which can be used alongside the GemLite constructor as follows&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;quantize_(model, gemlite_uintx_weight_only(group_size, bit_width, packing_bitwidth))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The primary difficulty in creating this integration was making sure that the TorchAO composability guarantees were satisfied for the entire breadth of GemLite quantization kernel options. While the primary integration was relatively straight forward, making sure every different quantization type and their associated kernels worked well with tensor parallel was non-trivial.&lt;/p&gt;

&lt;h3 id=&quot;torch-tensor-parallel&quot;&gt;Torch Tensor Parallel&lt;/h3&gt;

&lt;p&gt;Tensor Parallelism is an effective way to speed up LLM inference. TP shards large matrices of linear or embedding modules onto multiple devices, typically in column-wise or row-wise styles. As the weight matrix gets distributed, computation is decomposed too. For example, the column-wise pattern below enables simultaneous matrix-vector multiply on four devices:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/accelerating-llm-inference/fg5.jpg&quot; alt=&quot;equation&quot; style=&quot;max-width:300px; width:100%; display: block; margin-left: auto; margin-right: auto&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PyTorch implements TP by converting a regular tensor (e.g. matrix &lt;em&gt;A&lt;/em&gt;) into a &lt;em&gt;DTensor&lt;/em&gt;:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dtensor = _shard_tensor(mA, device_mesh, (Shard(0),))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Since DTensor stores meta information about the sharding, it knows how to reconstruct the full result when needed. Take Transformers’ feedforward module for example, as the down projection and up projection use column-wise and row-wise sharding respectively, DTensor will automatically perform an all-reduce on the ranks’ results as they move into the next operation. Such automation allows model authors to focus on computation without worrying about the communication needed for distributed execution.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tensor Parallel and Quantization Order&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Since both DTensor and quantization are tensor-level transformations, the application order matters in ensuring a workflow can generally work on different setups. We have two observations: (i) checkpoints are typically saved in quantized formats, to save the quantization overhead before each run; and (ii) TP may run on a different number of devices, depending on resource constraints or service agreements. As such, we first apply quantization to the original tensor, save it to disk depending on whether a reuse is desired. At service launch time, we load the quantized checkpoint and shard the tensors into DTensors on-the-fly as we load them into the model.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tensor Parallel Support in TorchAO&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Since we quantize the model first then distribute the Tensor, we’ll have &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DTensor(QuantizedTensor(weight))&lt;/code&gt;, where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DTensor&lt;/code&gt; means a distributed Tensor class and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QuantizedTensor&lt;/code&gt; means a quantized tensor class in TorchAO. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QuantizedTensor&lt;/code&gt; should support the operators called when constructing a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DTensor&lt;/code&gt;, including slice and view ops. To make sure the overall execution is efficient, the packed weight that’s sliced in the dimension 0 and 1 should match the result of first slice the unpacked weight then pack (pack and slice operation should commute), otherwise the packing format is not compatible with tensor parallelism.&lt;/p&gt;

&lt;h2 id=&quot;4-sglang&quot;&gt;4. SGLang&lt;/h2&gt;

&lt;p&gt;SGLang is a fast serving framework for large language models and vision language models. It is known for its almost &lt;a href=&quot;https://lmsys.org/blog/2024-12-04-sglang-v0-4/&quot;&gt;zero-overhead batch scheduler&lt;/a&gt; and fast &lt;a href=&quot;https://lmsys.org/blog/2024-02-05-compressed-fsm/&quot;&gt;constrained decoding&lt;/a&gt;. It is mainly implemented in Python, lightweight, and easy to hack. It is also one of the first frameworks to integrate torch.compile.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TorchAO integration in SGLang&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We integrated &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;quantize_&lt;/code&gt; API for applying a specific type of quantization to model into SGLang that supports int4 weight only quantization (both tinygemm and GemLite version), float8 dynamic quantization and a few other types of quantization so far. Users can enable quantization by adding &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--torchao-config&lt;/code&gt; argument to the benchmarking script. The currently enabled options also support tensor parallelism through composition with DTensor that is enabled with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--tp-size&lt;/code&gt; option.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Torch Native Tensor Parallel Support in SGLang&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Existing model definitions in SGLang use special linear modules that are coupled with tensor parallelism style, for example: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MergedColumnParallelLinear&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QKVParallelLinear&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RowParallelLinear&lt;/code&gt;. To decouple the model definition and tensor parallelization style, we defined a &lt;a href=&quot;https://github.com/sgl-project/sglang/blob/main/python/sglang/srt/models/torch_native_llama.py&quot;&gt;pytorch native model&lt;/a&gt; that uses plain &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nn.Linear&lt;/code&gt; module from PyTorch and rely on PyTorch tensor parallelism APIs for parallelization and torch.compile for speedup. At related module hierarchies, we add a dictionary describing how a submodule should be parallelized. For example, in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;class LlamaAttention&lt;/code&gt;, we define:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;_tp_plan = {
    &quot;qkv_proj&quot;: &quot;Colwise_Sharded&quot;,
    &quot;o_proj&quot;: &quot;Rowwise&quot;,
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;qkv_proj&quot; &lt;/code&gt;and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;o_proj&quot; &lt;/code&gt;are the FQNs of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wqkv&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wo&lt;/code&gt; projections, and the values are their TP styles.&lt;/p&gt;

&lt;p&gt;We then define a TP engine in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;model_parallel.py&lt;/code&gt;. It searches for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_tp_plan &lt;/code&gt;recursively within the model, and applies the indicated TP styles to the submodules using PyTorch’s &lt;a href=&quot;https://pytorch.org/docs/stable/distributed.tensor.parallel.html#torch.distributed.tensor.parallel.parallelize_module&quot;&gt;parallelize_module&lt;/a&gt; API.&lt;/p&gt;

&lt;h2 id=&quot;5-results&quot;&gt;5. Results&lt;/h2&gt;

&lt;p&gt;The evaluation focused on two popular quantization techniques for H100 machines: int4 weight-only quantization and float8 dynamic quantization. These methods were chosen due to their widespread use in optimizing memory efficiency and computational performance on H100 machines, making them ideal candidates for benchmarking against various workloads.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;int4 Weight-Only Quantization&lt;/strong&gt;: This method significantly reduces memory footprint and accelerates decode for memory-bound workloads, with minimal impact on performance in compute-intensive scenarios like prefill or larger batch sizes. We present results for bf16, GemLite, and tinygemm kernels below, across various batch sizes and tensor parallel configurations&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;float8 Dynamic Quantization&lt;/strong&gt;: While offering less memory savings, this method often provides higher accuracy and balanced speedups for both memory-bound and compute-bound tasks. With Hopper-grade hardware and native fp8 support, the efficient cutlass/cuBLAS kernels used by AO contribute to a significant speedup&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The graphs below show the decode tokens/sec for different tp sizes, each graph shows the results across different batch sizes and for different types of quantization:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;BF16 is our bfloat16, torch.compile’d baseline&lt;/li&gt;
  &lt;li&gt;tinygemm-4-64 is using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int4_weight_only&lt;/code&gt; quantization in TorchAO, it’s a 4 bit groupwise quantization with group size of 64, using tinygemm kernel&lt;/li&gt;
  &lt;li&gt;gemlite-4-64 is using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gemlite_uintx_weight_only &lt;/code&gt;quantization in TorchAO, 4 means 4 bit, and 64 is also the group size, using GemLite kernel&lt;/li&gt;
  &lt;li&gt;fp8dq-per_row is using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;float8_dynamic_activation_float8_weight&lt;/code&gt; quantization in TorchAO, both activation and weights are quantized with per row scales&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/accelerating-llm-inference/fg2.png&quot; alt=&quot;bar chart&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/accelerating-llm-inference/fg3.png&quot; alt=&quot;bar chart&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/accelerating-llm-inference/fg4.png&quot; alt=&quot;bar chart&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;For int4 weight-only quantization, at batch size 1, the tinygemm kernel achieved the best performance. However, its efficiency declined with increasing batch sizes. Conversely, GemLite effectively bridged this gap, delivering superior performance at larger batch sizes. GemLite also achieved a 9–10x speedup during the prefill phase compared to tinygemm, despite ongoing performance optimizations constrained by Triton.&lt;/p&gt;

&lt;p&gt;Float8 dynamic quantization showed 1.3x speedup over bfloat16 consistently with tensor parallel size 1 across different batch sizes and 1.1x to 1.2x speedup in larger tensor parallel sizes. As the tensor parallel size increases, the overall speedup decreases, which is expected due to the reduction in matmul size. Note that we do expect to get speedup for prefill as well, but since we rely on torch.compile for speedup and prefill compile is not enabled in SGLang yet, we will leave this for future work.&lt;/p&gt;

&lt;h3 id=&quot;repro-instructions&quot;&gt;Repro Instructions&lt;/h3&gt;

&lt;p&gt;We conducted benchmarks on an 8xH100 machine using GemLite 0.4.1, SGLang built from commit feb2b76, TorchAO nightly 0.8.0.dev20241223+cu124, and PyTorch 2.5.1. The Llama-3.1 Instruct models were chosen as the architecture for evaluation.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;BATCH_SIZE=16
# Note: gemlite is only compatible with float16
# while int4wo-64 (tinygemm-4-64 as shown in the graph) and fp8dq-per_row should use bfloat16
DTYPE=float16
# int4wo-64, fp8dq-per_tensor
TORCHAO_CONFIG=gemlite-4-64
TP_SIZE=2
# Decode performance
python3 -m sglang.bench_offline_throughput --model-path meta-llama/Llama-3.1-8B-Instruct --json-model-override-args '{&quot;architectures&quot;: [&quot;TorchNativeLlamaForCausalLM&quot;]}' --dataset-name random --random-input 1024 --random-output 512 --random-range 1 --num-prompts $BATCH_SIZE --enable-torch-compile --dtype $DTYPE --torchao-config $TORCHAO_CONFIG --tp-size $TP_SIZE

# Example output
# Benchmark...
# [2024-12-20 12:42:16 TP0] Prefill batch. #new-seq: 2, #new-token: 2046, #cached-token: 4, cache hit rate: \0.06%, token usage: 0.00, #running-req: 0, #queue-req: 0
# ...
# [2024-12-20 12:45:35 TP0] Decode batch. #running-req: 16, #token: 16763, token usage: 0.01, gen throughput\ (token/s): 2.20, #queue-req: 0
# [2024-12-20 12:45:38 TP0] Decode batch. #running-req: 16, #token: 24443, token usage: 0.02, gen throughput\ (token/s): 2739.89, #queue-req: 0

# We reported the last throughput (token/s) as the performance for decode
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;With performant and extensible kernels from &lt;a href=&quot;https://github.com/mobiusml/gemlite&quot;&gt;GemLite&lt;/a&gt;, PyTorch native architecture optimization library &lt;a href=&quot;https://github.com/pytorch/ao&quot;&gt;TorchAO&lt;/a&gt; and high performance inference framework &lt;a href=&quot;https://github.com/sgl-project/sglang&quot;&gt;SGLang&lt;/a&gt;, we showcased fast end-to-end quantized inference for both int4 and float8 across different batch sizes and tensor parallel sizes with simple and composable user APIs to reduce the resource requirement for LLMs. This integration is our first step towards meeting the needs of fast inference across different models, workloads, precisions and hardwares and we are looking forward to continuing advancing the state of the art for end to end mixed and low precision LLM inference.&lt;/p&gt;

&lt;p&gt;Our immediate future work focuses on the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Exploring diverse combinations of weight and activation quantization to strike the best balance between speed and accuracy&lt;/li&gt;
  &lt;li&gt;Extending support to additional GPU architectures to broaden accessibility&lt;/li&gt;
  &lt;li&gt;Enhancing compatibility with MoE models to address growing demands in scalable inference&lt;/li&gt;
  &lt;li&gt;Allow for easy integration of fast custom kernels in TorchAO so that they can be easily leveraged by SGLang and other inference frameworks&lt;/li&gt;
  &lt;li&gt;While we didn’t measure accuracy impact in this blogpost, we can develop auto quantization tool in TorchAO to allow users to trade off between performance and accuracy&lt;/li&gt;
  &lt;li&gt;Better integration with tensor parallelism in SGLang to support running larger models&lt;/li&gt;
  &lt;li&gt;Enable torch.compile for prefill phase in SGLang&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We also invite the community to actively test, provide feedback, and contribute to shaping the future of fast and efficient LLM inference.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Teams at PyTorch, Mobius Labs and SGLang</name>
        
        
      </author>

      

      

      
        <summary type="html">Large Language Models (LLMs) are typically very resource-intensive, requiring significant amounts of memory, compute and power to operate effectively. Quantization provides a solution by reducing weights and activations from 16 bit floats to lower bitrates (e.g., 8 bit, 4 bit, 2 bit), achieving significant speedup and memory savings and also enables support for larger batch sizes.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">MLOps Workflow Simplified for PyTorch with Arm and GitHub Collaboration</title>
      <link href="https://pytorch.org/blog/mlops-workflow/" rel="alternate" type="text/html" title="MLOps Workflow Simplified for PyTorch with Arm and GitHub Collaboration" />
      <published>2025-01-15T00:00:00-08:00</published>
      <updated>2025-01-15T00:00:00-08:00</updated>
      <id>https://pytorch.org/blog/mlops-workflow</id>
      <content type="html" xml:base="https://pytorch.org/blog/mlops-workflow/">&lt;p&gt;PyTorch is one of the most widely used and most powerful deep learning frameworks for training and deploying complex neural networks. It has never been easier to train and deploy AI applications, and low-cost, high-performance, energy-efficient hardware, tools, and technology for creating optimized workflows are more accessible than ever.  But data science, machine learning, and devops can be deep topics unto themselves, and it can be overwhelming for developers with one specialty to see how they all come together in the real world, or even to know where to get started.&lt;/p&gt;

&lt;p&gt;To that end, we at Arm have collaborated with our friends at GitHub to decompose the basic elements of real world MLOps pipelines that use PyTorch models and create a simplified workflow and MLOps tutorial that anyone with a GitHub and a Docker Hub account can leverage.&lt;/p&gt;

&lt;h2 id=&quot;mlops-overview&quot;&gt;MLOps Overview&lt;/h2&gt;

&lt;p&gt;The software development lifecycle for machine learning applications typically starts from training data, which is used to train sophisticated neural networks (NNs) that are optimized, integrated into software images, and then deployed onto compute clusters and even fleets of devices in the field.  These devices are typically continuously collecting data and are managed by cloud services, which actively monitor performance of the ML algorithm(s) and feedback data for retraining in the next iteration of the lifecycle – enabling continuous improvement of the algorithms, as well as supporting deployment of new AI features.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mlops-workflow/fg1.png&quot; alt=&quot;process flow chart&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example of a typical ML software development lifecycle.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Scott Arbeit from GitHub recently published an &lt;a href=&quot;https://github.blog/enterprise-software/ci-cd/streamlining-your-mlops-pipeline-with-github-actions-and-arm64-runners/&quot;&gt;excellent blog&lt;/a&gt; that highlights the importance of MLOps in machine learning and describes automation via simplified GitHub actions for several key tasks including:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Data preprocessing&lt;/strong&gt;: cleaning and preparation of data for training.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Model training and validation&lt;/strong&gt;: automatic execution of training scripts when new data is pushed or when changes are made to the model code.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Deployment&lt;/strong&gt;: automatic packaging and deployment of models to production environments upon successful training and validation.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Monitoring and alerts:&lt;/strong&gt; workflows to monitor model performance and send alerts if certain thresholds are breached.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The article also describes a conceptual efficient MLOps pipeline that takes advantage of new, low-cost Arm Runners natively integrated into GitHub Actions to train and validate PyTorch models. It also uses containerization for consistent deployment across different environments.&lt;/p&gt;

&lt;p&gt;Our team at Arm put GitHub’s ideas and conceptual workflow into practice and created a tutorial to help you get started today.&lt;/p&gt;

&lt;h2 id=&quot;optimizing-your-pytorch-mlops-workflow&quot;&gt;Optimizing Your PyTorch MLOps Workflow&lt;/h2&gt;

&lt;p&gt;A new &lt;a href=&quot;https://learn.arm.com/&quot;&gt;Arm Learning Path&lt;/a&gt; unpacks each of the key phases described in Scott’s blog, and demonstrates each key task in detail, providing prescriptive instructions and code examples to leverage several aspects of the PyTorch framework to implement each phase.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mlops-workflow/fg2.png&quot; alt=&quot;process flow chart&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Key ML tasks to setup and automate with GitHub Actions.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;With this learning path you will be able to take advantage of the following strategies with a real-world object detection use case to make your own streamlined MLOps workflow:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Containerization:&lt;/strong&gt; Package your PyTorch model and its dependencies into a Docker container to help ensure consistent performance across different environments.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Efficient Data Loading:&lt;/strong&gt; Optimize data loading pipelines to help minimize I/O bottlenecks and maximize GPU utilization.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Model Optimization:&lt;/strong&gt; Explore techniques like model quantization, pruning, and knowledge distillation to help reduce model size and improve inference speed.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Leverage PyTorch’s Ecosystem:&lt;/strong&gt; Utilize libraries like TorchVision to help streamline common deep learning tasks.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Monitor and Profile:&lt;/strong&gt; Monitor resource utilization and identify potential bottlenecks to further optimize your workflow.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;an-end-to-end-mlops-workflow&quot;&gt;An End-to-End MLOps Workflow&lt;/h2&gt;

&lt;p&gt;The best part of this learning path is not just that it takes you through each task in detail, but it brings it all together into a unified automated workflow.&lt;/p&gt;

&lt;p&gt;With GitHub Actions, you can build an end-to-end custom MLOPs workflow that combines and automates the individual workflows for each ML task.  To demonstrate this, the repository contains a workflow in a boilerplate .yml file that automates the individual steps.&lt;/p&gt;

&lt;p&gt;You can run an MLOps workflow using GitHub Actions natively for managing all the steps in your ML application’s lifecycle.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mlops-workflow/fg3.png&quot; alt=&quot;process flow chart&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A successful run of this MLOps workflow in GitHub Actions.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;try-it-yourself&quot;&gt;Try It Yourself!&lt;/h2&gt;

&lt;p&gt;Our Arm team has battle-tested this tutorial in the field and delivered the tutorial as a workshop at GitHub Universe 2024 earlier this year.  Now it’s time for you to take it for a spin and get hands-on with PyTorch and MLOps.&lt;/p&gt;

&lt;p&gt;Try the Arm Learning Path &lt;a href=&quot;https://learn.arm.com/learning-paths/servers-and-cloud-computing/gh-runners/&quot;&gt;Here&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;By the end of this tutorial, you can:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Set up a new GitHub Arm-runner to natively build an arm64 image to take advantage of the lowest-cost, most power efficient compute available.&lt;/li&gt;
  &lt;li&gt;Train and test a PyTorch ML model with the German Traffic Sign Recognition Benchmark (GTSRB) dataset.&lt;/li&gt;
  &lt;li&gt;Compare the performance of two trained PyTorch ML models; one model compiled with OpenBLAS (Open Basic Linear Algebra Subprograms Library) and oneDNN (Deep Neural Network Library), and the other model compiled with Arm Compute Library (ACL).&lt;/li&gt;
  &lt;li&gt;Containerize a ML model and push the container to DockerHub.&lt;/li&gt;
  &lt;li&gt;Automate each task into a single MLOps pipeline Using GitHub Actions.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Combining the power of PyTorch with the simplicity of GitHub Actions and the efficiency of native Arm Runners significantly helps you accelerate your deep learning development and deployment processes. Following the best practices outlined in this blog post helps you achieve optimal performance and cost-effectiveness for your PyTorch projects.&lt;/p&gt;

&lt;p&gt;We’d love to see what you create based on this example.  If you have created your own Arm Learning Path, you are invited to &lt;a href=&quot;https://learn.arm.com/learning-paths/cross-platform/_example-learning-path/&quot;&gt;share it here&lt;/a&gt;.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Eric Sondhi, Arm</name>
        
        
      </author>

      

      

      
        <summary type="html">PyTorch is one of the most widely used and most powerful deep learning frameworks for training and deploying complex neural networks. It has never been easier to train and deploy AI applications, and low-cost, high-performance, energy-efficient hardware, tools, and technology for creating optimized workflows are more accessible than ever. But data science, machine learning, and devops can be deep topics unto themselves, and it can be overwhelming for developers with one specialty to see how they all come together in the real world, or even to know where to get started.</summary>
      

      
      
    </entry>
  
</feed>


