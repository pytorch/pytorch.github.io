


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>torch.sparse &mdash; PyTorch main documentation</title>
  

  
  
  
  
    <link rel="canonical" href="https://pytorch.org/docs/stable/sparse.html"/>
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!-- <link rel="stylesheet" href="_static/pygments.css" type="text/css" /> -->
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/copybutton.css" type="text/css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-beta/dist/katex.min.css" type="text/css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" type="text/css" />
  <link rel="stylesheet" href="_static/katex-math.css" type="text/css" />
  <link rel="stylesheet" href="_static/sphinx-dropdown.css" type="text/css" />
  <link rel="stylesheet" href="_static/panels-bootstrap.min.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/jit.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="torch.Tensor.is_sparse_csr" href="generated/torch.Tensor.is_sparse_csr.html" />
    <link rel="prev" title="torch.nested" href="nested.html" />

<!--
  Search engines should not index the main version of documentation.
  Stable documentation are built without release == 'main'.
-->
<meta name="robots" content="noindex">


  <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-T8XT4PS');</script>
    <!-- End Google Tag Manager -->
  


  
  <script src="_static/js/modernizr.min.js"></script>

  <!-- Preload the theme fonts -->

<link rel="preload" href="_static/fonts/FreightSans/freight-sans-book.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="_static/fonts/FreightSans/freight-sans-medium.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="_static/fonts/IBMPlexMono/IBMPlexMono-Medium.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="_static/fonts/FreightSans/freight-sans-bold.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="_static/fonts/FreightSans/freight-sans-medium-italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="_static/fonts/IBMPlexMono/IBMPlexMono-SemiBold.woff2" as="font" type="font/woff2" crossorigin="anonymous">

<!-- Preload the katex fonts -->

<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Math-Italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Main-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Main-Bold.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size1-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size4-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size2-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size3-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Caligraphic-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css" integrity="sha384-vSIIfh2YWi9wW0r9iZe7RJPrKwp6bG+s9QZMoITbCckVJqGCCRhc+ccxNcdpHuYu" crossorigin="anonymous">
</head>

<div class="container-fluid header-holder tutorials-header" id="header-holder">
  <div class="container">
    <div class="header-container">
      <a class="header-logo" href="https://pytorch.org/" aria-label="PyTorch"></a>

      <div class="main-menu">
        <ul>
          <li>
            <a href="https://pytorch.org/get-started">Get Started</a>
          </li>

          <li>
            <a href="https://pytorch.org/ecosystem">Ecosystem</a>
          </li>

          <li>
            <a href="https://pytorch.org/mobile">Mobile</a>
          </li>

          <li>
            <a href="https://pytorch.org/blog/">Blog</a>
          </li>

          <li>
            <a href="https://pytorch.org/tutorials">Tutorials</a>
          </li>

          <li class="active docs-active">
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="resource-option with-down-orange-arrow">
                Docs
              </a>
              <div class="resources-dropdown-menu">
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/docs/stable/index.html">
                  <span class="dropdown-title">PyTorch</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/audio/stable/index.html">
                  <span class="dropdown-title">torchaudio</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/text/stable/index.html">
                  <span class="dropdown-title">torchtext</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/vision/stable/index.html">
                  <span class="dropdown-title">torchvision</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/torcharrow">
                  <span class="dropdown-title">torcharrow</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/data">
                  <span class="dropdown-title">TorchData</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/torchrec">
                  <span class="dropdown-title">TorchRec</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/serve/">
                  <span class="dropdown-title">TorchServe</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/torchx/">
                  <span class="dropdown-title">TorchX</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/xla">
                  <span class="dropdown-title">PyTorch on XLA Devices</span>
                  <p></p>
                </a>
            </div>
          </li>

          <li>
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="resource-option with-down-arrow">
                Resources
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="https://pytorch.org/features">
                  <span class="dropdown-title">About</span>
                  <p>Learn about PyTorch’s features and capabilities</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/foundation">
                  <span class="dropdown-title">PyTorch Foundation</span>
                  <p>Learn about the PyTorch foundation</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/#community-module">
                  <span class="dropdown-title">Community</span>
                  <p>Join the PyTorch developer community to contribute, learn, and get your questions answered.</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/community-stories">
                  <span class="dropdown-title">Community Stories</span>
                  <p>Learn how our community solves real, everyday machine learning problems with PyTorch.</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/resources">
                  <span class="dropdown-title">Developer Resources</span>
                  <p>Find resources and get questions answered</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/events">
                  <span class="dropdown-title">Events</span>
                  <p>Find events, webinars, and podcasts</p>
                </a>
                <a class="nav-dropdown-item" href="https://discuss.pytorch.org/" target="_blank">
                  <span class="dropdown-title">Forums</span>
                  <p>A place to discuss PyTorch code, issues, install, research</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/hub">
                  <span class="dropdown-title">Models (Beta)</span>
                  <p>Discover, publish, and reuse pre-trained models</p>
                </a>
              </div>
            </div>
          </li>

          <li>
            <a href="https://github.com/pytorch/pytorch">GitHub</a>
          </li>
        </ul>
      </div>

      <a class="main-menu-open-button" href="#" data-behavior="open-mobile-menu"></a>
    </div>
  </div>
</div>

<body class="pytorch-body">

   

    

    <div class="table-of-contents-link-wrapper">
      <span>Table of Contents</span>
      <a href="#" class="toggle-table-of-contents" data-behavior="toggle-table-of-contents"></a>
    </div>

    <nav data-toggle="wy-nav-shift" class="pytorch-left-menu" id="pytorch-left-menu">
      <div class="pytorch-side-scroll">
        <div class="pytorch-menu pytorch-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          <div class="pytorch-left-menu-search">
            
    <div class="version">
      <a href='https://pytorch.org/docs/versions.html'>main (2.1.0a0+git707d265 ) &#x25BC</a>
    </div>
    


  


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search Docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          </div>

          

<div>
  <a style="color:#F05732" href="https://pytorch.org/docs/stable/sparse.html">
    You are viewing unstable developer preview docs.
    Click here to view docs for latest stable release.
  </a>
</div>


            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Community</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="community/build_ci_governance.html">PyTorch Governance | Build + CI</a></li>
<li class="toctree-l1"><a class="reference internal" href="community/contribution_guide.html">PyTorch Contribution Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="community/design.html">PyTorch Design Philosophy</a></li>
<li class="toctree-l1"><a class="reference internal" href="community/governance.html">PyTorch Governance | Mechanics</a></li>
<li class="toctree-l1"><a class="reference internal" href="community/persons_of_interest.html">PyTorch Governance | Maintainers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="notes/amp_examples.html">CUDA Automatic Mixed Precision examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="notes/autograd.html">Autograd mechanics</a></li>
<li class="toctree-l1"><a class="reference internal" href="notes/broadcasting.html">Broadcasting semantics</a></li>
<li class="toctree-l1"><a class="reference internal" href="notes/cpu_threading_torchscript_inference.html">CPU threading and TorchScript inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="notes/cuda.html">CUDA semantics</a></li>
<li class="toctree-l1"><a class="reference internal" href="notes/ddp.html">Distributed Data Parallel</a></li>
<li class="toctree-l1"><a class="reference internal" href="notes/extending.html">Extending PyTorch</a></li>
<li class="toctree-l1"><a class="reference internal" href="notes/extending.func.html">Extending torch.func with autograd.Function</a></li>
<li class="toctree-l1"><a class="reference internal" href="notes/faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="notes/gradcheck.html">Gradcheck mechanics</a></li>
<li class="toctree-l1"><a class="reference internal" href="notes/hip.html">HIP (ROCm) semantics</a></li>
<li class="toctree-l1"><a class="reference internal" href="notes/large_scale_deployments.html">Features for large-scale deployments</a></li>
<li class="toctree-l1"><a class="reference internal" href="notes/modules.html">Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="notes/mps.html">MPS backend</a></li>
<li class="toctree-l1"><a class="reference internal" href="notes/multiprocessing.html">Multiprocessing best practices</a></li>
<li class="toctree-l1"><a class="reference internal" href="notes/numerical_accuracy.html">Numerical accuracy</a></li>
<li class="toctree-l1"><a class="reference internal" href="notes/randomness.html">Reproducibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="notes/serialization.html">Serialization semantics</a></li>
<li class="toctree-l1"><a class="reference internal" href="notes/windows.html">Windows FAQ</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">torch.compile</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="compile/index.html">torch.compile</a></li>
<li class="toctree-l1"><a class="reference internal" href="compile/get-started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="compile/troubleshooting.html">PyTorch 2.0 Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="compile/faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="compile/technical-overview.html">Technical Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="compile/guards-overview.html">Guards Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="compile/custom-backends.html">Custom Backends</a></li>
<li class="toctree-l1"><a class="reference internal" href="compile/fine_grained_apis.html">TorchDynamo APIs to control fine-grained tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="compile/profiling_torch_compile.html">Profiling to understand torch.compile performance</a></li>
<li class="toctree-l1"><a class="reference internal" href="compile/inductor_profiling.html">TorchInductor GPU Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="compile/deep-dive.html">TorchDynamo Deeper Dive</a></li>
<li class="toctree-l1"><a class="reference internal" href="compile/cudagraph_trees.html">CUDAGraph Trees</a></li>
<li class="toctree-l1"><a class="reference internal" href="compile/performance-dashboard.html">PyTorch 2.0 Performance Dashboard</a></li>
<li class="toctree-l1"><a class="reference internal" href="compile/torchfunc-and-torchcompile.html">torch.func interaction with torch.compile</a></li>
<li class="toctree-l1"><a class="reference internal" href="ir.html">IRs</a></li>
<li class="toctree-l1"><a class="reference internal" href="compile/dynamic-shapes.html">Dynamic shapes</a></li>
<li class="toctree-l1"><a class="reference internal" href="compile/fake-tensor.html">Fake tensor</a></li>
<li class="toctree-l1"><a class="reference internal" href="logging.html">torch._logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="compile/transformations.html">Writing Graph Transformations on ATen IR</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Language Bindings</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="cpp_index.html">C++</a></li>
<li class="toctree-l1"><a class="reference external" href="https://pytorch.org/javadoc/">Javadoc</a></li>
<li class="toctree-l1"><a class="reference internal" href="deploy.html">torch::deploy</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Python API</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="torch.html">torch</a></li>
<li class="toctree-l1"><a class="reference internal" href="nn.html">torch.nn</a></li>
<li class="toctree-l1"><a class="reference internal" href="nn.functional.html">torch.nn.functional</a></li>
<li class="toctree-l1"><a class="reference internal" href="tensors.html">torch.Tensor</a></li>
<li class="toctree-l1"><a class="reference internal" href="tensor_attributes.html">Tensor Attributes</a></li>
<li class="toctree-l1"><a class="reference internal" href="tensor_view.html">Tensor Views</a></li>
<li class="toctree-l1"><a class="reference internal" href="amp.html">torch.amp</a></li>
<li class="toctree-l1"><a class="reference internal" href="autograd.html">torch.autograd</a></li>
<li class="toctree-l1"><a class="reference internal" href="library.html">torch.library</a></li>
<li class="toctree-l1"><a class="reference internal" href="cuda.html">torch.cuda</a></li>
<li class="toctree-l1"><a class="reference internal" href="mps.html">torch.mps</a></li>
<li class="toctree-l1"><a class="reference internal" href="backends.html">torch.backends</a></li>
<li class="toctree-l1"><a class="reference internal" href="export.html">torch._export.export</a></li>
<li class="toctree-l1"><a class="reference internal" href="distributed.html">torch.distributed</a></li>
<li class="toctree-l1"><a class="reference internal" href="distributed.algorithms.join.html">torch.distributed.algorithms.join</a></li>
<li class="toctree-l1"><a class="reference internal" href="distributed.elastic.html">torch.distributed.elastic</a></li>
<li class="toctree-l1"><a class="reference internal" href="fsdp.html">torch.distributed.fsdp</a></li>
<li class="toctree-l1"><a class="reference internal" href="distributed.optim.html">torch.distributed.optim</a></li>
<li class="toctree-l1"><a class="reference internal" href="distributed.tensor.parallel.html">torch.distributed.tensor.parallel</a></li>
<li class="toctree-l1"><a class="reference internal" href="distributed.checkpoint.html">torch.distributed.checkpoint</a></li>
<li class="toctree-l1"><a class="reference internal" href="distributions.html">torch.distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="compiler.html">torch.compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="fft.html">torch.fft</a></li>
<li class="toctree-l1"><a class="reference internal" href="func.html">torch.func</a></li>
<li class="toctree-l1"><a class="reference internal" href="futures.html">torch.futures</a></li>
<li class="toctree-l1"><a class="reference internal" href="fx.html">torch.fx</a></li>
<li class="toctree-l1"><a class="reference internal" href="hub.html">torch.hub</a></li>
<li class="toctree-l1"><a class="reference internal" href="jit.html">torch.jit</a></li>
<li class="toctree-l1"><a class="reference internal" href="linalg.html">torch.linalg</a></li>
<li class="toctree-l1"><a class="reference internal" href="monitor.html">torch.monitor</a></li>
<li class="toctree-l1"><a class="reference internal" href="signal.html">torch.signal</a></li>
<li class="toctree-l1"><a class="reference internal" href="special.html">torch.special</a></li>
<li class="toctree-l1"><a class="reference internal" href="torch.overrides.html">torch.overrides</a></li>
<li class="toctree-l1"><a class="reference internal" href="package.html">torch.package</a></li>
<li class="toctree-l1"><a class="reference internal" href="profiler.html">torch.profiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="nn.init.html">torch.nn.init</a></li>
<li class="toctree-l1"><a class="reference internal" href="onnx.html">torch.onnx</a></li>
<li class="toctree-l1"><a class="reference internal" href="onnx_diagnostics.html">torch.onnx diagnostics</a></li>
<li class="toctree-l1"><a class="reference internal" href="optim.html">torch.optim</a></li>
<li class="toctree-l1"><a class="reference internal" href="complex_numbers.html">Complex Numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ddp_comm_hooks.html">DDP Communication Hooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="pipeline.html">Pipeline Parallelism</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantization.html">Quantization</a></li>
<li class="toctree-l1"><a class="reference internal" href="rpc.html">Distributed RPC Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="random.html">torch.random</a></li>
<li class="toctree-l1"><a class="reference internal" href="masked.html">torch.masked</a></li>
<li class="toctree-l1"><a class="reference internal" href="nested.html">torch.nested</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">torch.sparse</a></li>
<li class="toctree-l1"><a class="reference internal" href="storage.html">torch.Storage</a></li>
<li class="toctree-l1"><a class="reference internal" href="testing.html">torch.testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="benchmark_utils.html">torch.utils.benchmark</a></li>
<li class="toctree-l1"><a class="reference internal" href="bottleneck.html">torch.utils.bottleneck</a></li>
<li class="toctree-l1"><a class="reference internal" href="checkpoint.html">torch.utils.checkpoint</a></li>
<li class="toctree-l1"><a class="reference internal" href="cpp_extension.html">torch.utils.cpp_extension</a></li>
<li class="toctree-l1"><a class="reference internal" href="data.html">torch.utils.data</a></li>
<li class="toctree-l1"><a class="reference internal" href="jit_utils.html">torch.utils.jit</a></li>
<li class="toctree-l1"><a class="reference internal" href="dlpack.html">torch.utils.dlpack</a></li>
<li class="toctree-l1"><a class="reference internal" href="mobile_optimizer.html">torch.utils.mobile_optimizer</a></li>
<li class="toctree-l1"><a class="reference internal" href="model_zoo.html">torch.utils.model_zoo</a></li>
<li class="toctree-l1"><a class="reference internal" href="tensorboard.html">torch.utils.tensorboard</a></li>
<li class="toctree-l1"><a class="reference internal" href="type_info.html">Type Info</a></li>
<li class="toctree-l1"><a class="reference internal" href="named_tensor.html">Named Tensors</a></li>
<li class="toctree-l1"><a class="reference internal" href="name_inference.html">Named Tensors operator coverage</a></li>
<li class="toctree-l1"><a class="reference internal" href="config_mod.html">torch.__config__</a></li>
<li class="toctree-l1"><a class="reference internal" href="logging.html">torch._logging</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Libraries</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://pytorch.org/audio/stable">torchaudio</a></li>
<li class="toctree-l1"><a class="reference external" href="https://pytorch.org/data">TorchData</a></li>
<li class="toctree-l1"><a class="reference external" href="https://pytorch.org/torchrec">TorchRec</a></li>
<li class="toctree-l1"><a class="reference external" href="https://pytorch.org/serve">TorchServe</a></li>
<li class="toctree-l1"><a class="reference external" href="https://pytorch.org/text/stable">torchtext</a></li>
<li class="toctree-l1"><a class="reference external" href="https://pytorch.org/vision/stable">torchvision</a></li>
<li class="toctree-l1"><a class="reference external" href="https://pytorch.org/xla/">PyTorch on XLA Devices</a></li>
</ul>

            
          

        </div>
      </div>
    </nav>

    <div class="pytorch-container">
      <div class="pytorch-page-level-bar" id="pytorch-page-level-bar">
        <div class="pytorch-breadcrumbs-wrapper">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="pytorch-breadcrumbs">
    
      <li>
        <a href="index.html">
          
            Docs
          
        </a> &gt;
      </li>

        
      <li>torch.sparse</li>
    
    
      <li class="pytorch-breadcrumbs-aside">
        
            
            <a href="_sources/sparse.rst.txt" rel="nofollow"><img src="_static/images/view-page-source-icon.svg"></a>
          
        
      </li>
    
  </ul>

  
</div>
        </div>

        <div class="pytorch-shortcuts-wrapper" id="pytorch-shortcuts-wrapper">
          Shortcuts
        </div>
      </div>

      <section data-toggle="wy-nav-shift" id="pytorch-content-wrap" class="pytorch-content-wrap">
        <div class="pytorch-content-left">

        

          <!-- Google Tag Manager (noscript) -->
          <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-T8XT4PS"
          height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
          <!-- End Google Tag Manager (noscript) -->
          
          <div class="rst-content">
          
            <div role="main" class="main-content" itemscope="itemscope" itemtype="http://schema.org/Article">
             <article itemprop="articleBody" id="pytorch-article" class="pytorch-article">
              
  <span class="target" id="module-torch.sparse"></span><div class="section" id="torch-sparse">
<span id="sparse-docs"></span><h1>torch.sparse<a class="headerlink" href="#torch-sparse" title="Permalink to this heading">¶</a></h1>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The PyTorch API of sparse tensors is in beta and may change in the near future.
We highly welcome feature requests, bug reports and general suggestions as GitHub issues.</p>
</div>
<div class="section" id="why-and-when-to-use-sparsity">
<h2>Why and when to use sparsity<a class="headerlink" href="#why-and-when-to-use-sparsity" title="Permalink to this heading">¶</a></h2>
<p>By default PyTorch stores <a class="reference internal" href="tensors.html#torch.Tensor" title="torch.Tensor"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a> stores elements contiguously
physical memory. This leads to efficient implementations of various array
processing algorithms that require fast access to elements.</p>
<p>Now, some users might decide to represent data such as graph adjacency
matrices, pruned weights or points clouds by Tensors whose <em>elements are
mostly zero valued</em>. We recognize these are important applications and aim
to provide performance optimizations for these use cases via sparse storage formats.</p>
<p>Various sparse storage formats such as COO, CSR/CSC, semi-structured, LIL, etc. have been
developed over the years. While they differ in exact layouts, they all
compress data through efficient representation of zero valued elements.
We call the uncompressed values <em>specified</em> in contrast to <em>unspecified</em>,
compressed elements.</p>
<p>By compressing repeat zeros sparse storage formats aim to save memory
and computational resources on various CPUs and GPUs. Especially for high
degrees of sparsity or highly structured sparsity this can have significant
performance implications. As such sparse storage formats can be seen as a
performance optimization.</p>
<p>Like many other performance optimization sparse storage formats are not
always advantageous. When trying sparse formats for your use case
you might find your execution time to increase rather than decrease.</p>
<p>Please feel encouraged to open a GitHub issue if you analytically
expected to see a stark increase in performance but measured a
degradation instead. This helps us prioritize the implementation
of efficient kernels and wider performance optimizations.</p>
<p>We make it easy to try different sparsity layouts, and convert between them,
without being opinionated on what’s best for your particular application.</p>
</div>
<div class="section" id="functionality-overview">
<h2>Functionality overview<a class="headerlink" href="#functionality-overview" title="Permalink to this heading">¶</a></h2>
<p>We want it to be straightforward to construct a sparse Tensor from a
given dense Tensor by providing conversion routines for each layout.</p>
<p>In the next example we convert a 2D Tensor with default dense (strided)
layout to a 2D Tensor backed by the COO memory layout. Only values and
indices of non-zero elements are stored in this case.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">to_sparse</span><span class="p">()</span>
<span class="go">tensor(indices=tensor([[0, 1],</span>
<span class="go">                       [1, 0]]),</span>
<span class="go">       values=tensor([2., 3.]),</span>
<span class="go">       size=(2, 2), nnz=2, layout=torch.sparse_coo)</span>
</pre></div>
</div>
<p>PyTorch currently supports <a class="reference internal" href="#sparse-coo-docs"><span class="std std-ref">COO</span></a>, <a class="reference internal" href="#sparse-csr-docs"><span class="std std-ref">CSR</span></a>,
<a class="reference internal" href="#sparse-csc-docs"><span class="std std-ref">CSC</span></a>, <a class="reference internal" href="#sparse-bsr-docs"><span class="std std-ref">BSR</span></a>, and <a class="reference internal" href="#sparse-bsc-docs"><span class="std std-ref">BSC</span></a>.</p>
<p>We also have a prototype implementation to support :ref: <cite>semi-structured sparsity&lt;sparse-semi-structured-docs&gt;</cite>.
Please see the references for more details.</p>
<p>Note that we provide slight generalizations of these formats.</p>
<p>Batching: Devices such as GPUs require batching for optimal performance and
thus we support batch dimensions.</p>
<p>We currently offer a very simple version of batching where each component of a sparse format
itself is batched. This also requires the same number of specified elements per batch entry.
In this example we construct a 3D (batched) CSR Tensor from a 3D dense Tensor.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[[</span><span class="mf">1.</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">]],</span> <span class="p">[[</span><span class="mf">4.</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">5.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">to_sparse_csr</span><span class="p">()</span>
<span class="go">tensor(crow_indices=tensor([[0, 1, 3],</span>
<span class="go">                            [0, 1, 3]]),</span>
<span class="go">       col_indices=tensor([[0, 0, 1],</span>
<span class="go">                           [0, 0, 1]]),</span>
<span class="go">       values=tensor([[1., 2., 3.],</span>
<span class="go">                      [4., 5., 6.]]), size=(2, 2, 2), nnz=3,</span>
<span class="go">       layout=torch.sparse_csr)</span>
</pre></div>
</div>
<p>Dense dimensions: On the other hand, some data such as Graph embeddings might be
better viewed as sparse collections of vectors instead of scalars.</p>
<p>In this example we create a 3D Hybrid COO Tensor with 2 sparse and 1 dense dimension
from a 3D strided Tensor. If an entire row in the 3D strided Tensor is zero, it is
not stored. If however any of the values in the row are non-zero, they are stored
entirely. This reduces the number of indices since we need one index one per row instead
of one per element. But it also increases the amount of storage for the values. Since
only rows that are <em>entirely</em> zero can be emitted and the presence of any non-zero
valued elements cause the entire row to be stored.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[[</span><span class="mf">0.</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">]],</span> <span class="p">[[</span><span class="mf">0.</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">to_sparse</span><span class="p">(</span><span class="n">sparse_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">tensor(indices=tensor([[0, 1],</span>
<span class="go">                       [1, 1]]),</span>
<span class="go">       values=tensor([[1., 2.],</span>
<span class="go">                      [3., 4.]]),</span>
<span class="go">       size=(2, 2, 2), nnz=2, layout=torch.sparse_coo)</span>
</pre></div>
</div>
</div>
<div class="section" id="operator-overview">
<h2>Operator overview<a class="headerlink" href="#operator-overview" title="Permalink to this heading">¶</a></h2>
<p>Fundamentally, operations on Tensor with sparse storage formats behave the same as
operations on Tensor with strided (or other) storage formats. The particularities of
storage, that is the physical layout of the data, influences the performance of
an operation but should not influence the semantics.</p>
<p>We are actively increasing operator coverage for sparse tensors. Users should not
expect support same level of support as for dense Tensors yet.
See our <a class="reference internal" href="#sparse-ops-docs"><span class="std std-ref">operator</span></a> documentation for a list.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b_s</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">to_sparse_csr</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b_s</span><span class="o">.</span><span class="n">cos</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">RuntimeError</span>: <span class="n">unsupported tensor layout: SparseCsr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b_s</span><span class="o">.</span><span class="n">sin</span><span class="p">()</span>
<span class="go">tensor(crow_indices=tensor([0, 3, 6]),</span>
<span class="go">       col_indices=tensor([2, 3, 4, 0, 1, 3]),</span>
<span class="go">       values=tensor([ 0.8415,  0.9093,  0.1411, -0.7568, -0.9589, -0.2794]),</span>
<span class="go">       size=(2, 6), nnz=6, layout=torch.sparse_csr)</span>
</pre></div>
</div>
<p>As shown in the example above, we don’t support non-zero preserving unary
operators such as cos. The output of a non-zero preserving unary operation
will not be able to take advantage of sparse storage formats to the same
extent as the input and potentially result in a catastrophic increase in memory.
We instead rely on the user to explicitly convert to a dense Tensor first and
then run the operation.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b_s</span><span class="o">.</span><span class="n">to_dense</span><span class="p">()</span><span class="o">.</span><span class="n">cos</span><span class="p">()</span>
<span class="go">tensor([[ 1.0000, -0.4161],</span>
<span class="go">        [-0.9900,  1.0000]])</span>
</pre></div>
</div>
<p>We are aware that some users want to ignore compressed zeros for operations such
as <cite>cos</cite> instead of preserving the exact semantics of the operation. For this we
can point to torch.masked and its MaskedTensor, which is in turn also backed and
powered by sparse storage formats and kernels.</p>
<p>Also note that, for now, the user doesn’t have a choice of the output layout. For example,
adding a sparse Tensor to a regular strided Tensor results in a strided Tensor. Some
users might prefer for this to stay a sparse layout, because they know the result will
still be sufficiently sparse.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">to_sparse</span><span class="p">()</span>
<span class="go">tensor([[0., 3.],</span>
<span class="go">        [3., 0.]])</span>
</pre></div>
</div>
<p>We acknowledge that access to kernels that can efficiently produce different output
layouts can be very useful. A subsequent operation might significantly benefit from
receiving a particular layout. We are working on an API to control the result layout
and recognize it is an important feature to plan a more optimal path of execution for
any given model.</p>
</div>
<div class="section" id="sparse-semi-structured-tensors">
<span id="sparse-semi-structured-docs"></span><h2>Sparse Semi-Structured Tensors<a class="headerlink" href="#sparse-semi-structured-tensors" title="Permalink to this heading">¶</a></h2>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Sparse semi-sturctured tensors are currently a prototype feature and subject to change. Please feel free to open an issue to report a bug or if you have feedback to share.</p>
</div>
<p>Semi-Structured sparsity is a sparse data layout that was first introduced in NVIDIA’s Ampere architecture. It is also referred to as <strong>fine-grained structured sparsity</strong> or <strong>2:4 structured sparsity</strong>.</p>
<p>This sparse layout stores <cite>n</cite> elements out of every <cite>2n</cite> elements, with <cite>n</cite> being determined by the width of the Tensor’s data type (dtype). The most frequently used dtype is float16, where <cite>n=2</cite>, thus the term “2:4 structured sparsity.”</p>
<p>Semi-structured sparsity is explained in greater detail in <a class="reference external" href="https://developer.nvidia.com/blog/exploiting-ampere-structured-sparsity-with-cusparselt">this NVIDIA blog post</a>.</p>
<p>In PyTorch, semi-structured sparsity is implemented via a Tensor subclass.
By subclassing, we can override <code class="docutils literal notranslate"><span class="pre">__torch_dispatch__</span></code> , allowing us to use faster sparse kernels when performing matrix multiplication.
We can also store the tensor in it’s compressed form inside the subclass to reduce memory overhead.</p>
<p>In this compressed form, the sparse tensor is stored by retaining only the <em>specified</em> elements and some metadata, which encodes the mask.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The specified elements and metadata mask of a semi-structured sparse tensor are stored together in a single
flat compressed tensor. They are appended to each other to form a contiguous chunk of memory.</p>
<p>compressed tensor = [ specified elements of original tensor |   metadata_mask ]</p>
<p>For an original tensor of size <cite>(r, c)</cite> we expect the first <cite>m * k // 2</cite> elements to be the kept elements
and the rest of the tensor is metadata.</p>
<p>In order to make it easier for the user to view the specified elements
and mask, one can use <code class="docutils literal notranslate"><span class="pre">.indices()</span></code> and <code class="docutils literal notranslate"><span class="pre">.values()</span></code> to access the mask and specified elements respectively.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">.values()</span></code> returns the specified elements in a tensor of size <cite>(r, c//2)</cite> and with the same dtype as the dense matrix.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.indices()</span></code> returns the metadata_mask in a tensor of size <cite>(r, c//2 )</cite> and with element type <code class="docutils literal notranslate"><span class="pre">torch.int16</span></code> if dtype is torch.float16 and element type <code class="docutils literal notranslate"><span class="pre">torch.int32</span></code> if dtype is torch.int8.</p></li>
</ul>
</div>
<p>For 2:4 sparse tensors, the metadata overhead is minor - just 2 bits per specified element.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It’s important to note that <code class="docutils literal notranslate"><span class="pre">torch.float32</span></code> is only supported for 1:2 sparsity. Therefore, it does not follow the same formula as above.</p>
</div>
<p>Here, we break down how to calculate the compression ratio ( size dense / size sparse) of a 2:4 sparse tensor.</p>
<p>Let <cite>(r, c) = tensor.shape</cite> and <cite>e = bitwidth(tensor.dtype)</cite>, so <cite>e = 16</cite> for <code class="docutils literal notranslate"><span class="pre">torch.float16</span></code> and <code class="docutils literal notranslate"><span class="pre">torch.bfloat16</span></code> and <cite>e = 8</cite> for <code class="docutils literal notranslate"><span class="pre">torch.int8</span></code>.</p>
<div class="math">
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>M</mi><mrow><mi>d</mi><mi>e</mi><mi>n</mi><mi>s</mi><mi>e</mi></mrow></msub><mo>=</mo><mi>r</mi><mo>×</mo><mi>c</mi><mo>×</mo><mi>e</mi><mspace linebreak="newline"></mspace><msub><mi>M</mi><mrow><mi>s</mi><mi>p</mi><mi>a</mi><mi>r</mi><mi>s</mi><mi>e</mi></mrow></msub><mo>=</mo><msub><mi>M</mi><mrow><mi>s</mi><mi>p</mi><mi>e</mi><mi>c</mi><mi>i</mi><mi>f</mi><mi>i</mi><mi>e</mi><mi>d</mi></mrow></msub><mo>+</mo><msub><mi>M</mi><mrow><mi>m</mi><mi>e</mi><mi>t</mi><mi>a</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi></mrow></msub><mo>=</mo><mi>r</mi><mo>×</mo><mfrac><mi>c</mi><mn>2</mn></mfrac><mo>×</mo><mi>e</mi><mo>+</mo><mi>r</mi><mo>×</mo><mfrac><mi>c</mi><mn>2</mn></mfrac><mo>×</mo><mn>2</mn><mo>=</mo><mfrac><mrow><mi>r</mi><mi>c</mi><mi>e</mi></mrow><mn>2</mn></mfrac><mo>+</mo><mi>r</mi><mi>c</mi><mo>=</mo><mi>r</mi><mi>c</mi><mi>e</mi><mo stretchy="false">(</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>+</mo><mfrac><mn>1</mn><mi>e</mi></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M_{dense} = r \times c \times e \\
M_{sparse} = M_{specified} + M_{metadata} = r \times \frac{c}{2} \times e + r \times \frac{c}{2} \times 2 = \frac{rce}{2} + rc =rce(\frac{1}{2} +\frac{1}{e})

</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">se</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">rse</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">ec</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.7936em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.7936em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.7936em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">rce</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">rc</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord mathnormal">rce</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">e</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></span></div><p>Using these calculations, we can determine the total memory footprint for both the original dense and the new sparse representation.</p>
<p>This gives us a simple formula for the compression ratio, which is dependent only on the bitwidth of the tensor datatype.</p>
<div class="math">
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>C</mi><mo>=</mo><mfrac><msub><mi>M</mi><mrow><mi>s</mi><mi>p</mi><mi>a</mi><mi>r</mi><mi>s</mi><mi>e</mi></mrow></msub><msub><mi>M</mi><mrow><mi>d</mi><mi>e</mi><mi>n</mi><mi>s</mi><mi>e</mi></mrow></msub></mfrac><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>+</mo><mfrac><mn>1</mn><mi>e</mi></mfrac></mrow><annotation encoding="application/x-tex">C = \frac{M_{sparse}}{M_{dense}} =  \frac{1}{2} + \frac{1}{e}

</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1963em;vertical-align:-0.836em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">se</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">rse</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.836em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">e</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></div><p>By using this formula, we find that the compression ratio is 56.25% for <code class="docutils literal notranslate"><span class="pre">torch.float16</span></code> and 62.5% for <code class="docutils literal notranslate"><span class="pre">torch.int8</span></code>.</p>
<div class="section" id="constructing-sparse-semi-structured-tensors">
<h3>Constructing Sparse Semi-Structured Tensors<a class="headerlink" href="#constructing-sparse-semi-structured-tensors" title="Permalink to this heading">¶</a></h3>
<p>You can transform a dense tensor into a sparse semi-structured tensor by using the <code class="docutils literal notranslate"><span class="pre">torch.sparse.to_sparse_semi_structured</span></code> function.</p>
<p>Please also note that we only support CUDA tensors since hardware compatibility for semi-structured sparsity is limited to NVIDIA GPUs.</p>
<p>The following datatypes are supported for semi-structured sparsity. Note that each datatype has its own shape constraints and compression factor.</p>
<table class="colwidths-given docutils colwidths-auto align-default">
<colgroup>
<col style="width: 19%" />
<col style="width: 56%" />
<col style="width: 13%" />
<col style="width: 13%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>PyTorch dtype</p></th>
<th class="head"><p>Shape Constraints</p></th>
<th class="head"><p>Compression Factor</p></th>
<th class="head"><p>Sparsity Pattern</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">torch.float16</span></code></p></td>
<td><p>Tensor must be 2D and (r, c) must both be a positive multiple of 64</p></td>
<td><p>9/16</p></td>
<td><p>2:4</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">torch.int8</span></code></p></td>
<td><p>Tensor must be 2D and (r, c) must both be a positive multiple of 128</p></td>
<td><p>10/16</p></td>
<td><p>2:4</p></td>
</tr>
</tbody>
</table>
<p>To construct a semi-structured sparse tensor, start by creating a regular dense tensor that adheres to a 2:4 (or semi-structured) sparse format.
To do this we  tile a small 1x4 strip to create a 16x16 dense float16 tensor.
Afterwards, we can call <code class="docutils literal notranslate"><span class="pre">to_sparse_semi_structured</span></code> on this matrix to compress it for accelerated inference.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">torch.sparse</span> <span class="kn">import</span> <span class="n">to_sparse_semi_structured</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">tile</span><span class="p">((</span><span class="mi">128</span><span class="p">,</span> <span class="mi">32</span><span class="p">))</span><span class="o">.</span><span class="n">half</span><span class="p">()</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>
<span class="go">tensor([[0., 0., 1.,  ..., 0., 1., 1.],</span>
<span class="go">        [0., 0., 1.,  ..., 0., 1., 1.],</span>
<span class="go">        [0., 0., 1.,  ..., 0., 1., 1.],</span>
<span class="go">        ...,</span>
<span class="go">        [0., 0., 1.,  ..., 0., 1., 1.],</span>
<span class="go">        [0., 0., 1.,  ..., 0., 1., 1.],</span>
<span class="go">        [0., 0., 1.,  ..., 0., 1., 1.]], device=&#39;cuda:0&#39;, dtype=torch.float16)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_sparse</span> <span class="o">=</span> <span class="n">to_sparse_semi_structured</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">bool</span><span class="p">())</span>
<span class="go">SparseSemiStructuredTensor(shape=torch.Size([128, 128]), transposed=False, values=tensor([[1., 1., 1.,  ..., 1., 1., 1.],</span>
<span class="go">        [1., 1., 1.,  ..., 1., 1., 1.],</span>
<span class="go">        [1., 1., 1.,  ..., 1., 1., 1.],</span>
<span class="go">        ...,</span>
<span class="go">        [1., 1., 1.,  ..., 1., 1., 1.],</span>
<span class="go">        [1., 1., 1.,  ..., 1., 1., 1.],</span>
<span class="go">        [1., 1., 1.,  ..., 1., 1., 1.]], device=&#39;cuda:0&#39;, dtype=torch.float16), metadata=tensor([[-4370, -4370, -4370,  ..., -4370, -4370, -4370],</span>
<span class="go">        [-4370, -4370, -4370,  ..., -4370, -4370, -4370],</span>
<span class="go">        [-4370, -4370, -4370,  ..., -4370, -4370, -4370],</span>
<span class="go">        ...,</span>
<span class="go">        [-4370, -4370, -4370,  ..., -4370, -4370, -4370],</span>
<span class="go">        [-4370, -4370, -4370,  ..., -4370, -4370, -4370],</span>
<span class="go">        [-4370, -4370, -4370,  ..., -4370, -4370, -4370]], device=&#39;cuda:0&#39;,</span>
<span class="go">dtype=torch.int16))</span>
</pre></div>
</div>
</div>
<div class="section" id="sparse-semi-structured-tensor-operations">
<h3>Sparse Semi-Structured Tensor Operations<a class="headerlink" href="#sparse-semi-structured-tensor-operations" title="Permalink to this heading">¶</a></h3>
<p>Currently, the following operations are supported for semi-structured sparse tensors:</p>
<ul class="simple">
<li><p>torch.addmm(bias, dense, sparse.t())</p></li>
<li><p>torch.mm(dense, sparse)</p></li>
<li><p>torch.mm(sparse, dense)</p></li>
<li><p>aten.linear.default(dense, sparse, bias)</p></li>
<li><p>aten.t.default(sparse)</p></li>
<li><p>aten.t.detach(sparse)</p></li>
</ul>
<p>To use these ops, simply pass the output of <code class="docutils literal notranslate"><span class="pre">to_sparse_semi_structured(tensor)</span></code>  instead of using <code class="docutils literal notranslate"><span class="pre">tensor</span></code> once your tensor has 0s in a semi-structured sparse format, like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">tile</span><span class="p">((</span><span class="mi">64</span><span class="p">,</span> <span class="mi">16</span><span class="p">))</span><span class="o">.</span><span class="n">half</span><span class="p">()</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span><span class="o">.</span><span class="n">half</span><span class="p">()</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_sparse</span> <span class="o">=</span> <span class="n">to_sparse_semi_structured</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">bool</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">mm</span><span class="p">(</span><span class="n">a_sparse</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Under the hood, SparseSemiStructuredTensor will call <code class="docutils literal notranslate"><span class="pre">torch._structured_sparse_linear</span></code> for accelerated inference using CUTLASS sparse kernels.</p>
</div>
<div class="section" id="accelerating-nn-linear-with-semi-structured-sparsity">
<h3>Accelerating nn.Linear with semi-structured sparsity<a class="headerlink" href="#accelerating-nn-linear-with-semi-structured-sparsity" title="Permalink to this heading">¶</a></h3>
<p>You can accelerate the linear layers in your model if the weights are already semi-structured sparse with just a few lines of code:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">input</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span><span class="o">.</span><span class="n">half</span><span class="p">()</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">tile</span><span class="p">((</span><span class="mi">64</span><span class="p">,</span> <span class="mi">16</span><span class="p">))</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span><span class="o">.</span><span class="n">bool</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span><span class="o">.</span><span class="n">half</span><span class="p">()</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear</span><span class="o">.</span><span class="n">weight</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">to_sparse_semi_structured</span><span class="p">(</span><span class="n">linear</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="sparse-coo-tensors">
<span id="sparse-coo-docs"></span><h2>Sparse COO tensors<a class="headerlink" href="#sparse-coo-tensors" title="Permalink to this heading">¶</a></h2>
<p>PyTorch implements the so-called Coordinate format, or COO
format, as one of the storage formats for implementing sparse
tensors.  In COO format, the specified elements are stored as tuples
of element indices and the corresponding values. In particular,</p>
<blockquote>
<div><ul class="simple">
<li><p>the indices of specified elements are collected in <code class="docutils literal notranslate"><span class="pre">indices</span></code>
tensor of size <code class="docutils literal notranslate"><span class="pre">(ndim,</span> <span class="pre">nse)</span></code> and with element type
<code class="docutils literal notranslate"><span class="pre">torch.int64</span></code>,</p></li>
<li><p>the corresponding values are collected in <code class="docutils literal notranslate"><span class="pre">values</span></code> tensor of
size <code class="docutils literal notranslate"><span class="pre">(nse,)</span></code> and with an arbitrary integer or floating point
number element type,</p></li>
</ul>
</div></blockquote>
<p>where <code class="docutils literal notranslate"><span class="pre">ndim</span></code> is the dimensionality of the tensor and <code class="docutils literal notranslate"><span class="pre">nse</span></code> is the
number of specified elements.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The memory consumption of a sparse COO tensor is at least <code class="docutils literal notranslate"><span class="pre">(ndim</span> <span class="pre">*</span>
<span class="pre">8</span> <span class="pre">+</span> <span class="pre">&lt;size</span> <span class="pre">of</span> <span class="pre">element</span> <span class="pre">type</span> <span class="pre">in</span> <span class="pre">bytes&gt;)</span> <span class="pre">*</span> <span class="pre">nse</span></code> bytes (plus a constant
overhead from storing other tensor data).</p>
<p>The memory consumption of a strided tensor is at least
<code class="docutils literal notranslate"><span class="pre">product(&lt;tensor</span> <span class="pre">shape&gt;)</span> <span class="pre">*</span> <span class="pre">&lt;size</span> <span class="pre">of</span> <span class="pre">element</span> <span class="pre">type</span> <span class="pre">in</span> <span class="pre">bytes&gt;</span></code>.</p>
<p>For example, the memory consumption of a 10 000 x 10 000 tensor
with 100 000 non-zero 32-bit floating point numbers is at least
<code class="docutils literal notranslate"><span class="pre">(2</span> <span class="pre">*</span> <span class="pre">8</span> <span class="pre">+</span> <span class="pre">4)</span> <span class="pre">*</span> <span class="pre">100</span> <span class="pre">000</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">000</span> <span class="pre">000</span></code> bytes when using COO tensor
layout and <code class="docutils literal notranslate"><span class="pre">10</span> <span class="pre">000</span> <span class="pre">*</span> <span class="pre">10</span> <span class="pre">000</span> <span class="pre">*</span> <span class="pre">4</span> <span class="pre">=</span> <span class="pre">400</span> <span class="pre">000</span> <span class="pre">000</span></code> bytes when using
the default strided tensor layout. Notice the 200 fold memory
saving from using the COO storage format.</p>
</div>
<div class="section" id="construction">
<h3>Construction<a class="headerlink" href="#construction" title="Permalink to this heading">¶</a></h3>
<p>A sparse COO tensor can be constructed by providing the two tensors of
indices and values, as well as the size of the sparse tensor (when it
cannot be inferred from the indices and values tensors) to a function
<a class="reference internal" href="generated/torch.sparse_coo_tensor.html#torch.sparse_coo_tensor" title="torch.sparse_coo_tensor"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.sparse_coo_tensor()</span></code></a>.</p>
<p>Suppose we want to define a sparse tensor with the entry 3 at location
(0, 2), entry 4 at location (1, 0), and entry 5 at location (1, 2).
Unspecified elements are assumed to have the same value, fill value,
which is zero by default. We would then write:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="go">         [2, 0, 2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span>  <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sparse_coo_tensor</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">tensor(indices=tensor([[0, 1, 1],</span>
<span class="go">                       [2, 0, 2]]),</span>
<span class="go">       values=tensor([3, 4, 5]),</span>
<span class="go">       size=(2, 3), nnz=3, layout=torch.sparse_coo)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">to_dense</span><span class="p">()</span>
<span class="go">tensor([[0, 0, 3],</span>
<span class="go">        [4, 0, 5]])</span>
</pre></div>
</div>
<p>Note that the input <code class="docutils literal notranslate"><span class="pre">i</span></code> is NOT a list of index tuples.  If you want
to write your indices this way, you should transpose before passing them to
the sparse constructor:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span>  <span class="p">[</span><span class="mi">3</span><span class="p">,</span>      <span class="mi">4</span><span class="p">,</span>      <span class="mi">5</span>    <span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sparse_coo_tensor</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">)),</span> <span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Or another equivalent formulation to get s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sparse_coo_tensor</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">t</span><span class="p">(),</span> <span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">sparse_coo_tensor</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">t</span><span class="p">(),</span> <span class="n">v</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span><span class="o">.</span><span class="n">to_dense</span><span class="p">()</span>
<span class="go">tensor([[0, 0, 3],</span>
<span class="go">        [4, 0, 5]])</span>
</pre></div>
</div>
<p>An empty sparse COO tensor can be constructed by specifying its size
only:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">torch</span><span class="o">.</span><span class="n">sparse_coo_tensor</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">tensor(indices=tensor([], size=(2, 0)),</span>
<span class="go">       values=tensor([], size=(0,)),</span>
<span class="go">       size=(2, 3), nnz=0, layout=torch.sparse_coo)</span>
</pre></div>
</div>
</div>
<div class="section" id="sparse-hybrid-coo-tensors">
<span id="sparse-hybrid-coo-docs"></span><h3>Sparse hybrid COO tensors<a class="headerlink" href="#sparse-hybrid-coo-tensors" title="Permalink to this heading">¶</a></h3>
<p>PyTorch implements an extension of sparse tensors with scalar values
to sparse tensors with (contiguous) tensor values. Such tensors are
called hybrid tensors.</p>
<p>PyTorch hybrid COO tensor extends the sparse COO tensor by allowing
the <code class="docutils literal notranslate"><span class="pre">values</span></code> tensor to be a multi-dimensional tensor so that we
have:</p>
<blockquote>
<div><ul class="simple">
<li><p>the indices of specified elements are collected in <code class="docutils literal notranslate"><span class="pre">indices</span></code>
tensor of size <code class="docutils literal notranslate"><span class="pre">(sparse_dims,</span> <span class="pre">nse)</span></code> and with element type
<code class="docutils literal notranslate"><span class="pre">torch.int64</span></code>,</p></li>
<li><p>the corresponding (tensor) values are collected in <code class="docutils literal notranslate"><span class="pre">values</span></code>
tensor of size <code class="docutils literal notranslate"><span class="pre">(nse,</span> <span class="pre">dense_dims)</span></code> and with an arbitrary integer
or floating point number element type.</p></li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We use (M + K)-dimensional tensor to denote a N-dimensional sparse
hybrid tensor, where M and K are the numbers of sparse and dense
dimensions, respectively, such that M + K == N holds.</p>
</div>
<p>Suppose we want to create a (2 + 1)-dimensional tensor with the entry
[3, 4] at location (0, 2), entry [5, 6] at location (1, 0), and entry
[7, 8] at location (1, 2). We would write</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="go">         [2, 0, 2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span>  <span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sparse_coo_tensor</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">tensor(indices=tensor([[0, 1, 1],</span>
<span class="go">                       [2, 0, 2]]),</span>
<span class="go">       values=tensor([[3, 4],</span>
<span class="go">                      [5, 6],</span>
<span class="go">                      [7, 8]]),</span>
<span class="go">       size=(2, 3, 2), nnz=3, layout=torch.sparse_coo)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">to_dense</span><span class="p">()</span>
<span class="go">tensor([[[0, 0],</span>
<span class="go">         [0, 0],</span>
<span class="go">         [3, 4]],</span>
<span class="go">        [[5, 6],</span>
<span class="go">         [0, 0],</span>
<span class="go">         [7, 8]]])</span>
</pre></div>
</div>
<p>In general, if <code class="docutils literal notranslate"><span class="pre">s</span></code> is a sparse COO tensor and <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">=</span>
<span class="pre">s.sparse_dim()</span></code>, <code class="docutils literal notranslate"><span class="pre">K</span> <span class="pre">=</span> <span class="pre">s.dense_dim()</span></code>, then we have the following
invariants:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">+</span> <span class="pre">K</span> <span class="pre">==</span> <span class="pre">len(s.shape)</span> <span class="pre">==</span> <span class="pre">s.ndim</span></code> - dimensionality of a tensor
is the sum of the number of sparse and dense dimensions,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">s.indices().shape</span> <span class="pre">==</span> <span class="pre">(M,</span> <span class="pre">nse)</span></code> - sparse indices are stored
explicitly,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">s.values().shape</span> <span class="pre">==</span> <span class="pre">(nse,)</span> <span class="pre">+</span> <span class="pre">s.shape[M</span> <span class="pre">:</span> <span class="pre">M</span> <span class="pre">+</span> <span class="pre">K]</span></code> - the values
of a hybrid tensor are K-dimensional tensors,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">s.values().layout</span> <span class="pre">==</span> <span class="pre">torch.strided</span></code> - values are stored as
strided tensors.</p></li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Dense dimensions always follow sparse dimensions, that is, mixing
of dense and sparse dimensions is not supported.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To be sure that a constructed sparse tensor has consistent indices,
values, and size, the invariant checks can be enabled per tensor
creation via <code class="docutils literal notranslate"><span class="pre">check_invariants=True</span></code> keyword argument, or
globally using <a class="reference internal" href="generated/torch.sparse.check_sparse_tensor_invariants.html#torch.sparse.check_sparse_tensor_invariants" title="torch.sparse.check_sparse_tensor_invariants"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.sparse.check_sparse_tensor_invariants</span></code></a>
context manager instance. By default, the sparse tensor invariants
checks are disabled.</p>
</div>
</div>
<div class="section" id="uncoalesced-sparse-coo-tensors">
<span id="sparse-uncoalesced-coo-docs"></span><h3>Uncoalesced sparse COO tensors<a class="headerlink" href="#uncoalesced-sparse-coo-tensors" title="Permalink to this heading">¶</a></h3>
<p>PyTorch sparse COO tensor format permits sparse <em>uncoalesced</em> tensors,
where there may be duplicate coordinates in the indices; in this case,
the interpretation is that the value at that index is the sum of all
duplicate value entries. For example, one can specify multiple values,
<code class="docutils literal notranslate"><span class="pre">3</span></code> and <code class="docutils literal notranslate"><span class="pre">4</span></code>, for the same index <code class="docutils literal notranslate"><span class="pre">1</span></code>, that leads to an 1-D
uncoalesced tensor:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span>  <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">sparse_coo_tensor</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">tensor(indices=tensor([[1, 1]]),</span>
<span class="go">       values=tensor(  [3, 4]),</span>
<span class="go">       size=(3,), nnz=2, layout=torch.sparse_coo)</span>
</pre></div>
</div>
<p>while the coalescing process will accumulate the multi-valued elements
into a single value using summation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">coalesce</span><span class="p">()</span>
<span class="go">tensor(indices=tensor([[1]]),</span>
<span class="go">       values=tensor([7]),</span>
<span class="go">       size=(3,), nnz=1, layout=torch.sparse_coo)</span>
</pre></div>
</div>
<p>In general, the output of <a class="reference internal" href="generated/torch.Tensor.coalesce.html#torch.Tensor.coalesce" title="torch.Tensor.coalesce"><code class="xref py py-meth docutils literal notranslate"><span class="pre">torch.Tensor.coalesce()</span></code></a> method is a
sparse tensor with the following properties:</p>
<ul class="simple">
<li><p>the indices of specified tensor elements are unique,</p></li>
<li><p>the indices are sorted in lexicographical order,</p></li>
<li><p><a class="reference internal" href="generated/torch.Tensor.is_coalesced.html#torch.Tensor.is_coalesced" title="torch.Tensor.is_coalesced"><code class="xref py py-meth docutils literal notranslate"><span class="pre">torch.Tensor.is_coalesced()</span></code></a> returns <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For the most part, you shouldn’t have to care whether or not a
sparse tensor is coalesced or not, as most operations will work
identically given a sparse coalesced or uncoalesced tensor.</p>
<p>However, some operations can be implemented more efficiently on
uncoalesced tensors, and some on coalesced tensors.</p>
<p>For instance, addition of sparse COO tensors is implemented by
simply concatenating the indices and values tensors:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sparse_coo_tensor</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sparse_coo_tensor</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="go">tensor(indices=tensor([[0, 0, 1, 1]]),</span>
<span class="go">       values=tensor([7, 8, 5, 6]),</span>
<span class="go">       size=(2,), nnz=4, layout=torch.sparse_coo)</span>
</pre></div>
</div>
<p>If you repeatedly perform an operation that can produce duplicate
entries (e.g., <a class="reference internal" href="generated/torch.Tensor.add.html#torch.Tensor.add" title="torch.Tensor.add"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.Tensor.add()</span></code></a>), you should occasionally
coalesce your sparse tensors to prevent them from growing too large.</p>
<p>On the other hand, the lexicographical ordering of indices can be
advantageous for implementing algorithms that involve many element
selection operations, such as slicing or matrix products.</p>
</div>
</div>
<div class="section" id="working-with-sparse-coo-tensors">
<h3>Working with sparse COO tensors<a class="headerlink" href="#working-with-sparse-coo-tensors" title="Permalink to this heading">¶</a></h3>
<p>Let’s consider the following example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="go">         [2, 0, 2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span>  <span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sparse_coo_tensor</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>As mentioned above, a sparse COO tensor is a <a class="reference internal" href="tensors.html#torch.Tensor" title="torch.Tensor"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a>
instance and to distinguish it from the <cite>Tensor</cite> instances that use
some other layout, on can use <a class="reference internal" href="generated/torch.Tensor.is_sparse.html#torch.Tensor.is_sparse" title="torch.Tensor.is_sparse"><code class="xref py py-attr docutils literal notranslate"><span class="pre">torch.Tensor.is_sparse</span></code></a> or
<code class="xref py py-attr docutils literal notranslate"><span class="pre">torch.Tensor.layout</span></code> properties:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">is_sparse</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">layout</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">sparse_coo</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The number of sparse and dense dimensions can be acquired using
methods <a class="reference internal" href="generated/torch.Tensor.sparse_dim.html#torch.Tensor.sparse_dim" title="torch.Tensor.sparse_dim"><code class="xref py py-meth docutils literal notranslate"><span class="pre">torch.Tensor.sparse_dim()</span></code></a> and
<a class="reference internal" href="generated/torch.Tensor.dense_dim.html#torch.Tensor.dense_dim" title="torch.Tensor.dense_dim"><code class="xref py py-meth docutils literal notranslate"><span class="pre">torch.Tensor.dense_dim()</span></code></a>, respectively. For instance:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">sparse_dim</span><span class="p">(),</span> <span class="n">s</span><span class="o">.</span><span class="n">dense_dim</span><span class="p">()</span>
<span class="go">(2, 1)</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">s</span></code> is a sparse COO tensor then its COO format data can be
acquired using methods <a class="reference internal" href="generated/torch.Tensor.indices.html#torch.Tensor.indices" title="torch.Tensor.indices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">torch.Tensor.indices()</span></code></a> and
<a class="reference internal" href="generated/torch.Tensor.values.html#torch.Tensor.values" title="torch.Tensor.values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">torch.Tensor.values()</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, one can acquire the COO format data only when the tensor
instance is coalesced:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">indices</span><span class="p">()</span>
<span class="go">RuntimeError: Cannot get indices on an uncoalesced tensor, please call .coalesce() first</span>
</pre></div>
</div>
<p>For acquiring the COO format data of an uncoalesced tensor, use
<code class="xref py py-func docutils literal notranslate"><span class="pre">torch.Tensor._values()</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">torch.Tensor._indices()</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">_indices</span><span class="p">()</span>
<span class="go">tensor([[0, 1, 1],</span>
<span class="go">        [2, 0, 2]])</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Calling <code class="xref py py-meth docutils literal notranslate"><span class="pre">torch.Tensor._values()</span></code> will return a <em>detached</em> tensor.
To track gradients, <code class="xref py py-meth docutils literal notranslate"><span class="pre">torch.Tensor.coalesce().values()</span></code> must be
used instead.</p>
</div>
</div>
<p>Constructing a new sparse COO tensor results a tensor that is not
coalesced:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">is_coalesced</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>but one can construct a coalesced copy of a sparse COO tensor using
the <a class="reference internal" href="generated/torch.Tensor.coalesce.html#torch.Tensor.coalesce" title="torch.Tensor.coalesce"><code class="xref py py-meth docutils literal notranslate"><span class="pre">torch.Tensor.coalesce()</span></code></a> method:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">coalesce</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span><span class="o">.</span><span class="n">indices</span><span class="p">()</span>
<span class="go">tensor([[0, 1, 1],</span>
<span class="go">       [2, 0, 2]])</span>
</pre></div>
</div>
<p>When working with uncoalesced sparse COO tensors, one must take into
an account the additive nature of uncoalesced data: the values of the
same indices are the terms of a sum that evaluation gives the value of
the corresponding tensor element. For example, the scalar
multiplication on a sparse uncoalesced tensor could be implemented by
multiplying all the uncoalesced values with the scalar because <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">*</span>
<span class="pre">(a</span> <span class="pre">+</span> <span class="pre">b)</span> <span class="pre">==</span> <span class="pre">c</span> <span class="pre">*</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">c</span> <span class="pre">*</span> <span class="pre">b</span></code> holds. However, any nonlinear operation,
say, a square root, cannot be implemented by applying the operation to
uncoalesced data because <code class="docutils literal notranslate"><span class="pre">sqrt(a</span> <span class="pre">+</span> <span class="pre">b)</span> <span class="pre">==</span> <span class="pre">sqrt(a)</span> <span class="pre">+</span> <span class="pre">sqrt(b)</span></code> does not
hold in general.</p>
<p>Slicing (with positive step) of a sparse COO tensor is supported only
for dense dimensions. Indexing is supported for both sparse and dense
dimensions:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">tensor(indices=tensor([[0, 2]]),</span>
<span class="go">       values=tensor([[5, 6],</span>
<span class="go">                      [7, 8]]),</span>
<span class="go">       size=(3, 2), nnz=2, layout=torch.sparse_coo)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="go">tensor(6)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span>
<span class="go">tensor([6])</span>
</pre></div>
</div>
<p>In PyTorch, the fill value of a sparse tensor cannot be specified
explicitly and is assumed to be zero in general. However, there exists
operations that may interpret the fill value differently. For
instance, <a class="reference internal" href="generated/torch.sparse.softmax.html#torch.sparse.softmax" title="torch.sparse.softmax"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.sparse.softmax()</span></code></a> computes the softmax with the
assumption that the fill value is negative infinity.</p>
</div>
</div>
<div class="section" id="sparse-compressed-tensors">
<span id="sparse-compressed-docs"></span><h2>Sparse Compressed Tensors<a class="headerlink" href="#sparse-compressed-tensors" title="Permalink to this heading">¶</a></h2>
<p>Sparse Compressed Tensors represents a class of sparse tensors that
have a common feature of compressing the indices of a certain dimension
using an encoding that enables certain optimizations on linear algebra
kernels of sparse compressed tensors. This encoding is based on the
<a class="reference external" href="https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_(CSR,_CRS_or_Yale_format)">Compressed Sparse Row (CSR)</a> format that PyTorch sparse compressed
tensors extend with the support of sparse tensor batches, allowing
multi-dimensional tensor values, and storing sparse tensor values in
dense blocks.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We use (B + M + K)-dimensional tensor to denote a N-dimensional
sparse compressed hybrid tensor, where B, M, and K are the numbers
of batch, sparse, and dense dimensions, respectively, such that
<code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">+</span> <span class="pre">M</span> <span class="pre">+</span> <span class="pre">K</span> <span class="pre">==</span> <span class="pre">N</span></code> holds. The number of sparse dimensions for
sparse compressed tensors is always two, <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">==</span> <span class="pre">2</span></code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We say that an indices tensor <code class="docutils literal notranslate"><span class="pre">compressed_indices</span></code> uses CSR
encoding if the following invariants are satisfied:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">compressed_indices</span></code> is a contiguous strided 32 or 64 bit
integer tensor</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">compressed_indices</span></code> shape is <code class="docutils literal notranslate"><span class="pre">(*batchsize,</span>
<span class="pre">compressed_dim_size</span> <span class="pre">+</span> <span class="pre">1)</span></code> where <code class="docutils literal notranslate"><span class="pre">compressed_dim_size</span></code> is the
number of compressed dimensions (e.g. rows or columns)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">compressed_indices[...,</span> <span class="pre">0]</span> <span class="pre">==</span> <span class="pre">0</span></code> where <code class="docutils literal notranslate"><span class="pre">...</span></code> denotes batch
indices</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">compressed_indices[...,</span> <span class="pre">compressed_dim_size]</span> <span class="pre">==</span> <span class="pre">nse</span></code> where
<code class="docutils literal notranslate"><span class="pre">nse</span></code> is the number of specified elements</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">compressed_indices[...,</span> <span class="pre">i]</span> <span class="pre">-</span> <span class="pre">compressed_indices[...,</span> <span class="pre">i</span> <span class="pre">-</span>
<span class="pre">1]</span> <span class="pre">&lt;=</span> <span class="pre">plain_dim_size</span></code> for <code class="docutils literal notranslate"><span class="pre">i=1,</span> <span class="pre">...,</span> <span class="pre">compressed_dim_size</span></code>,
where <code class="docutils literal notranslate"><span class="pre">plain_dim_size</span></code> is the number of plain dimensions
(orthogonal to compressed dimensions, e.g. columns or rows).</p></li>
</ul>
<p>To be sure that a constructed sparse tensor has consistent indices,
values, and size, the invariant checks can be enabled per tensor
creation via <code class="docutils literal notranslate"><span class="pre">check_invariants=True</span></code> keyword argument, or
globally using <a class="reference internal" href="generated/torch.sparse.check_sparse_tensor_invariants.html#torch.sparse.check_sparse_tensor_invariants" title="torch.sparse.check_sparse_tensor_invariants"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.sparse.check_sparse_tensor_invariants</span></code></a>
context manager instance. By default, the sparse tensor invariants
checks are disabled.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The generalization of sparse compressed layouts to N-dimensional
tensors can lead to some confusion regarding the count of specified
elements. When a sparse compressed tensor contains batch dimensions
the number of specified elements will correspond to the number of such
elements per-batch. When a sparse compressed tensor has dense dimensions
the element considered is now the K-dimensional array. Also for block
sparse compressed layouts the 2-D block is considered as the element
being specified.  Take as an example a 3-dimensional block sparse
tensor, with one batch dimension of length <code class="docutils literal notranslate"><span class="pre">b</span></code>, and a block
shape of <code class="docutils literal notranslate"><span class="pre">p,</span> <span class="pre">q</span></code>. If this tensor has <code class="docutils literal notranslate"><span class="pre">n</span></code> specified elements, then
in fact we have <code class="docutils literal notranslate"><span class="pre">n</span></code> blocks specified per batch. This tensor would
have <code class="docutils literal notranslate"><span class="pre">values</span></code> with shape <code class="docutils literal notranslate"><span class="pre">(b,</span> <span class="pre">n,</span> <span class="pre">p,</span> <span class="pre">q)</span></code>. This interpretation of the
number of specified elements comes from all sparse compressed layouts
being derived from the compression of a 2-dimensional matrix. Batch
dimensions are treated as stacking of sparse matrices, dense dimensions
change the meaning of the element from a simple scalar value to an
array with its own dimensions.</p>
</div>
<div class="section" id="sparse-csr-tensor">
<span id="sparse-csr-docs"></span><h3>Sparse CSR Tensor<a class="headerlink" href="#sparse-csr-tensor" title="Permalink to this heading">¶</a></h3>
<p>The primary advantage of the CSR format over the COO format is better
use of storage and much faster computation operations such as sparse
matrix-vector multiplication using MKL and MAGMA backends.</p>
<p>In the simplest case, a (0 + 2 + 0)-dimensional sparse CSR tensor
consists of three 1-D tensors: <code class="docutils literal notranslate"><span class="pre">crow_indices</span></code>, <code class="docutils literal notranslate"><span class="pre">col_indices</span></code> and
<code class="docutils literal notranslate"><span class="pre">values</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">crow_indices</span></code> tensor consists of compressed row
indices. This is a 1-D tensor of size <code class="docutils literal notranslate"><span class="pre">nrows</span> <span class="pre">+</span> <span class="pre">1</span></code> (the number of
rows plus 1). The last element of <code class="docutils literal notranslate"><span class="pre">crow_indices</span></code> is the number
of specified elements, <code class="docutils literal notranslate"><span class="pre">nse</span></code>. This tensor encodes the index in
<code class="docutils literal notranslate"><span class="pre">values</span></code> and <code class="docutils literal notranslate"><span class="pre">col_indices</span></code> depending on where the given row
starts. Each successive number in the tensor subtracted by the
number before it denotes the number of elements in a given row.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">col_indices</span></code> tensor contains the column indices of each
element. This is a 1-D tensor of size <code class="docutils literal notranslate"><span class="pre">nse</span></code>.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">values</span></code> tensor contains the values of the CSR tensor
elements. This is a 1-D tensor of size <code class="docutils literal notranslate"><span class="pre">nse</span></code>.</p></li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The index tensors <code class="docutils literal notranslate"><span class="pre">crow_indices</span></code> and <code class="docutils literal notranslate"><span class="pre">col_indices</span></code> should have
element type either <code class="docutils literal notranslate"><span class="pre">torch.int64</span></code> (default) or
<code class="docutils literal notranslate"><span class="pre">torch.int32</span></code>. If you want to use MKL-enabled matrix operations,
use <code class="docutils literal notranslate"><span class="pre">torch.int32</span></code>. This is as a result of the default linking of
pytorch being with MKL LP64, which uses 32 bit integer indexing.</p>
</div>
<p>In the general case, the (B + 2 + K)-dimensional sparse CSR tensor
consists of two (B + 1)-dimensional index tensors <code class="docutils literal notranslate"><span class="pre">crow_indices</span></code> and
<code class="docutils literal notranslate"><span class="pre">col_indices</span></code>, and of (1 + K)-dimensional <code class="docutils literal notranslate"><span class="pre">values</span></code> tensor such
that</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">crow_indices.shape</span> <span class="pre">==</span> <span class="pre">(*batchsize,</span> <span class="pre">nrows</span> <span class="pre">+</span> <span class="pre">1)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">col_indices.shape</span> <span class="pre">==</span> <span class="pre">(*batchsize,</span> <span class="pre">nse)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">values.shape</span> <span class="pre">==</span> <span class="pre">(nse,</span> <span class="pre">*densesize)</span></code></p></li>
</ul>
</div></blockquote>
<p>while the shape of the sparse CSR tensor is <code class="docutils literal notranslate"><span class="pre">(*batchsize,</span> <span class="pre">nrows,</span>
<span class="pre">ncols,</span> <span class="pre">*densesize)</span></code> where <code class="docutils literal notranslate"><span class="pre">len(batchsize)</span> <span class="pre">==</span> <span class="pre">B</span></code> and
<code class="docutils literal notranslate"><span class="pre">len(densesize)</span> <span class="pre">==</span> <span class="pre">K</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The batches of sparse CSR tensors are dependent: the number of
specified elements in all batches must be the same. This somewhat
artificial constraint allows efficient storage of the indices of
different CSR batches.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The number of sparse and dense dimensions can be acquired using
<a class="reference internal" href="generated/torch.Tensor.sparse_dim.html#torch.Tensor.sparse_dim" title="torch.Tensor.sparse_dim"><code class="xref py py-meth docutils literal notranslate"><span class="pre">torch.Tensor.sparse_dim()</span></code></a> and <a class="reference internal" href="generated/torch.Tensor.dense_dim.html#torch.Tensor.dense_dim" title="torch.Tensor.dense_dim"><code class="xref py py-meth docutils literal notranslate"><span class="pre">torch.Tensor.dense_dim()</span></code></a>
methods. The batch dimensions can be computed from the tensor
shape: <code class="docutils literal notranslate"><span class="pre">batchsize</span> <span class="pre">=</span> <span class="pre">tensor.shape[:-tensor.sparse_dim()</span> <span class="pre">-</span>
<span class="pre">tensor.dense_dim()]</span></code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The memory consumption of a sparse CSR tensor is at least
<code class="docutils literal notranslate"><span class="pre">(nrows</span> <span class="pre">*</span> <span class="pre">8</span> <span class="pre">+</span> <span class="pre">(8</span> <span class="pre">+</span> <span class="pre">&lt;size</span> <span class="pre">of</span> <span class="pre">element</span> <span class="pre">type</span> <span class="pre">in</span> <span class="pre">bytes&gt;</span> <span class="pre">*</span>
<span class="pre">prod(densesize))</span> <span class="pre">*</span> <span class="pre">nse)</span> <span class="pre">*</span> <span class="pre">prod(batchsize)</span></code> bytes (plus a constant
overhead from storing other tensor data).</p>
<p>With the same example data of <a class="reference internal" href="#sparse-coo-docs"><span class="std std-ref">the note in sparse COO format
introduction</span></a>, the memory consumption of a 10 000
x 10 000 tensor with 100 000 non-zero 32-bit floating point numbers
is at least <code class="docutils literal notranslate"><span class="pre">(10000</span> <span class="pre">*</span> <span class="pre">8</span> <span class="pre">+</span> <span class="pre">(8</span> <span class="pre">+</span> <span class="pre">4</span> <span class="pre">*</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">100</span> <span class="pre">000)</span> <span class="pre">*</span> <span class="pre">1</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">280</span> <span class="pre">000</span></code>
bytes when using CSR tensor layout. Notice the 1.6 and 310 fold
savings from using CSR storage format compared to using the COO and
strided formats, respectively.</p>
</div>
<div class="section" id="construction-of-csr-tensors">
<h4>Construction of CSR tensors<a class="headerlink" href="#construction-of-csr-tensors" title="Permalink to this heading">¶</a></h4>
<p>Sparse CSR tensors can be directly constructed by using the
<a class="reference internal" href="generated/torch.sparse_csr_tensor.html#torch.sparse_csr_tensor" title="torch.sparse_csr_tensor"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.sparse_csr_tensor()</span></code></a> function. The user must supply the row
and column indices and values tensors separately where the row indices
must be specified using the CSR compression encoding.  The <code class="docutils literal notranslate"><span class="pre">size</span></code>
argument is optional and will be deduced from the <code class="docutils literal notranslate"><span class="pre">crow_indices</span></code> and
<code class="docutils literal notranslate"><span class="pre">col_indices</span></code> if it is not present.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">crow_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">col_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">csr</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sparse_csr_tensor</span><span class="p">(</span><span class="n">crow_indices</span><span class="p">,</span> <span class="n">col_indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">csr</span>
<span class="go">tensor(crow_indices=tensor([0, 2, 4]),</span>
<span class="go">       col_indices=tensor([0, 1, 0, 1]),</span>
<span class="go">       values=tensor([1., 2., 3., 4.]), size=(2, 2), nnz=4,</span>
<span class="go">       dtype=torch.float64)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">csr</span><span class="o">.</span><span class="n">to_dense</span><span class="p">()</span>
<span class="go">tensor([[1., 2.],</span>
<span class="go">        [3., 4.]], dtype=torch.float64)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The values of sparse dimensions in deduced <code class="docutils literal notranslate"><span class="pre">size</span></code> is computed
from the size of <code class="docutils literal notranslate"><span class="pre">crow_indices</span></code> and the maximal index value in
<code class="docutils literal notranslate"><span class="pre">col_indices</span></code>. If the number of columns needs to be larger than
in the deduced <code class="docutils literal notranslate"><span class="pre">size</span></code> then the <code class="docutils literal notranslate"><span class="pre">size</span></code> argument must be
specified explicitly.</p>
</div>
<p>The simplest way of constructing a 2-D sparse CSR tensor from a
strided or sparse COO tensor is to use
<a class="reference internal" href="generated/torch.Tensor.to_sparse_csr.html#torch.Tensor.to_sparse_csr" title="torch.Tensor.to_sparse_csr"><code class="xref py py-meth docutils literal notranslate"><span class="pre">torch.Tensor.to_sparse_csr()</span></code></a> method. Any zeros in the (strided)
tensor will be interpreted as missing values in the sparse tensor:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sp</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">to_sparse_csr</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sp</span>
<span class="go">tensor(crow_indices=tensor([0, 1, 3, 3]),</span>
<span class="go">      col_indices=tensor([2, 0, 1]),</span>
<span class="go">      values=tensor([1., 1., 2.]), size=(3, 4), nnz=3, dtype=torch.float64)</span>
</pre></div>
</div>
</div>
<div class="section" id="csr-tensor-operations">
<h4>CSR Tensor Operations<a class="headerlink" href="#csr-tensor-operations" title="Permalink to this heading">¶</a></h4>
<p>The sparse matrix-vector multiplication can be performed with the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">tensor.matmul()</span></code> method. This is currently the only math operation
supported on CSR tensors.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vec</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sp</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
<span class="go">tensor([[0.9078],</span>
<span class="go">        [1.3180],</span>
<span class="go">        [0.0000]], dtype=torch.float64)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="sparse-csc-tensor">
<span id="sparse-csc-docs"></span><h3>Sparse CSC Tensor<a class="headerlink" href="#sparse-csc-tensor" title="Permalink to this heading">¶</a></h3>
<p>The sparse CSC (Compressed Sparse Column) tensor format implements the
CSC format for storage of 2 dimensional tensors with an extension to
supporting batches of sparse CSC tensors and values being
multi-dimensional tensors.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Sparse CSC tensor is essentially a transpose of the sparse CSR
tensor when the transposition is about swapping the sparse
dimensions.</p>
</div>
<p>Similarly to <a class="reference internal" href="#sparse-csr-docs"><span class="std std-ref">sparse CSR tensors</span></a>, a sparse CSC
tensor consists of three tensors: <code class="docutils literal notranslate"><span class="pre">ccol_indices</span></code>, <code class="docutils literal notranslate"><span class="pre">row_indices</span></code>
and <code class="docutils literal notranslate"><span class="pre">values</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">ccol_indices</span></code> tensor consists of compressed column
indices. This is a (B + 1)-D tensor of shape <code class="docutils literal notranslate"><span class="pre">(*batchsize,</span> <span class="pre">ncols</span> <span class="pre">+</span> <span class="pre">1)</span></code>.
The last element is the number of specified
elements, <code class="docutils literal notranslate"><span class="pre">nse</span></code>. This tensor encodes the index in <code class="docutils literal notranslate"><span class="pre">values</span></code> and
<code class="docutils literal notranslate"><span class="pre">row_indices</span></code> depending on where the given column starts. Each
successive number in the tensor subtracted by the number before it
denotes the number of elements in a given column.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">row_indices</span></code> tensor contains the row indices of each
element. This is a (B + 1)-D tensor of shape <code class="docutils literal notranslate"><span class="pre">(*batchsize,</span> <span class="pre">nse)</span></code>.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">values</span></code> tensor contains the values of the CSC tensor
elements. This is a (1 + K)-D tensor of shape <code class="docutils literal notranslate"><span class="pre">(nse,</span> <span class="pre">*densesize)</span></code>.</p></li>
</ul>
</div></blockquote>
<div class="section" id="construction-of-csc-tensors">
<h4>Construction of CSC tensors<a class="headerlink" href="#construction-of-csc-tensors" title="Permalink to this heading">¶</a></h4>
<p>Sparse CSC tensors can be directly constructed by using the
<a class="reference internal" href="generated/torch.sparse_csc_tensor.html#torch.sparse_csc_tensor" title="torch.sparse_csc_tensor"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.sparse_csc_tensor()</span></code></a> function. The user must supply the row
and column indices and values tensors separately where the column indices
must be specified using the CSR compression encoding.  The <code class="docutils literal notranslate"><span class="pre">size</span></code>
argument is optional and will be deduced from the <code class="docutils literal notranslate"><span class="pre">row_indices</span></code> and
<code class="docutils literal notranslate"><span class="pre">ccol_indices</span></code> tensors if it is not present.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ccol_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">csc</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sparse_csc_tensor</span><span class="p">(</span><span class="n">ccol_indices</span><span class="p">,</span> <span class="n">row_indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">csc</span>
<span class="go">tensor(ccol_indices=tensor([0, 2, 4]),</span>
<span class="go">       row_indices=tensor([0, 1, 0, 1]),</span>
<span class="go">       values=tensor([1., 2., 3., 4.]), size=(2, 2), nnz=4,</span>
<span class="go">       dtype=torch.float64, layout=torch.sparse_csc)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">csc</span><span class="o">.</span><span class="n">to_dense</span><span class="p">()</span>
<span class="go">tensor([[1., 3.],</span>
<span class="go">        [2., 4.]], dtype=torch.float64)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The sparse CSC tensor constructor function has the compressed
column indices argument before the row indices argument.</p>
</div>
<p>The (0 + 2 + 0)-dimensional sparse CSC tensors can be constructed from
any two-dimensional tensor using <a class="reference internal" href="generated/torch.Tensor.to_sparse_csc.html#torch.Tensor.to_sparse_csc" title="torch.Tensor.to_sparse_csc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">torch.Tensor.to_sparse_csc()</span></code></a>
method. Any zeros in the (strided) tensor will be interpreted as
missing values in the sparse tensor:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sp</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">to_sparse_csc</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sp</span>
<span class="go">tensor(ccol_indices=tensor([0, 1, 2, 3, 3]),</span>
<span class="go">       row_indices=tensor([1, 1, 0]),</span>
<span class="go">       values=tensor([1., 2., 1.]), size=(3, 4), nnz=3, dtype=torch.float64,</span>
<span class="go">       layout=torch.sparse_csc)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="sparse-bsr-tensor">
<span id="sparse-bsr-docs"></span><h3>Sparse BSR Tensor<a class="headerlink" href="#sparse-bsr-tensor" title="Permalink to this heading">¶</a></h3>
<p>The sparse BSR (Block compressed Sparse Row) tensor format implements the
BSR format for storage of two-dimensional tensors with an extension to
supporting batches of sparse BSR tensors and values being blocks of
multi-dimensional tensors.</p>
<p>A sparse BSR tensor consists of three tensors: <code class="docutils literal notranslate"><span class="pre">crow_indices</span></code>,
<code class="docutils literal notranslate"><span class="pre">col_indices</span></code> and <code class="docutils literal notranslate"><span class="pre">values</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">crow_indices</span></code> tensor consists of compressed row
indices. This is a (B + 1)-D tensor of shape <code class="docutils literal notranslate"><span class="pre">(*batchsize,</span>
<span class="pre">nrowblocks</span> <span class="pre">+</span> <span class="pre">1)</span></code>.  The last element is the number of specified blocks,
<code class="docutils literal notranslate"><span class="pre">nse</span></code>. This tensor encodes the index in <code class="docutils literal notranslate"><span class="pre">values</span></code> and
<code class="docutils literal notranslate"><span class="pre">col_indices</span></code> depending on where the given column block
starts. Each successive number in the tensor subtracted by the
number before it denotes the number of blocks in a given row.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">col_indices</span></code> tensor contains the column block indices of each
element. This is a (B + 1)-D tensor of shape <code class="docutils literal notranslate"><span class="pre">(*batchsize,</span>
<span class="pre">nse)</span></code>.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">values</span></code> tensor contains the values of the sparse BSR tensor
elements collected into two-dimensional blocks. This is a (1 + 2 +
K)-D tensor of shape <code class="docutils literal notranslate"><span class="pre">(nse,</span> <span class="pre">nrowblocks,</span> <span class="pre">ncolblocks,</span>
<span class="pre">*densesize)</span></code>.</p></li>
</ul>
</div></blockquote>
<div class="section" id="construction-of-bsr-tensors">
<h4>Construction of BSR tensors<a class="headerlink" href="#construction-of-bsr-tensors" title="Permalink to this heading">¶</a></h4>
<p>Sparse BSR tensors can be directly constructed by using the
<a class="reference internal" href="generated/torch.sparse_bsr_tensor.html#torch.sparse_bsr_tensor" title="torch.sparse_bsr_tensor"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.sparse_bsr_tensor()</span></code></a> function. The user must supply the row
and column block indices and values tensors separately where the row block indices
must be specified using the CSR compression encoding.
The <code class="docutils literal notranslate"><span class="pre">size</span></code> argument is optional and will be deduced from the <code class="docutils literal notranslate"><span class="pre">crow_indices</span></code> and
<code class="docutils literal notranslate"><span class="pre">col_indices</span></code> tensors if it is not present.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">crow_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">col_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]],</span>
<span class="gp">... </span>                       <span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">]],</span>
<span class="gp">... </span>                       <span class="p">[[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">],</span> <span class="p">[</span><span class="mi">18</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">20</span><span class="p">]],</span>
<span class="gp">... </span>                       <span class="p">[[</span><span class="mi">15</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">17</span><span class="p">],</span> <span class="p">[</span><span class="mi">21</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">23</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bsr</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sparse_bsr_tensor</span><span class="p">(</span><span class="n">crow_indices</span><span class="p">,</span> <span class="n">col_indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bsr</span>
<span class="go">tensor(crow_indices=tensor([0, 2, 4]),</span>
<span class="go">       col_indices=tensor([0, 1, 0, 1]),</span>
<span class="go">       values=tensor([[[ 0.,  1.,  2.],</span>
<span class="go">                       [ 6.,  7.,  8.]],</span>
<span class="go">                      [[ 3.,  4.,  5.],</span>
<span class="go">                       [ 9., 10., 11.]],</span>
<span class="go">                      [[12., 13., 14.],</span>
<span class="go">                       [18., 19., 20.]],</span>
<span class="go">                      [[15., 16., 17.],</span>
<span class="go">                       [21., 22., 23.]]]),</span>
<span class="go">       size=(4, 6), nnz=4, dtype=torch.float64, layout=torch.sparse_bsr)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bsr</span><span class="o">.</span><span class="n">to_dense</span><span class="p">()</span>
<span class="go">tensor([[ 0.,  1.,  2.,  3.,  4.,  5.],</span>
<span class="go">        [ 6.,  7.,  8.,  9., 10., 11.],</span>
<span class="go">        [12., 13., 14., 15., 16., 17.],</span>
<span class="go">        [18., 19., 20., 21., 22., 23.]], dtype=torch.float64)</span>
</pre></div>
</div>
<p>The (0 + 2 + 0)-dimensional sparse BSR tensors can be constructed from
any two-dimensional tensor using <a class="reference internal" href="generated/torch.Tensor.to_sparse_bsr.html#torch.Tensor.to_sparse_bsr" title="torch.Tensor.to_sparse_bsr"><code class="xref py py-meth docutils literal notranslate"><span class="pre">torch.Tensor.to_sparse_bsr()</span></code></a>
method that also requires the specification of the values block size:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dense</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>                      <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">],</span>
<span class="gp">... </span>                      <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">17</span><span class="p">],</span>
<span class="gp">... </span>                      <span class="p">[</span><span class="mi">18</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">23</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bsr</span> <span class="o">=</span> <span class="n">dense</span><span class="o">.</span><span class="n">to_sparse_bsr</span><span class="p">(</span><span class="n">blocksize</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bsr</span>
<span class="go">tensor(crow_indices=tensor([0, 2, 4]),</span>
<span class="go">       col_indices=tensor([0, 1, 0, 1]),</span>
<span class="go">       values=tensor([[[ 0,  1,  2],</span>
<span class="go">                       [ 6,  7,  8]],</span>
<span class="go">                      [[ 3,  4,  5],</span>
<span class="go">                       [ 9, 10, 11]],</span>
<span class="go">                      [[12, 13, 14],</span>
<span class="go">                       [18, 19, 20]],</span>
<span class="go">                      [[15, 16, 17],</span>
<span class="go">                       [21, 22, 23]]]), size=(4, 6), nnz=4,</span>
<span class="go">       layout=torch.sparse_bsr)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="sparse-bsc-tensor">
<span id="sparse-bsc-docs"></span><h3>Sparse BSC Tensor<a class="headerlink" href="#sparse-bsc-tensor" title="Permalink to this heading">¶</a></h3>
<p>The sparse BSC (Block compressed Sparse Column) tensor format implements the
BSC format for storage of two-dimensional tensors with an extension to
supporting batches of sparse BSC tensors and values being blocks of
multi-dimensional tensors.</p>
<p>A sparse BSC tensor consists of three tensors: <code class="docutils literal notranslate"><span class="pre">ccol_indices</span></code>,
<code class="docutils literal notranslate"><span class="pre">row_indices</span></code> and <code class="docutils literal notranslate"><span class="pre">values</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">ccol_indices</span></code> tensor consists of compressed column
indices. This is a (B + 1)-D tensor of shape <code class="docutils literal notranslate"><span class="pre">(*batchsize,</span>
<span class="pre">ncolblocks</span> <span class="pre">+</span> <span class="pre">1)</span></code>.  The last element is the number of specified blocks,
<code class="docutils literal notranslate"><span class="pre">nse</span></code>. This tensor encodes the index in <code class="docutils literal notranslate"><span class="pre">values</span></code> and
<code class="docutils literal notranslate"><span class="pre">row_indices</span></code> depending on where the given row block
starts. Each successive number in the tensor subtracted by the
number before it denotes the number of blocks in a given column.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">row_indices</span></code> tensor contains the row block indices of each
element. This is a (B + 1)-D tensor of shape <code class="docutils literal notranslate"><span class="pre">(*batchsize,</span>
<span class="pre">nse)</span></code>.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">values</span></code> tensor contains the values of the sparse BSC tensor
elements collected into two-dimensional blocks. This is a (1 + 2 +
K)-D tensor of shape <code class="docutils literal notranslate"><span class="pre">(nse,</span> <span class="pre">nrowblocks,</span> <span class="pre">ncolblocks,</span>
<span class="pre">*densesize)</span></code>.</p></li>
</ul>
</div></blockquote>
<div class="section" id="construction-of-bsc-tensors">
<h4>Construction of BSC tensors<a class="headerlink" href="#construction-of-bsc-tensors" title="Permalink to this heading">¶</a></h4>
<p>Sparse BSC tensors can be directly constructed by using the
<a class="reference internal" href="generated/torch.sparse_bsc_tensor.html#torch.sparse_bsc_tensor" title="torch.sparse_bsc_tensor"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.sparse_bsc_tensor()</span></code></a> function. The user must supply the row
and column block indices and values tensors separately where the column block indices
must be specified using the CSR compression encoding.
The <code class="docutils literal notranslate"><span class="pre">size</span></code> argument is optional and will be deduced from the <code class="docutils literal notranslate"><span class="pre">ccol_indices</span></code> and
<code class="docutils literal notranslate"><span class="pre">row_indices</span></code> tensors if it is not present.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ccol_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]],</span>
<span class="gp">... </span>                       <span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">]],</span>
<span class="gp">... </span>                       <span class="p">[[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">],</span> <span class="p">[</span><span class="mi">18</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">20</span><span class="p">]],</span>
<span class="gp">... </span>                       <span class="p">[[</span><span class="mi">15</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">17</span><span class="p">],</span> <span class="p">[</span><span class="mi">21</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">23</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bsc</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sparse_bsc_tensor</span><span class="p">(</span><span class="n">ccol_indices</span><span class="p">,</span> <span class="n">row_indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bsc</span>
<span class="go">tensor(ccol_indices=tensor([0, 2, 4]),</span>
<span class="go">       row_indices=tensor([0, 1, 0, 1]),</span>
<span class="go">       values=tensor([[[ 0.,  1.,  2.],</span>
<span class="go">                       [ 6.,  7.,  8.]],</span>
<span class="go">                      [[ 3.,  4.,  5.],</span>
<span class="go">                       [ 9., 10., 11.]],</span>
<span class="go">                      [[12., 13., 14.],</span>
<span class="go">                       [18., 19., 20.]],</span>
<span class="go">                      [[15., 16., 17.],</span>
<span class="go">                       [21., 22., 23.]]]), size=(4, 6), nnz=4,</span>
<span class="go">       dtype=torch.float64, layout=torch.sparse_bsc)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="tools-for-working-with-sparse-compressed-tensors">
<h3>Tools for working with sparse compressed tensors<a class="headerlink" href="#tools-for-working-with-sparse-compressed-tensors" title="Permalink to this heading">¶</a></h3>
<p>All sparse compressed tensors — CSR, CSC, BSR, and BSC tensors —
are conceptionally very similar in that their indices data is split
into two parts: so-called compressed indices that use the CSR
encoding, and so-called plain indices that are orthogonal to the
compressed indices. This allows various tools on these tensors to
share the same implementations that are parameterized by tensor
layout.</p>
<div class="section" id="construction-of-sparse-compressed-tensors">
<h4>Construction of sparse compressed tensors<a class="headerlink" href="#construction-of-sparse-compressed-tensors" title="Permalink to this heading">¶</a></h4>
<p>Sparse CSR, CSC, BSR, and CSC tensors can be constructed by using
<a class="reference internal" href="generated/torch.sparse_compressed_tensor.html#torch.sparse_compressed_tensor" title="torch.sparse_compressed_tensor"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.sparse_compressed_tensor()</span></code></a> function that have the same
interface as the above discussed constructor functions
<a class="reference internal" href="generated/torch.sparse_csr_tensor.html#torch.sparse_csr_tensor" title="torch.sparse_csr_tensor"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.sparse_csr_tensor()</span></code></a>, <a class="reference internal" href="generated/torch.sparse_csc_tensor.html#torch.sparse_csc_tensor" title="torch.sparse_csc_tensor"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.sparse_csc_tensor()</span></code></a>,
<a class="reference internal" href="generated/torch.sparse_bsr_tensor.html#torch.sparse_bsr_tensor" title="torch.sparse_bsr_tensor"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.sparse_bsr_tensor()</span></code></a>, and <a class="reference internal" href="generated/torch.sparse_bsc_tensor.html#torch.sparse_bsc_tensor" title="torch.sparse_bsc_tensor"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.sparse_bsc_tensor()</span></code></a>,
respectively, but with an extra required <code class="docutils literal notranslate"><span class="pre">layout</span></code> argument. The
following example illustrates a method of constructing CSR and CSC
tensors using the same input data by specifying the corresponding
layout parameter to the <a class="reference internal" href="generated/torch.sparse_compressed_tensor.html#torch.sparse_compressed_tensor" title="torch.sparse_compressed_tensor"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.sparse_compressed_tensor()</span></code></a>
function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">compressed_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plain_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">csr</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sparse_compressed_tensor</span><span class="p">(</span><span class="n">compressed_indices</span><span class="p">,</span> <span class="n">plain_indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">layout</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">sparse_csr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">csr</span>
<span class="go">tensor(crow_indices=tensor([0, 2, 4]),</span>
<span class="go">       col_indices=tensor([0, 1, 0, 1]),</span>
<span class="go">       values=tensor([1, 2, 3, 4]), size=(2, 2), nnz=4,</span>
<span class="go">       layout=torch.sparse_csr)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">csc</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sparse_compressed_tensor</span><span class="p">(</span><span class="n">compressed_indices</span><span class="p">,</span> <span class="n">plain_indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">layout</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">sparse_csc</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">csc</span>
<span class="go">tensor(ccol_indices=tensor([0, 2, 4]),</span>
<span class="go">       row_indices=tensor([0, 1, 0, 1]),</span>
<span class="go">       values=tensor([1, 2, 3, 4]), size=(2, 2), nnz=4,</span>
<span class="go">       layout=torch.sparse_csc)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">csr</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">to_dense</span><span class="p">()</span> <span class="o">==</span> <span class="n">csc</span><span class="o">.</span><span class="n">to_dense</span><span class="p">())</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="go">tensor(True)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="supported-operations">
<span id="sparse-ops-docs"></span><h2>Supported operations<a class="headerlink" href="#supported-operations" title="Permalink to this heading">¶</a></h2>
<div class="section" id="linear-algebra-operations">
<h3>Linear Algebra operations<a class="headerlink" href="#linear-algebra-operations" title="Permalink to this heading">¶</a></h3>
<p>The following table summarizes supported Linear Algebra operations on
sparse matrices where the operands layouts may vary. Here
<code class="docutils literal notranslate"><span class="pre">T[layout]</span></code> denotes a tensor with a given layout. Similarly,
<code class="docutils literal notranslate"><span class="pre">M[layout]</span></code> denotes a matrix (2-D PyTorch tensor), and <code class="docutils literal notranslate"><span class="pre">V[layout]</span></code>
denotes a vector (1-D PyTorch tensor). In addition, <code class="docutils literal notranslate"><span class="pre">f</span></code> denotes a
scalar (float or 0-D PyTorch tensor), <code class="docutils literal notranslate"><span class="pre">*</span></code> is element-wise
multiplication, and <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> is matrix multiplication.</p>
<table class="colwidths-given docutils colwidths-auto align-default">
<colgroup>
<col style="width: 24%" />
<col style="width: 6%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>PyTorch operation</p></th>
<th class="head"><p>Sparse grad?</p></th>
<th class="head"><p>Layout signature</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="generated/torch.mv.html#torch.mv" title="torch.mv"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.mv()</span></code></a></p></td>
<td><p>no</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">M[sparse_coo]</span> <span class="pre">&#64;</span> <span class="pre">V[strided]</span> <span class="pre">-&gt;</span> <span class="pre">V[strided]</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/torch.mv.html#torch.mv" title="torch.mv"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.mv()</span></code></a></p></td>
<td><p>no</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">M[sparse_csr]</span> <span class="pre">&#64;</span> <span class="pre">V[strided]</span> <span class="pre">-&gt;</span> <span class="pre">V[strided]</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/torch.matmul.html#torch.matmul" title="torch.matmul"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.matmul()</span></code></a></p></td>
<td><p>no</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">M[sparse_coo]</span> <span class="pre">&#64;</span> <span class="pre">M[strided]</span> <span class="pre">-&gt;</span> <span class="pre">M[strided]</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/torch.matmul.html#torch.matmul" title="torch.matmul"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.matmul()</span></code></a></p></td>
<td><p>no</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">M[sparse_csr]</span> <span class="pre">&#64;</span> <span class="pre">M[strided]</span> <span class="pre">-&gt;</span> <span class="pre">M[strided]</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/torch.matmul.html#torch.matmul" title="torch.matmul"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.matmul()</span></code></a></p></td>
<td><p>no</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">M[SparseSemiStructured]</span> <span class="pre">&#64;</span> <span class="pre">M[strided]</span> <span class="pre">-&gt;</span> <span class="pre">M[strided]</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/torch.matmul.html#torch.matmul" title="torch.matmul"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.matmul()</span></code></a></p></td>
<td><p>no</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">M[strided]</span> <span class="pre">&#64;</span> <span class="pre">M[SparseSemiStructured]</span> <span class="pre">-&gt;</span> <span class="pre">M[strided]</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/torch.mm.html#torch.mm" title="torch.mm"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.mm()</span></code></a></p></td>
<td><p>no</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">M[sparse_coo]</span> <span class="pre">&#64;</span> <span class="pre">M[strided]</span> <span class="pre">-&gt;</span> <span class="pre">M[strided]</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/torch.mm.html#torch.mm" title="torch.mm"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.mm()</span></code></a></p></td>
<td><p>no</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">M[SparseSemiStructured]</span> <span class="pre">&#64;</span> <span class="pre">M[strided]</span> <span class="pre">-&gt;</span> <span class="pre">M[strided]</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/torch.mm.html#torch.mm" title="torch.mm"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.mm()</span></code></a></p></td>
<td><p>no</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">M[strided]</span> <span class="pre">&#64;</span> <span class="pre">M[SparseSemiStructured]</span> <span class="pre">-&gt;</span> <span class="pre">M[strided]</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/torch.sparse.mm.html#torch.sparse.mm" title="torch.sparse.mm"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.sparse.mm()</span></code></a></p></td>
<td><p>yes</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">M[sparse_coo]</span> <span class="pre">&#64;</span> <span class="pre">M[strided]</span> <span class="pre">-&gt;</span> <span class="pre">M[strided]</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/torch.smm.html#torch.smm" title="torch.smm"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.smm()</span></code></a></p></td>
<td><p>no</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">M[sparse_coo]</span> <span class="pre">&#64;</span> <span class="pre">M[strided]</span> <span class="pre">-&gt;</span> <span class="pre">M[sparse_coo]</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/torch.hspmm.html#torch.hspmm" title="torch.hspmm"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.hspmm()</span></code></a></p></td>
<td><p>no</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">M[sparse_coo]</span> <span class="pre">&#64;</span> <span class="pre">M[strided]</span> <span class="pre">-&gt;</span> <span class="pre">M[hybrid</span> <span class="pre">sparse_coo]</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/torch.bmm.html#torch.bmm" title="torch.bmm"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.bmm()</span></code></a></p></td>
<td><p>no</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T[sparse_coo]</span> <span class="pre">&#64;</span> <span class="pre">T[strided]</span> <span class="pre">-&gt;</span> <span class="pre">T[strided]</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/torch.addmm.html#torch.addmm" title="torch.addmm"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.addmm()</span></code></a></p></td>
<td><p>no</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">*</span> <span class="pre">M[strided]</span> <span class="pre">+</span> <span class="pre">f</span> <span class="pre">*</span> <span class="pre">(M[sparse_coo]</span> <span class="pre">&#64;</span> <span class="pre">M[strided])</span> <span class="pre">-&gt;</span> <span class="pre">M[strided]</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/torch.addmm.html#torch.addmm" title="torch.addmm"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.addmm()</span></code></a></p></td>
<td><p>no</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">*</span> <span class="pre">M[strided]</span> <span class="pre">+</span> <span class="pre">f</span> <span class="pre">*</span> <span class="pre">(M[SparseSemiStructured]</span> <span class="pre">&#64;</span> <span class="pre">M[strided])</span> <span class="pre">-&gt;</span> <span class="pre">M[strided]</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/torch.addmm.html#torch.addmm" title="torch.addmm"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.addmm()</span></code></a></p></td>
<td><p>no</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">*</span> <span class="pre">M[strided]</span> <span class="pre">+</span> <span class="pre">f</span> <span class="pre">*</span> <span class="pre">(M[strided]</span> <span class="pre">&#64;</span> <span class="pre">M[SparseSemiStructured])</span> <span class="pre">-&gt;</span> <span class="pre">M[strided]</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/torch.sparse.addmm.html#torch.sparse.addmm" title="torch.sparse.addmm"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.sparse.addmm()</span></code></a></p></td>
<td><p>yes</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">*</span> <span class="pre">M[strided]</span> <span class="pre">+</span> <span class="pre">f</span> <span class="pre">*</span> <span class="pre">(M[sparse_coo]</span> <span class="pre">&#64;</span> <span class="pre">M[strided])</span> <span class="pre">-&gt;</span> <span class="pre">M[strided]</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/torch.sspaddmm.html#torch.sspaddmm" title="torch.sspaddmm"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.sspaddmm()</span></code></a></p></td>
<td><p>no</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">*</span> <span class="pre">M[sparse_coo]</span> <span class="pre">+</span> <span class="pre">f</span> <span class="pre">*</span> <span class="pre">(M[sparse_coo]</span> <span class="pre">&#64;</span> <span class="pre">M[strided])</span> <span class="pre">-&gt;</span> <span class="pre">M[sparse_coo]</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/torch.lobpcg.html#torch.lobpcg" title="torch.lobpcg"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.lobpcg()</span></code></a></p></td>
<td><p>no</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">GENEIG(M[sparse_coo])</span> <span class="pre">-&gt;</span> <span class="pre">M[strided],</span> <span class="pre">M[strided]</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/torch.pca_lowrank.html#torch.pca_lowrank" title="torch.pca_lowrank"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.pca_lowrank()</span></code></a></p></td>
<td><p>yes</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">PCA(M[sparse_coo])</span> <span class="pre">-&gt;</span> <span class="pre">M[strided],</span> <span class="pre">M[strided],</span> <span class="pre">M[strided]</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/torch.svd_lowrank.html#torch.svd_lowrank" title="torch.svd_lowrank"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.svd_lowrank()</span></code></a></p></td>
<td><p>yes</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SVD(M[sparse_coo])</span> <span class="pre">-&gt;</span> <span class="pre">M[strided],</span> <span class="pre">M[strided],</span> <span class="pre">M[strided]</span></code></p></td>
</tr>
</tbody>
</table>
<p>where “Sparse grad?” column indicates if the PyTorch operation supports
backward with respect to sparse matrix argument. All PyTorch operations,
except <a class="reference internal" href="generated/torch.smm.html#torch.smm" title="torch.smm"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.smm()</span></code></a>, support backward with respect to strided
matrix arguments.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, PyTorch does not support matrix multiplication with the
layout signature <code class="docutils literal notranslate"><span class="pre">M[strided]</span> <span class="pre">&#64;</span> <span class="pre">M[sparse_coo]</span></code>. However,
applications can still compute this using the matrix relation <code class="docutils literal notranslate"><span class="pre">D</span> <span class="pre">&#64;</span>
<span class="pre">S</span> <span class="pre">==</span> <span class="pre">(S.t()</span> <span class="pre">&#64;</span> <span class="pre">D.t()).t()</span></code>.</p>
</div>
</div>
<div class="section" id="tensor-methods-and-sparse">
<h3>Tensor methods and sparse<a class="headerlink" href="#tensor-methods-and-sparse" title="Permalink to this heading">¶</a></h3>
<p>The following Tensor methods are related to sparse tensors:</p>
<table class="autosummary longtable docutils colwidths-auto align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/torch.Tensor.is_sparse.html#torch.Tensor.is_sparse" title="torch.Tensor.is_sparse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tensor.is_sparse</span></code></a></p></td>
<td><p>Is <code class="docutils literal notranslate"><span class="pre">True</span></code> if the Tensor uses sparse COO storage layout, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/torch.Tensor.is_sparse_csr.html#torch.Tensor.is_sparse_csr" title="torch.Tensor.is_sparse_csr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tensor.is_sparse_csr</span></code></a></p></td>
<td><p>Is <code class="docutils literal notranslate"><span class="pre">True</span></code> if the Tensor uses sparse CSR storage layout, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/torch.Tensor.dense_dim.html#torch.Tensor.dense_dim" title="torch.Tensor.dense_dim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tensor.dense_dim</span></code></a></p></td>
<td><p>Return the number of dense dimensions in a <a class="reference internal" href="#sparse-docs"><span class="std std-ref">sparse tensor</span></a> <code class="xref py py-attr docutils literal notranslate"><span class="pre">self</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/torch.Tensor.sparse_dim.html#torch.Tensor.sparse_dim" title="torch.Tensor.sparse_dim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tensor.sparse_dim</span></code></a></p></td>
<td><p>Return the number of sparse dimensions in a <a class="reference internal" href="#sparse-docs"><span class="std std-ref">sparse tensor</span></a> <code class="xref py py-attr docutils literal notranslate"><span class="pre">self</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/torch.Tensor.sparse_mask.html#torch.Tensor.sparse_mask" title="torch.Tensor.sparse_mask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tensor.sparse_mask</span></code></a></p></td>
<td><p>Returns a new <a class="reference internal" href="#sparse-docs"><span class="std std-ref">sparse tensor</span></a> with values from a strided tensor <code class="xref py py-attr docutils literal notranslate"><span class="pre">self</span></code> filtered by the indices of the sparse tensor <code class="xref py py-attr docutils literal notranslate"><span class="pre">mask</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/torch.Tensor.to_sparse.html#torch.Tensor.to_sparse" title="torch.Tensor.to_sparse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tensor.to_sparse</span></code></a></p></td>
<td><p>Returns a sparse copy of the tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/torch.Tensor.to_sparse_coo.html#torch.Tensor.to_sparse_coo" title="torch.Tensor.to_sparse_coo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tensor.to_sparse_coo</span></code></a></p></td>
<td><p>Convert a tensor to <a class="reference internal" href="#sparse-coo-docs"><span class="std std-ref">coordinate format</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/torch.Tensor.to_sparse_csr.html#torch.Tensor.to_sparse_csr" title="torch.Tensor.to_sparse_csr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tensor.to_sparse_csr</span></code></a></p></td>
<td><p>Convert a tensor to compressed row storage format (CSR).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/torch.Tensor.to_sparse_csc.html#torch.Tensor.to_sparse_csc" title="torch.Tensor.to_sparse_csc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tensor.to_sparse_csc</span></code></a></p></td>
<td><p>Convert a tensor to compressed column storage (CSC) format.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/torch.Tensor.to_sparse_bsr.html#torch.Tensor.to_sparse_bsr" title="torch.Tensor.to_sparse_bsr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tensor.to_sparse_bsr</span></code></a></p></td>
<td><p>Convert a tensor to a block sparse row (BSR) storage format of given blocksize.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/torch.Tensor.to_sparse_bsc.html#torch.Tensor.to_sparse_bsc" title="torch.Tensor.to_sparse_bsc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tensor.to_sparse_bsc</span></code></a></p></td>
<td><p>Convert a tensor to a block sparse column (BSC) storage format of given blocksize.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/torch.Tensor.to_dense.html#torch.Tensor.to_dense" title="torch.Tensor.to_dense"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tensor.to_dense</span></code></a></p></td>
<td><p>Creates a strided copy of <code class="xref py py-attr docutils literal notranslate"><span class="pre">self</span></code> if <code class="xref py py-attr docutils literal notranslate"><span class="pre">self</span></code> is not a strided tensor, otherwise returns <code class="xref py py-attr docutils literal notranslate"><span class="pre">self</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/torch.Tensor.values.html#torch.Tensor.values" title="torch.Tensor.values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tensor.values</span></code></a></p></td>
<td><p>Return the values tensor of a <a class="reference internal" href="#sparse-coo-docs"><span class="std std-ref">sparse COO tensor</span></a>.</p></td>
</tr>
</tbody>
</table>
<p>The following Tensor methods are specific to sparse COO tensors:</p>
<table class="autosummary longtable docutils colwidths-auto align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/torch.Tensor.coalesce.html#torch.Tensor.coalesce" title="torch.Tensor.coalesce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tensor.coalesce</span></code></a></p></td>
<td><p>Returns a coalesced copy of <code class="xref py py-attr docutils literal notranslate"><span class="pre">self</span></code> if <code class="xref py py-attr docutils literal notranslate"><span class="pre">self</span></code> is an <a class="reference internal" href="#sparse-uncoalesced-coo-docs"><span class="std std-ref">uncoalesced tensor</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/torch.Tensor.sparse_resize_.html#torch.Tensor.sparse_resize_" title="torch.Tensor.sparse_resize_"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tensor.sparse_resize_</span></code></a></p></td>
<td><p>Resizes <code class="xref py py-attr docutils literal notranslate"><span class="pre">self</span></code> <a class="reference internal" href="#sparse-docs"><span class="std std-ref">sparse tensor</span></a> to the desired size and the number of sparse and dense dimensions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/torch.Tensor.sparse_resize_and_clear_.html#torch.Tensor.sparse_resize_and_clear_" title="torch.Tensor.sparse_resize_and_clear_"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tensor.sparse_resize_and_clear_</span></code></a></p></td>
<td><p>Removes all specified elements from a <a class="reference internal" href="#sparse-docs"><span class="std std-ref">sparse tensor</span></a> <code class="xref py py-attr docutils literal notranslate"><span class="pre">self</span></code> and resizes <code class="xref py py-attr docutils literal notranslate"><span class="pre">self</span></code> to the desired size and the number of sparse and dense dimensions.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/torch.Tensor.is_coalesced.html#torch.Tensor.is_coalesced" title="torch.Tensor.is_coalesced"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tensor.is_coalesced</span></code></a></p></td>
<td><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="xref py py-attr docutils literal notranslate"><span class="pre">self</span></code> is a <a class="reference internal" href="#sparse-coo-docs"><span class="std std-ref">sparse COO tensor</span></a> that is coalesced, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/torch.Tensor.indices.html#torch.Tensor.indices" title="torch.Tensor.indices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tensor.indices</span></code></a></p></td>
<td><p>Return the indices tensor of a <a class="reference internal" href="#sparse-coo-docs"><span class="std std-ref">sparse COO tensor</span></a>.</p></td>
</tr>
</tbody>
</table>
<p>The following methods are specific to <a class="reference internal" href="#sparse-csr-docs"><span class="std std-ref">sparse CSR tensors</span></a> and <a class="reference internal" href="#sparse-bsr-docs"><span class="std std-ref">sparse BSR tensors</span></a>:</p>
<table class="autosummary longtable docutils colwidths-auto align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/torch.Tensor.crow_indices.html#torch.Tensor.crow_indices" title="torch.Tensor.crow_indices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tensor.crow_indices</span></code></a></p></td>
<td><p>Returns the tensor containing the compressed row indices of the <code class="xref py py-attr docutils literal notranslate"><span class="pre">self</span></code> tensor when <code class="xref py py-attr docutils literal notranslate"><span class="pre">self</span></code> is a sparse CSR tensor of layout <code class="docutils literal notranslate"><span class="pre">sparse_csr</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/torch.Tensor.col_indices.html#torch.Tensor.col_indices" title="torch.Tensor.col_indices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tensor.col_indices</span></code></a></p></td>
<td><p>Returns the tensor containing the column indices of the <code class="xref py py-attr docutils literal notranslate"><span class="pre">self</span></code> tensor when <code class="xref py py-attr docutils literal notranslate"><span class="pre">self</span></code> is a sparse CSR tensor of layout <code class="docutils literal notranslate"><span class="pre">sparse_csr</span></code>.</p></td>
</tr>
</tbody>
</table>
<p>The following methods are specific to <a class="reference internal" href="#sparse-csc-docs"><span class="std std-ref">sparse CSC tensors</span></a> and <a class="reference internal" href="#sparse-bsc-docs"><span class="std std-ref">sparse BSC tensors</span></a>:</p>
<table class="autosummary longtable docutils colwidths-auto align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/torch.Tensor.row_indices.html#torch.Tensor.row_indices" title="torch.Tensor.row_indices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tensor.row_indices</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/torch.Tensor.ccol_indices.html#torch.Tensor.ccol_indices" title="torch.Tensor.ccol_indices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tensor.ccol_indices</span></code></a></p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<p>The following Tensor methods support sparse COO tensors:</p>
<p><a class="reference internal" href="generated/torch.Tensor.add.html#torch.Tensor.add" title="torch.Tensor.add"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.add_.html#torch.Tensor.add_" title="torch.Tensor.add_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.addmm.html#torch.Tensor.addmm" title="torch.Tensor.addmm"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addmm()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.addmm_.html#torch.Tensor.addmm_" title="torch.Tensor.addmm_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addmm_()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.any.html#torch.Tensor.any" title="torch.Tensor.any"><code class="xref py py-meth docutils literal notranslate"><span class="pre">any()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.asin.html#torch.Tensor.asin" title="torch.Tensor.asin"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asin()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.asin_.html#torch.Tensor.asin_" title="torch.Tensor.asin_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asin_()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.arcsin.html#torch.Tensor.arcsin" title="torch.Tensor.arcsin"><code class="xref py py-meth docutils literal notranslate"><span class="pre">arcsin()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.arcsin_.html#torch.Tensor.arcsin_" title="torch.Tensor.arcsin_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">arcsin_()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.bmm.html#torch.Tensor.bmm" title="torch.Tensor.bmm"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bmm()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.clone.html#torch.Tensor.clone" title="torch.Tensor.clone"><code class="xref py py-meth docutils literal notranslate"><span class="pre">clone()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.deg2rad.html#torch.Tensor.deg2rad" title="torch.Tensor.deg2rad"><code class="xref py py-meth docutils literal notranslate"><span class="pre">deg2rad()</span></code></a>
<code class="xref py py-meth docutils literal notranslate"><span class="pre">deg2rad_()</span></code>
<a class="reference internal" href="generated/torch.Tensor.detach.html#torch.Tensor.detach" title="torch.Tensor.detach"><code class="xref py py-meth docutils literal notranslate"><span class="pre">detach()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.detach_.html#torch.Tensor.detach_" title="torch.Tensor.detach_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">detach_()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.dim.html#torch.Tensor.dim" title="torch.Tensor.dim"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dim()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.div.html#torch.Tensor.div" title="torch.Tensor.div"><code class="xref py py-meth docutils literal notranslate"><span class="pre">div()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.div_.html#torch.Tensor.div_" title="torch.Tensor.div_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">div_()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.floor_divide.html#torch.Tensor.floor_divide" title="torch.Tensor.floor_divide"><code class="xref py py-meth docutils literal notranslate"><span class="pre">floor_divide()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.floor_divide_.html#torch.Tensor.floor_divide_" title="torch.Tensor.floor_divide_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">floor_divide_()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.get_device.html#torch.Tensor.get_device" title="torch.Tensor.get_device"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_device()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.index_select.html#torch.Tensor.index_select" title="torch.Tensor.index_select"><code class="xref py py-meth docutils literal notranslate"><span class="pre">index_select()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.isnan.html#torch.Tensor.isnan" title="torch.Tensor.isnan"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isnan()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.log1p.html#torch.Tensor.log1p" title="torch.Tensor.log1p"><code class="xref py py-meth docutils literal notranslate"><span class="pre">log1p()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.log1p_.html#torch.Tensor.log1p_" title="torch.Tensor.log1p_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">log1p_()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.mm.html#torch.Tensor.mm" title="torch.Tensor.mm"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mm()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.mul.html#torch.Tensor.mul" title="torch.Tensor.mul"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mul()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.mul_.html#torch.Tensor.mul_" title="torch.Tensor.mul_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mul_()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.mv.html#torch.Tensor.mv" title="torch.Tensor.mv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mv()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.narrow_copy.html#torch.Tensor.narrow_copy" title="torch.Tensor.narrow_copy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">narrow_copy()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.neg.html#torch.Tensor.neg" title="torch.Tensor.neg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">neg()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.neg_.html#torch.Tensor.neg_" title="torch.Tensor.neg_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">neg_()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.negative.html#torch.Tensor.negative" title="torch.Tensor.negative"><code class="xref py py-meth docutils literal notranslate"><span class="pre">negative()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.negative_.html#torch.Tensor.negative_" title="torch.Tensor.negative_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">negative_()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.numel.html#torch.Tensor.numel" title="torch.Tensor.numel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">numel()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.rad2deg.html#torch.Tensor.rad2deg" title="torch.Tensor.rad2deg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rad2deg()</span></code></a>
<code class="xref py py-meth docutils literal notranslate"><span class="pre">rad2deg_()</span></code>
<a class="reference internal" href="generated/torch.Tensor.resize_as_.html#torch.Tensor.resize_as_" title="torch.Tensor.resize_as_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">resize_as_()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.size.html#torch.Tensor.size" title="torch.Tensor.size"><code class="xref py py-meth docutils literal notranslate"><span class="pre">size()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.pow.html#torch.Tensor.pow" title="torch.Tensor.pow"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pow()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.sqrt.html#torch.Tensor.sqrt" title="torch.Tensor.sqrt"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sqrt()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.square.html#torch.Tensor.square" title="torch.Tensor.square"><code class="xref py py-meth docutils literal notranslate"><span class="pre">square()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.smm.html#torch.Tensor.smm" title="torch.Tensor.smm"><code class="xref py py-meth docutils literal notranslate"><span class="pre">smm()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.sspaddmm.html#torch.Tensor.sspaddmm" title="torch.Tensor.sspaddmm"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sspaddmm()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.sub.html#torch.Tensor.sub" title="torch.Tensor.sub"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sub()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.sub_.html#torch.Tensor.sub_" title="torch.Tensor.sub_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sub_()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.t.html#torch.Tensor.t" title="torch.Tensor.t"><code class="xref py py-meth docutils literal notranslate"><span class="pre">t()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.t_.html#torch.Tensor.t_" title="torch.Tensor.t_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">t_()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.transpose.html#torch.Tensor.transpose" title="torch.Tensor.transpose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transpose()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.transpose_.html#torch.Tensor.transpose_" title="torch.Tensor.transpose_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transpose_()</span></code></a>
<a class="reference internal" href="generated/torch.Tensor.zero_.html#torch.Tensor.zero_" title="torch.Tensor.zero_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">zero_()</span></code></a></p>
</div>
<div class="section" id="torch-functions-specific-to-sparse-tensors">
<h3>Torch functions specific to sparse Tensors<a class="headerlink" href="#torch-functions-specific-to-sparse-tensors" title="Permalink to this heading">¶</a></h3>
<table class="autosummary longtable docutils colwidths-auto align-default">
<tbody>
<tr class="row-odd"><td><p><p id="torch.sparse_coo_tensor"/><a class="reference internal" href="generated/torch.sparse_coo_tensor.html#torch.sparse_coo_tensor" title="torch.sparse_coo_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse_coo_tensor</span></code></a></p></td>
<td><p>Constructs a <a class="reference internal" href="#sparse-coo-docs"><span class="std std-ref">sparse tensor in COO(rdinate) format</span></a> with specified values at the given <code class="xref py py-attr docutils literal notranslate"><span class="pre">indices</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><p id="torch.sparse_csr_tensor"/><a class="reference internal" href="generated/torch.sparse_csr_tensor.html#torch.sparse_csr_tensor" title="torch.sparse_csr_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse_csr_tensor</span></code></a></p></td>
<td><p>Constructs a <a class="reference internal" href="#sparse-csr-docs"><span class="std std-ref">sparse tensor in CSR (Compressed Sparse Row)</span></a> with specified values at the given <code class="xref py py-attr docutils literal notranslate"><span class="pre">crow_indices</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">col_indices</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><p id="torch.sparse_csc_tensor"/><a class="reference internal" href="generated/torch.sparse_csc_tensor.html#torch.sparse_csc_tensor" title="torch.sparse_csc_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse_csc_tensor</span></code></a></p></td>
<td><p>Constructs a <a class="reference internal" href="#sparse-csc-docs"><span class="std std-ref">sparse tensor in CSC (Compressed Sparse Column)</span></a> with specified values at the given <code class="xref py py-attr docutils literal notranslate"><span class="pre">ccol_indices</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">row_indices</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><p id="torch.sparse_bsr_tensor"/><a class="reference internal" href="generated/torch.sparse_bsr_tensor.html#torch.sparse_bsr_tensor" title="torch.sparse_bsr_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse_bsr_tensor</span></code></a></p></td>
<td><p>Constructs a <a class="reference internal" href="#sparse-bsr-docs"><span class="std std-ref">sparse tensor in BSR (Block Compressed Sparse Row))</span></a> with specified 2-dimensional blocks at the given <code class="xref py py-attr docutils literal notranslate"><span class="pre">crow_indices</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">col_indices</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><p id="torch.sparse_bsc_tensor"/><a class="reference internal" href="generated/torch.sparse_bsc_tensor.html#torch.sparse_bsc_tensor" title="torch.sparse_bsc_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse_bsc_tensor</span></code></a></p></td>
<td><p>Constructs a <a class="reference internal" href="#sparse-bsc-docs"><span class="std std-ref">sparse tensor in BSC (Block Compressed Sparse Column))</span></a> with specified 2-dimensional blocks at the given <code class="xref py py-attr docutils literal notranslate"><span class="pre">ccol_indices</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">row_indices</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><p id="torch.sparse_compressed_tensor"/><a class="reference internal" href="generated/torch.sparse_compressed_tensor.html#torch.sparse_compressed_tensor" title="torch.sparse_compressed_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse_compressed_tensor</span></code></a></p></td>
<td><p>Constructs a <a class="reference internal" href="#sparse-compressed-docs"><span class="std std-ref">sparse tensor in Compressed Sparse format - CSR, CSC, BSR, or BSC -</span></a> with specified values at the given <code class="xref py py-attr docutils literal notranslate"><span class="pre">compressed_indices</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">plain_indices</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/torch.sparse.sum.html#torch.sparse.sum" title="torch.sparse.sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse.sum</span></code></a></p></td>
<td><p>Returns the sum of each row of the sparse tensor <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code> in the given dimensions <code class="xref py py-attr docutils literal notranslate"><span class="pre">dim</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/torch.sparse.addmm.html#torch.sparse.addmm" title="torch.sparse.addmm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse.addmm</span></code></a></p></td>
<td><p>This function does exact same thing as <a class="reference internal" href="generated/torch.addmm.html#torch.addmm" title="torch.addmm"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.addmm()</span></code></a> in the forward, except that it supports backward for sparse COO matrix <code class="xref py py-attr docutils literal notranslate"><span class="pre">mat1</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/torch.sparse.sampled_addmm.html#torch.sparse.sampled_addmm" title="torch.sparse.sampled_addmm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse.sampled_addmm</span></code></a></p></td>
<td><p>Performs a matrix multiplication of the dense matrices <code class="xref py py-attr docutils literal notranslate"><span class="pre">mat1</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">mat2</span></code> at the locations specified by the sparsity pattern of <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/torch.sparse.mm.html#torch.sparse.mm" title="torch.sparse.mm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse.mm</span></code></a></p></td>
<td><p>Performs a matrix multiplication of the sparse matrix <code class="xref py py-attr docutils literal notranslate"><span class="pre">mat1</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><p id="torch.sspaddmm"/><a class="reference internal" href="generated/torch.sspaddmm.html#torch.sspaddmm" title="torch.sspaddmm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sspaddmm</span></code></a></p></td>
<td><p>Matrix multiplies a sparse tensor <code class="xref py py-attr docutils literal notranslate"><span class="pre">mat1</span></code> with a dense tensor <code class="xref py py-attr docutils literal notranslate"><span class="pre">mat2</span></code>, then adds the sparse tensor <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code> to the result.</p></td>
</tr>
<tr class="row-even"><td><p><p id="torch.hspmm"/><a class="reference internal" href="generated/torch.hspmm.html#torch.hspmm" title="torch.hspmm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hspmm</span></code></a></p></td>
<td><p>Performs a matrix multiplication of a <a class="reference internal" href="#sparse-coo-docs"><span class="std std-ref">sparse COO matrix</span></a> <code class="xref py py-attr docutils literal notranslate"><span class="pre">mat1</span></code> and a strided matrix <code class="xref py py-attr docutils literal notranslate"><span class="pre">mat2</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><p id="torch.smm"/><a class="reference internal" href="generated/torch.smm.html#torch.smm" title="torch.smm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">smm</span></code></a></p></td>
<td><p>Performs a matrix multiplication of the sparse matrix <code class="xref py py-attr docutils literal notranslate"><span class="pre">input</span></code> with the dense matrix <code class="xref py py-attr docutils literal notranslate"><span class="pre">mat</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/torch.sparse.softmax.html#torch.sparse.softmax" title="torch.sparse.softmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse.softmax</span></code></a></p></td>
<td><p>Applies a softmax function.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/torch.sparse.log_softmax.html#torch.sparse.log_softmax" title="torch.sparse.log_softmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse.log_softmax</span></code></a></p></td>
<td><p>Applies a softmax function followed by logarithm.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/torch.sparse.spdiags.html#torch.sparse.spdiags" title="torch.sparse.spdiags"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse.spdiags</span></code></a></p></td>
<td><p>Creates a sparse 2D tensor by placing the values from rows of <code class="xref py py-attr docutils literal notranslate"><span class="pre">diagonals</span></code> along specified diagonals of the output</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="other-functions">
<h3>Other functions<a class="headerlink" href="#other-functions" title="Permalink to this heading">¶</a></h3>
<p>The following <a class="reference internal" href="torch.html#module-torch" title="torch"><code class="xref py py-mod docutils literal notranslate"><span class="pre">torch</span></code></a> functions support sparse tensors:</p>
<p><a class="reference internal" href="generated/torch.cat.html#torch.cat" title="torch.cat"><code class="xref py py-func docutils literal notranslate"><span class="pre">cat()</span></code></a>
<a class="reference internal" href="generated/torch.dstack.html#torch.dstack" title="torch.dstack"><code class="xref py py-func docutils literal notranslate"><span class="pre">dstack()</span></code></a>
<a class="reference internal" href="generated/torch.empty.html#torch.empty" title="torch.empty"><code class="xref py py-func docutils literal notranslate"><span class="pre">empty()</span></code></a>
<a class="reference internal" href="generated/torch.empty_like.html#torch.empty_like" title="torch.empty_like"><code class="xref py py-func docutils literal notranslate"><span class="pre">empty_like()</span></code></a>
<a class="reference internal" href="generated/torch.hstack.html#torch.hstack" title="torch.hstack"><code class="xref py py-func docutils literal notranslate"><span class="pre">hstack()</span></code></a>
<a class="reference internal" href="generated/torch.index_select.html#torch.index_select" title="torch.index_select"><code class="xref py py-func docutils literal notranslate"><span class="pre">index_select()</span></code></a>
<a class="reference internal" href="generated/torch.is_complex.html#torch.is_complex" title="torch.is_complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">is_complex()</span></code></a>
<a class="reference internal" href="generated/torch.is_floating_point.html#torch.is_floating_point" title="torch.is_floating_point"><code class="xref py py-func docutils literal notranslate"><span class="pre">is_floating_point()</span></code></a>
<a class="reference internal" href="generated/torch.is_nonzero.html#torch.is_nonzero" title="torch.is_nonzero"><code class="xref py py-func docutils literal notranslate"><span class="pre">is_nonzero()</span></code></a>
<code class="xref py py-func docutils literal notranslate"><span class="pre">is_same_size()</span></code>
<code class="xref py py-func docutils literal notranslate"><span class="pre">is_signed()</span></code>
<a class="reference internal" href="generated/torch.is_tensor.html#torch.is_tensor" title="torch.is_tensor"><code class="xref py py-func docutils literal notranslate"><span class="pre">is_tensor()</span></code></a>
<a class="reference internal" href="generated/torch.lobpcg.html#torch.lobpcg" title="torch.lobpcg"><code class="xref py py-func docutils literal notranslate"><span class="pre">lobpcg()</span></code></a>
<a class="reference internal" href="generated/torch.mm.html#torch.mm" title="torch.mm"><code class="xref py py-func docutils literal notranslate"><span class="pre">mm()</span></code></a>
<code class="xref py py-func docutils literal notranslate"><span class="pre">native_norm()</span></code>
<a class="reference internal" href="generated/torch.pca_lowrank.html#torch.pca_lowrank" title="torch.pca_lowrank"><code class="xref py py-func docutils literal notranslate"><span class="pre">pca_lowrank()</span></code></a>
<a class="reference internal" href="generated/torch.select.html#torch.select" title="torch.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>
<a class="reference internal" href="generated/torch.stack.html#torch.stack" title="torch.stack"><code class="xref py py-func docutils literal notranslate"><span class="pre">stack()</span></code></a>
<a class="reference internal" href="generated/torch.svd_lowrank.html#torch.svd_lowrank" title="torch.svd_lowrank"><code class="xref py py-func docutils literal notranslate"><span class="pre">svd_lowrank()</span></code></a>
<a class="reference internal" href="generated/torch.unsqueeze.html#torch.unsqueeze" title="torch.unsqueeze"><code class="xref py py-func docutils literal notranslate"><span class="pre">unsqueeze()</span></code></a>
<a class="reference internal" href="generated/torch.vstack.html#torch.vstack" title="torch.vstack"><code class="xref py py-func docutils literal notranslate"><span class="pre">vstack()</span></code></a>
<a class="reference internal" href="generated/torch.zeros.html#torch.zeros" title="torch.zeros"><code class="xref py py-func docutils literal notranslate"><span class="pre">zeros()</span></code></a>
<a class="reference internal" href="generated/torch.zeros_like.html#torch.zeros_like" title="torch.zeros_like"><code class="xref py py-func docutils literal notranslate"><span class="pre">zeros_like()</span></code></a></p>
<p>To manage checking sparse tensor invariants, see:</p>
<table class="autosummary longtable docutils colwidths-auto align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/torch.sparse.check_sparse_tensor_invariants.html#torch.sparse.check_sparse_tensor_invariants" title="torch.sparse.check_sparse_tensor_invariants"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse.check_sparse_tensor_invariants</span></code></a></p></td>
<td><p>A tool to control checking sparse tensor invariants.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="unary-functions">
<h3>Unary functions<a class="headerlink" href="#unary-functions" title="Permalink to this heading">¶</a></h3>
<p>We aim to support all zero-preserving unary functions.</p>
<p>If you find that we are missing a zero-preserving unary function
that you need, please feel encouraged to open an issue for a feature request.
As always please kindly try the search function first before opening an issue.</p>
<p>The following operators currently support sparse COO/CSR/CSC/BSR/CSR tensor inputs.</p>
<p><a class="reference internal" href="generated/torch.abs.html#torch.abs" title="torch.abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">abs()</span></code></a>
<a class="reference internal" href="generated/torch.asin.html#torch.asin" title="torch.asin"><code class="xref py py-func docutils literal notranslate"><span class="pre">asin()</span></code></a>
<a class="reference internal" href="generated/torch.asinh.html#torch.asinh" title="torch.asinh"><code class="xref py py-func docutils literal notranslate"><span class="pre">asinh()</span></code></a>
<a class="reference internal" href="generated/torch.atan.html#torch.atan" title="torch.atan"><code class="xref py py-func docutils literal notranslate"><span class="pre">atan()</span></code></a>
<a class="reference internal" href="generated/torch.atanh.html#torch.atanh" title="torch.atanh"><code class="xref py py-func docutils literal notranslate"><span class="pre">atanh()</span></code></a>
<a class="reference internal" href="generated/torch.ceil.html#torch.ceil" title="torch.ceil"><code class="xref py py-func docutils literal notranslate"><span class="pre">ceil()</span></code></a>
<a class="reference internal" href="generated/torch.conj_physical.html#torch.conj_physical" title="torch.conj_physical"><code class="xref py py-func docutils literal notranslate"><span class="pre">conj_physical()</span></code></a>
<a class="reference internal" href="generated/torch.floor.html#torch.floor" title="torch.floor"><code class="xref py py-func docutils literal notranslate"><span class="pre">floor()</span></code></a>
<a class="reference internal" href="generated/torch.log1p.html#torch.log1p" title="torch.log1p"><code class="xref py py-func docutils literal notranslate"><span class="pre">log1p()</span></code></a>
<a class="reference internal" href="generated/torch.neg.html#torch.neg" title="torch.neg"><code class="xref py py-func docutils literal notranslate"><span class="pre">neg()</span></code></a>
<a class="reference internal" href="generated/torch.round.html#torch.round" title="torch.round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a>
<a class="reference internal" href="generated/torch.sin.html#torch.sin" title="torch.sin"><code class="xref py py-func docutils literal notranslate"><span class="pre">sin()</span></code></a>
<a class="reference internal" href="generated/torch.sinh.html#torch.sinh" title="torch.sinh"><code class="xref py py-func docutils literal notranslate"><span class="pre">sinh()</span></code></a>
<a class="reference internal" href="generated/torch.sign.html#torch.sign" title="torch.sign"><code class="xref py py-func docutils literal notranslate"><span class="pre">sign()</span></code></a>
<a class="reference internal" href="generated/torch.sgn.html#torch.sgn" title="torch.sgn"><code class="xref py py-func docutils literal notranslate"><span class="pre">sgn()</span></code></a>
<a class="reference internal" href="generated/torch.signbit.html#torch.signbit" title="torch.signbit"><code class="xref py py-func docutils literal notranslate"><span class="pre">signbit()</span></code></a>
<a class="reference internal" href="generated/torch.tan.html#torch.tan" title="torch.tan"><code class="xref py py-func docutils literal notranslate"><span class="pre">tan()</span></code></a>
<a class="reference internal" href="generated/torch.tanh.html#torch.tanh" title="torch.tanh"><code class="xref py py-func docutils literal notranslate"><span class="pre">tanh()</span></code></a>
<a class="reference internal" href="generated/torch.trunc.html#torch.trunc" title="torch.trunc"><code class="xref py py-func docutils literal notranslate"><span class="pre">trunc()</span></code></a>
<a class="reference internal" href="generated/torch.expm1.html#torch.expm1" title="torch.expm1"><code class="xref py py-func docutils literal notranslate"><span class="pre">expm1()</span></code></a>
<a class="reference internal" href="generated/torch.sqrt.html#torch.sqrt" title="torch.sqrt"><code class="xref py py-func docutils literal notranslate"><span class="pre">sqrt()</span></code></a>
<a class="reference internal" href="generated/torch.angle.html#torch.angle" title="torch.angle"><code class="xref py py-func docutils literal notranslate"><span class="pre">angle()</span></code></a>
<a class="reference internal" href="generated/torch.isinf.html#torch.isinf" title="torch.isinf"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinf()</span></code></a>
<a class="reference internal" href="generated/torch.isposinf.html#torch.isposinf" title="torch.isposinf"><code class="xref py py-func docutils literal notranslate"><span class="pre">isposinf()</span></code></a>
<a class="reference internal" href="generated/torch.isneginf.html#torch.isneginf" title="torch.isneginf"><code class="xref py py-func docutils literal notranslate"><span class="pre">isneginf()</span></code></a>
<a class="reference internal" href="generated/torch.isnan.html#torch.isnan" title="torch.isnan"><code class="xref py py-func docutils literal notranslate"><span class="pre">isnan()</span></code></a>
<a class="reference internal" href="generated/torch.erf.html#torch.erf" title="torch.erf"><code class="xref py py-func docutils literal notranslate"><span class="pre">erf()</span></code></a>
<a class="reference internal" href="generated/torch.erfinv.html#torch.erfinv" title="torch.erfinv"><code class="xref py py-func docutils literal notranslate"><span class="pre">erfinv()</span></code></a></p>
</div>
</div>
</div>


             </article>
             
            </div>
            <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="generated/torch.Tensor.is_sparse_csr.html" class="btn btn-neutral float-right" title="torch.Tensor.is_sparse_csr" accesskey="n" rel="next">Next <img src="_static/images/chevron-right-orange.svg" class="next-page"></a>
      
      
        <a href="nested.html" class="btn btn-neutral" title="torch.nested" accesskey="p" rel="prev"><img src="_static/images/chevron-right-orange.svg" class="previous-page"> Previous</a>
      
    </div>
  

  

    <hr>

  

  <div role="contentinfo">
    <p>
        &copy; Copyright 2023, PyTorch Contributors.

    </p>
  </div>
    
      <div>
        Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
      </div>
     

</footer>

          </div>
<script>

var match = window.location.href.match(/\/_[a-zA-Z0-9_]*.html|_dynamo/gi);
var url = window.location.href.lastIndexOf(match[match.length-1]);

if (url)
  {
    var div = '<div class="admonition note"><p class="admonition-title">Note</p><p><i class="fa fa-exclamation-circle" aria-hidden="true">&nbsp</i> This page describes an internal API which is not intended to be used outside of the PyTorch codebase and can be modified or removed without notice.</p></div>'
    document.getElementById("pytorch-article").insertAdjacentHTML('afterBegin', div)
  }
</script>
        </div>

        <div class="pytorch-content-right" id="pytorch-content-right">
          <div class="pytorch-right-menu" id="pytorch-right-menu">
            <div class="pytorch-side-scroll" id="pytorch-side-scroll-right">
              <ul>
<li><a class="reference internal" href="#">torch.sparse</a><ul>
<li><a class="reference internal" href="#why-and-when-to-use-sparsity">Why and when to use sparsity</a></li>
<li><a class="reference internal" href="#functionality-overview">Functionality overview</a></li>
<li><a class="reference internal" href="#operator-overview">Operator overview</a></li>
<li><a class="reference internal" href="#sparse-semi-structured-tensors">Sparse Semi-Structured Tensors</a><ul>
<li><a class="reference internal" href="#constructing-sparse-semi-structured-tensors">Constructing Sparse Semi-Structured Tensors</a></li>
<li><a class="reference internal" href="#sparse-semi-structured-tensor-operations">Sparse Semi-Structured Tensor Operations</a></li>
<li><a class="reference internal" href="#accelerating-nn-linear-with-semi-structured-sparsity">Accelerating nn.Linear with semi-structured sparsity</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sparse-coo-tensors">Sparse COO tensors</a><ul>
<li><a class="reference internal" href="#construction">Construction</a></li>
<li><a class="reference internal" href="#sparse-hybrid-coo-tensors">Sparse hybrid COO tensors</a></li>
<li><a class="reference internal" href="#uncoalesced-sparse-coo-tensors">Uncoalesced sparse COO tensors</a></li>
<li><a class="reference internal" href="#working-with-sparse-coo-tensors">Working with sparse COO tensors</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sparse-compressed-tensors">Sparse Compressed Tensors</a><ul>
<li><a class="reference internal" href="#sparse-csr-tensor">Sparse CSR Tensor</a><ul>
<li><a class="reference internal" href="#construction-of-csr-tensors">Construction of CSR tensors</a></li>
<li><a class="reference internal" href="#csr-tensor-operations">CSR Tensor Operations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sparse-csc-tensor">Sparse CSC Tensor</a><ul>
<li><a class="reference internal" href="#construction-of-csc-tensors">Construction of CSC tensors</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sparse-bsr-tensor">Sparse BSR Tensor</a><ul>
<li><a class="reference internal" href="#construction-of-bsr-tensors">Construction of BSR tensors</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sparse-bsc-tensor">Sparse BSC Tensor</a><ul>
<li><a class="reference internal" href="#construction-of-bsc-tensors">Construction of BSC tensors</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tools-for-working-with-sparse-compressed-tensors">Tools for working with sparse compressed tensors</a><ul>
<li><a class="reference internal" href="#construction-of-sparse-compressed-tensors">Construction of sparse compressed tensors</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#supported-operations">Supported operations</a><ul>
<li><a class="reference internal" href="#linear-algebra-operations">Linear Algebra operations</a></li>
<li><a class="reference internal" href="#tensor-methods-and-sparse">Tensor methods and sparse</a><ul>
</ul>
</li>
<li><a class="reference internal" href="#torch-functions-specific-to-sparse-tensors">Torch functions specific to sparse Tensors</a></li>
<li><a class="reference internal" href="#other-functions">Other functions</a></li>
<li><a class="reference internal" href="#unary-functions">Unary functions</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            </div>
          </div>
        </div>
      </section>
    </div>

  


  

     
       <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
         <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
         <script src="_static/jquery.js"></script>
         <script src="_static/underscore.js"></script>
         <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
         <script src="_static/doctools.js"></script>
         <script src="_static/sphinx_highlight.js"></script>
         <script src="_static/clipboard.min.js"></script>
         <script src="_static/copybutton.js"></script>
     

  

  <script type="text/javascript" src="_static/js/vendor/popper.min.js"></script>
  <script type="text/javascript" src="_static/js/vendor/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/list.js/1.5.0/list.min.js"></script>
  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 
<script script type="text/javascript">
  var collapsedSections = ['Developer Notes', 'Language Bindings', 'Libraries', 'Community'];
</script>

<img height="1" width="1" style="border-style:none;" alt="" src="https://www.googleadservices.com/pagead/conversion/795629140/?label=txkmCPmdtosBENSssfsC&amp;guid=ON&amp;script=0"/>


  <!-- Begin Footer -->

  <div class="container-fluid docs-tutorials-resources" id="docs-tutorials-resources">
    <div class="container">
      <div class="row">
        <div class="col-md-4 text-center">
          <h2>Docs</h2>
          <p>Access comprehensive developer documentation for PyTorch</p>
          <a class="with-right-arrow" href="https://pytorch.org/docs/stable/index.html">View Docs</a>
        </div>

        <div class="col-md-4 text-center">
          <h2>Tutorials</h2>
          <p>Get in-depth tutorials for beginners and advanced developers</p>
          <a class="with-right-arrow" href="https://pytorch.org/tutorials">View Tutorials</a>
        </div>

        <div class="col-md-4 text-center">
          <h2>Resources</h2>
          <p>Find development resources and get your questions answered</p>
          <a class="with-right-arrow" href="https://pytorch.org/resources">View Resources</a>
        </div>
      </div>
    </div>
  </div>

  <footer class="site-footer">
    <div class="container footer-container">
      <div class="footer-logo-wrapper">
        <a href="https://pytorch.org/" class="footer-logo"></a>
      </div>

      <div class="footer-links-wrapper">
        <div class="footer-links-col">
          <ul>
            <li class="list-title"><a href="https://pytorch.org/">PyTorch</a></li>
            <li><a href="https://pytorch.org/get-started">Get Started</a></li>
            <li><a href="https://pytorch.org/features">Features</a></li>
            <li><a href="https://pytorch.org/ecosystem">Ecosystem</a></li>
            <li><a href="https://pytorch.org/blog/">Blog</a></li>
            <li><a href="https://github.com/pytorch/pytorch/blob/master/CONTRIBUTING.md">Contributing</a></li>
          </ul>
        </div>

        <div class="footer-links-col">
          <ul>
            <li class="list-title"><a href="https://pytorch.org/resources">Resources</a></li>
            <li><a href="https://pytorch.org/tutorials">Tutorials</a></li>
            <li><a href="https://pytorch.org/docs/stable/index.html">Docs</a></li>
            <li><a href="https://discuss.pytorch.org" target="_blank">Discuss</a></li>
            <li><a href="https://github.com/pytorch/pytorch/issues" target="_blank">Github Issues</a></li>
            <li><a href="https://pytorch.org/assets/brand-guidelines/PyTorch-Brand-Guidelines.pdf" target="_blank">Brand Guidelines</a></li>
          </ul>
        </div>

        <div class="footer-links-col">
          <ul>
            <li class="list-title">Stay up to date</li>
            <li><a href="https://www.facebook.com/pytorch" target="_blank">Facebook</a></li>
            <li><a href="https://twitter.com/pytorch" target="_blank">Twitter</a></li>
            <li><a href="https://www.youtube.com/pytorch" target="_blank">YouTube</a></li>
            <li><a href="https://www.linkedin.com/company/pytorch" target="_blank">LinkedIn</a></li>
          </ul>  
          </div>

        <div class="footer-links-col">
          <ul>
            <li class="list-title">PyTorch Podcasts</li>
            <li><a href="https://open.spotify.com/show/6UzHKeiy368jKfQMKKvJY5" target="_blank">Spotify</a></li>
            <li><a href="https://podcasts.apple.com/us/podcast/pytorch-developer-podcast/id1566080008" target="_blank">Apple</a></li>
            <li><a href="https://www.google.com/podcasts?feed=aHR0cHM6Ly9mZWVkcy5zaW1wbGVjYXN0LmNvbS9PQjVGa0lsOA%3D%3D" target="_blank">Google</a></li>
            <li><a href="https://music.amazon.com/podcasts/7a4e6f0e-26c2-49e9-a478-41bd244197d0/PyTorch-Developer-Podcast?" target="_blank">Amazon</a></li>
          </ul>
         </div>
        </div>
        
        <div class="privacy-policy">
          <ul>
            <li class="privacy-policy-links"><a href="https://www.linuxfoundation.org/terms/" target="_blank">Terms</a></li>
            <li class="privacy-policy-links">|</li>
            <li class="privacy-policy-links"><a href="https://www.linuxfoundation.org/privacy-policy/" target="_blank">Privacy</a></li>
          </ul>
        </div>
        <div class="copyright">
        <p>© Copyright The Linux Foundation. The PyTorch Foundation is a project of The Linux Foundation.
          For web site terms of use, trademark policy and other policies applicable to The PyTorch Foundation please see
          <a href="www.linuxfoundation.org/policies/">www.linuxfoundation.org/policies/</a>. The PyTorch Foundation supports the PyTorch open source
          project, which has been established as PyTorch Project a Series of LF Projects, LLC. For policies applicable to the PyTorch Project a Series of LF Projects, LLC,
          please see <a href="www.lfprojects.org/policies/">www.lfprojects.org/policies/</a>.</p>
      </div>
     </div>

  </footer>

  <div class="cookie-banner-wrapper">
  <div class="container">
    <p class="gdpr-notice">To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or navigating, you agree to allow our usage of cookies. As the current maintainers of this site, Facebook’s Cookies Policy applies. Learn more, including about available controls: <a href="https://www.facebook.com/policies/cookies/">Cookies Policy</a>.</p>
    <img class="close-button" src="_static/images/pytorch-x.svg">
  </div>
</div>

  <!-- End Footer -->

  <!-- Begin Mobile Menu -->

  <div class="mobile-main-menu">
    <div class="container-fluid">
      <div class="container">
        <div class="mobile-main-menu-header-container">
          <a class="header-logo" href="https://pytorch.org/" aria-label="PyTorch"></a>
          <a class="main-menu-close-button" href="#" data-behavior="close-mobile-menu"></a>
        </div>
      </div>
    </div>

    <div class="mobile-main-menu-links-container">
      <div class="main-menu">
        <ul>
          <li>
            <a href="https://pytorch.org/get-started">Get Started</a>
          </li>

          <li>
            <a href="https://pytorch.org/ecosystem">Ecosystem</a>
          </li>
            
          <li>
            <a href="https://pytorch.org/mobile">Mobile</a>
          </li>

          <li>
            <a href="https://pytorch.org/blog/">Blog</a>
          </li>

          <li>
            <a href="https://pytorch.org/tutorials">Tutorials</a>
          </li>

          <li class="resources-mobile-menu-title" class="active">
            Docs
          </li>

          <ul class="resources-mobile-menu-items">
            <li>
              <a href="https://pytorch.org/docs/stable/index.html">PyTorch</a>
            </li>

            <li>
              <a href="https://pytorch.org/audio/stable/index.html">torchaudio</a>
            </li>

            <li>
              <a href="https://pytorch.org/text/stable/index.html">torchtext</a>
            </li>

            <li>
              <a href="https://pytorch.org/vision/stable/index.html">torchvision</a>
            </li>

            <li>
              <a href="https://pytorch.org/torcharrow">torcharrow</a>
            </li>

            <li>
              <a href="https://pytorch.org/data">TorchData</a>
            </li>

            <li>
              <a href="https://pytorch.org/torchrec">TorchRec</a>
            </li>

            <li>
              <a href="https://pytorch.org/serve/">TorchServe</a>
            </li>

            <li>
              <a href="https://pytorch.org/torchx/">TorchX</a>
            </li>

            <li>
              <a href="https://pytorch.org/xla">PyTorch on XLA Devices</a>
            </li>
          </ul>

          <li class="resources-mobile-menu-title">
            Resources
          </li>
            
           <ul class="resources-mobile-menu-items">

            <li>
              <a href="https://pytorch.org/features">About</a>
            </li>

            <li>
              <a href="https://pytorch.org/foundation">PyTorch Foundation</a>
            </li>

            <li>
              <a href="https://pytorch.org/#community-module">Community</a>
            </li>

            <li>
              <a href="https://pytorch.org/community-stories">Community Stories</a>
            </li>

            <li>
              <a href="https://pytorch.org/resources">Developer Resources</a>
            </li>

            <li>
              <a href="https://pytorch.org/events">Events</a>
            </li>

            <li>
              <a href="https://discuss.pytorch.org/">Forums</a>
            </li>

            <li>
              <a href="https://pytorch.org/hub">Models (Beta)</a>
            </li>
          </ul>

          <li>
            <a href="https://github.com/pytorch/pytorch">Github</a>
          </li>
        </ul>
      </div>
    </div>
  </div>

  <!-- End Mobile Menu -->

  <script type="text/javascript" src="_static/js/vendor/anchor.min.js"></script>

  <script type="text/javascript">
    $(document).ready(function() {
      mobileMenu.bind();
      mobileTOC.bind();
      pytorchAnchors.bind();
      sideMenus.bind();
      scrollToAnchor.bind();
      highlightNavigation.bind();
      mainMenuDropdown.bind();
      filterTags.bind();

      // Add class to links that have code blocks, since we cannot create links in code blocks
      $("article.pytorch-article a span.pre").each(function(e) {
        $(this).closest("a").addClass("has-code");
      });
    })
  </script>
</body>
</html>