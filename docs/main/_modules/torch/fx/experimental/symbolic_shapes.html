


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta name="robots" content="noindex">
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>torch.fx.experimental.symbolic_shapes &mdash; PyTorch main documentation</title>
  

  
  
  
  
    <link rel="canonical" href="https://pytorch.org/docs/stable/_modules/torch/fx/experimental/symbolic_shapes.html"/>
  

  

  
  
    

  

  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <!-- <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" /> -->
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/copybutton.css" type="text/css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-beta/dist/katex.min.css" type="text/css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/katex-math.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/sphinx-dropdown.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/panels-bootstrap.min.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/css/jit.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />

<!--
  Search engines should not index the main version of documentation.
  Stable documentation are built without release == 'main'.
-->
<meta name="robots" content="noindex">


  <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-T8XT4PS');</script>
    <!-- End Google Tag Manager -->
  


  
  <script src="../../../../_static/js/modernizr.min.js"></script>

  <!-- Preload the theme fonts -->

<link rel="preload" href="../../../../_static/fonts/FreightSans/freight-sans-book.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../../_static/fonts/FreightSans/freight-sans-medium.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../../_static/fonts/IBMPlexMono/IBMPlexMono-Medium.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../../_static/fonts/FreightSans/freight-sans-bold.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../../_static/fonts/FreightSans/freight-sans-medium-italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../../_static/fonts/IBMPlexMono/IBMPlexMono-SemiBold.woff2" as="font" type="font/woff2" crossorigin="anonymous">

<!-- Preload the katex fonts -->

<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Math-Italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Main-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Main-Bold.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size1-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size4-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size2-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size3-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Caligraphic-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css" integrity="sha384-vSIIfh2YWi9wW0r9iZe7RJPrKwp6bG+s9QZMoITbCckVJqGCCRhc+ccxNcdpHuYu" crossorigin="anonymous">
</head>

<div class="container-fluid header-holder tutorials-header" id="header-holder">
  <div class="container">
    <div class="header-container">
      <a class="header-logo" href="https://pytorch.org/" aria-label="PyTorch"></a>

      <div class="main-menu">
        <ul>
          <li>
            <a href="https://pytorch.org/get-started">Get Started</a>
          </li>

          <li>
            <a href="https://pytorch.org/ecosystem">Ecosystem</a>
          </li>

          <li>
          <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="resource-option with-down-arrow">
                Edge
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="https://pytorch.org/edge">
                  <span class="dropdown-title">About PyTorch Edge</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/executorch">
                  <span class="dropdown-title">ExecuTorch</span>
                </a>
              </div>
            </div>  
          </li>

          <li>
            <a href="https://pytorch.org/blog/">Blog</a>
          </li>

          <li>
            <a href="https://pytorch.org/tutorials">Tutorials</a>
          </li>

          <li class="active docs-active">
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="resource-option with-down-orange-arrow">
                Docs
              </a>
              <div class="resources-dropdown-menu">
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/docs/stable/index.html">
                  <span class="dropdown-title">PyTorch</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/audio/stable/index.html">
                  <span class="dropdown-title">torchaudio</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/text/stable/index.html">
                  <span class="dropdown-title">torchtext</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/vision/stable/index.html">
                  <span class="dropdown-title">torchvision</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/torcharrow">
                  <span class="dropdown-title">torcharrow</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/data">
                  <span class="dropdown-title">TorchData</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/torchrec">
                  <span class="dropdown-title">TorchRec</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/serve/">
                  <span class="dropdown-title">TorchServe</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/torchx/">
                  <span class="dropdown-title">TorchX</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/xla">
                  <span class="dropdown-title">PyTorch on XLA Devices</span>
                  <p></p>
                </a>
            </div>
          </li>

          <li>
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="resource-option with-down-arrow">
                Resources
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="https://pytorch.org/features">
                  <span class="dropdown-title">About</span>
                  <p>Learn about PyTorchâ€™s features and capabilities</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/foundation">
                  <span class="dropdown-title">PyTorch Foundation</span>
                  <p>Learn about the PyTorch foundation</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/#community-module">
                  <span class="dropdown-title">Community</span>
                  <p>Join the PyTorch developer community to contribute, learn, and get your questions answered.</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/community-stories">
                  <span class="dropdown-title">Community Stories</span>
                  <p>Learn how our community solves real, everyday machine learning problems with PyTorch.</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/resources">
                  <span class="dropdown-title">Developer Resources</span>
                  <p>Find resources and get questions answered</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/events">
                  <span class="dropdown-title">Events</span>
                  <p>Find events, webinars, and podcasts</p>
                </a>
                <a class="nav-dropdown-item" href="https://discuss.pytorch.org/" target="_blank">
                  <span class="dropdown-title">Forums</span>
                  <p>A place to discuss PyTorch code, issues, install, research</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/hub">
                  <span class="dropdown-title">Models (Beta)</span>
                  <p>Discover, publish, and reuse pre-trained models</p>
                </a>
              </div>
            </div>
          </li>

          <li>
            <a href="https://github.com/pytorch/pytorch">GitHub</a>
          </li>
        </ul>
      </div>

      <a class="main-menu-open-button" href="#" data-behavior="open-mobile-menu"></a>
    </div>
  </div>
</div>

<body class="pytorch-body">

   

    

    <div class="table-of-contents-link-wrapper">
      <span>Table of Contents</span>
      <a href="#" class="toggle-table-of-contents" data-behavior="toggle-table-of-contents"></a>
    </div>

    <nav data-toggle="wy-nav-shift" class="pytorch-left-menu" id="pytorch-left-menu">
      <div class="pytorch-side-scroll">
        <div class="pytorch-menu pytorch-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          <div class="pytorch-left-menu-search">
            
    <div class="version">
      <a href='https://pytorch.org/docs/versions.html'>main (2.3.0a0+gite868a7f ) &#x25BC</a>
    </div>
    


  


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search Docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          </div>

          

<div>
  <a style="color:#F05732" href="https://pytorch.org/docs/stable/_modules/torch/fx/experimental/symbolic_shapes.html">
    You are viewing unstable developer preview docs.
    Click here to view docs for latest stable release.
  </a>
</div>


            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Community</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../community/build_ci_governance.html">PyTorch Governance | Build + CI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../community/contribution_guide.html">PyTorch Contribution Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../community/design.html">PyTorch Design Philosophy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../community/governance.html">PyTorch Governance | Mechanics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../community/persons_of_interest.html">PyTorch Governance | Maintainers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../notes/amp_examples.html">CUDA Automatic Mixed Precision examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notes/autograd.html">Autograd mechanics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notes/broadcasting.html">Broadcasting semantics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notes/cpu_threading_torchscript_inference.html">CPU threading and TorchScript inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notes/cuda.html">CUDA semantics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notes/ddp.html">Distributed Data Parallel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notes/extending.html">Extending PyTorch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notes/extending.func.html">Extending torch.func with autograd.Function</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notes/faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notes/fsdp.html">FSDP Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notes/gradcheck.html">Gradcheck mechanics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notes/hip.html">HIP (ROCm) semantics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notes/large_scale_deployments.html">Features for large-scale deployments</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notes/modules.html">Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notes/mps.html">MPS backend</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notes/multiprocessing.html">Multiprocessing best practices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notes/numerical_accuracy.html">Numerical accuracy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notes/randomness.html">Reproducibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notes/serialization.html">Serialization semantics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notes/windows.html">Windows FAQ</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Language Bindings</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../cpp_index.html">C++</a></li>
<li class="toctree-l1"><a class="reference external" href="https://pytorch.org/javadoc/">Javadoc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../deploy.html">torch::deploy</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Python API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../torch.html">torch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../nn.html">torch.nn</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../nn.functional.html">torch.nn.functional</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tensors.html">torch.Tensor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tensor_attributes.html">Tensor Attributes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tensor_view.html">Tensor Views</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../amp.html">torch.amp</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../autograd.html">torch.autograd</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../library.html">torch.library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../cpu.html">torch.cpu</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../cuda.html">torch.cuda</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../torch_cuda_memory.html">Understanding CUDA Memory Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../torch_cuda_memory.html#generating-a-snapshot">Generating a Snapshot</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../torch_cuda_memory.html#using-the-visualizer">Using the visualizer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../torch_cuda_memory.html#snapshot-api-reference">Snapshot API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mps.html">torch.mps</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../xpu.html">torch.xpu</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../meta.html">Meta device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../backends.html">torch.backends</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../export.html">torch.export</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../distributed.html">torch.distributed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../distributed.algorithms.join.html">torch.distributed.algorithms.join</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../distributed.elastic.html">torch.distributed.elastic</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../fsdp.html">torch.distributed.fsdp</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../distributed.optim.html">torch.distributed.optim</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../distributed.tensor.parallel.html">torch.distributed.tensor.parallel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../distributed.checkpoint.html">torch.distributed.checkpoint</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../distributions.html">torch.distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../torch.compiler.html">torch.compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../fft.html">torch.fft</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../func.html">torch.func</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../futures.html">torch.futures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../fx.html">torch.fx</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../hub.html">torch.hub</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../jit.html">torch.jit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../linalg.html">torch.linalg</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../monitor.html">torch.monitor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../signal.html">torch.signal</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../special.html">torch.special</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../torch.overrides.html">torch.overrides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../package.html">torch.package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../profiler.html">torch.profiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../nn.init.html">torch.nn.init</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../nn.attention.html">torch.nn.attention</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../onnx.html">torch.onnx</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../optim.html">torch.optim</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../complex_numbers.html">Complex Numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ddp_comm_hooks.html">DDP Communication Hooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pipeline.html">Pipeline Parallelism</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../quantization.html">Quantization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../rpc.html">Distributed RPC Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../random.html">torch.random</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../masked.html">torch.masked</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../nested.html">torch.nested</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../sparse.html">torch.sparse</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../storage.html">torch.Storage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../testing.html">torch.testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../utils.html">torch.utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../benchmark_utils.html">torch.utils.benchmark</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../bottleneck.html">torch.utils.bottleneck</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../checkpoint.html">torch.utils.checkpoint</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../cpp_extension.html">torch.utils.cpp_extension</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../data.html">torch.utils.data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../deterministic.html">torch.utils.deterministic</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../jit_utils.html">torch.utils.jit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../dlpack.html">torch.utils.dlpack</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mobile_optimizer.html">torch.utils.mobile_optimizer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_zoo.html">torch.utils.model_zoo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tensorboard.html">torch.utils.tensorboard</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../symbolic_shapes.html">torch.fx.experimental.symbolic_shapes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../type_info.html">Type Info</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../named_tensor.html">Named Tensors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../name_inference.html">Named Tensors operator coverage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../config_mod.html">torch.__config__</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../logging.html">torch._logging</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Libraries</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://pytorch.org/audio/stable">torchaudio</a></li>
<li class="toctree-l1"><a class="reference external" href="https://pytorch.org/data">TorchData</a></li>
<li class="toctree-l1"><a class="reference external" href="https://pytorch.org/torchrec">TorchRec</a></li>
<li class="toctree-l1"><a class="reference external" href="https://pytorch.org/serve">TorchServe</a></li>
<li class="toctree-l1"><a class="reference external" href="https://pytorch.org/text/stable">torchtext</a></li>
<li class="toctree-l1"><a class="reference external" href="https://pytorch.org/vision/stable">torchvision</a></li>
<li class="toctree-l1"><a class="reference external" href="https://pytorch.org/xla/">PyTorch on XLA Devices</a></li>
</ul>

            
          

        </div>
      </div>
    </nav>

    <div class="pytorch-container">
      <div class="pytorch-page-level-bar" id="pytorch-page-level-bar">
        <div class="pytorch-breadcrumbs-wrapper">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="pytorch-breadcrumbs">
    
      <li>
        <a href="../../../../index.html">
          
            Docs
          
        </a> &gt;
      </li>

        
          <li><a href="../../../index.html">Module code</a> &gt;</li>
        
          <li><a href="../../../torch.html">torch</a> &gt;</li>
        
      <li>torch.fx.experimental.symbolic_shapes</li>
    
    
      <li class="pytorch-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
</div>
        </div>

        <div class="pytorch-shortcuts-wrapper" id="pytorch-shortcuts-wrapper">
          Shortcuts
        </div>
      </div>

      <section data-toggle="wy-nav-shift" id="pytorch-content-wrap" class="pytorch-content-wrap">
        <div class="pytorch-content-left">

        

          <!-- Google Tag Manager (noscript) -->
          <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-T8XT4PS"
          height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
          <!-- End Google Tag Manager (noscript) -->
          
          <div class="rst-content">
          
            <div role="main" class="main-content" itemscope="itemscope" itemtype="http://schema.org/Article">
             <article itemprop="articleBody" id="pytorch-article" class="pytorch-article">
              
  <h1>Source code for torch.fx.experimental.symbolic_shapes</h1><div class="highlight"><pre>
<span></span><span class="c1"># mypy: ignore-errors</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">``torch.fx.experimental.symbolic_shapes`` provides interfaces for interacting with</span>
<span class="sd">our symbolic shapes reasoning system that is used heavily in torch.compile.  Although</span>
<span class="sd">this is not generally considered public API, when writing framework code in PyTorch</span>
<span class="sd">as well as extensions to PyTorch (e.g., in custom operator implementations), you may</span>
<span class="sd">need to make use of these APIs to setup dynamic shapes support appropriately.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">builtins</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">import</span> <span class="nn">traceback</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">field</span>
<span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">lru_cache</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">cast</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">Set</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">Type</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
    <span class="n">TYPE_CHECKING</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">typing_extensions</span> <span class="kn">import</span> <span class="n">TypeAlias</span>

<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.fx</span>
<span class="kn">import</span> <span class="nn">torch.fx.traceback</span> <span class="k">as</span> <span class="nn">fx_traceback</span>
<span class="kn">from</span> <span class="nn">torch.fx.experimental</span> <span class="kn">import</span> <span class="n">_config</span> <span class="k">as</span> <span class="n">config</span>

<span class="kn">from</span> <span class="nn">torch.fx.experimental.recording</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">FakeTensorMeta</span><span class="p">,</span>
    <span class="n">ShapeEnvEvent</span><span class="p">,</span>
    <span class="n">record_shapeenv_event</span><span class="p">,</span>
    <span class="n">replay_shape_env_events</span><span class="p">,</span>
    <span class="n">shape_env_check_state_equal</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">torch.fx.experimental.sym_node</span> <span class="kn">import</span> <span class="n">SymNode</span><span class="p">,</span> <span class="n">SymTypes</span>

<span class="c1"># NB: The sym_* functions are used via getattr() and must be imported here.</span>
<span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">SymBool</span><span class="p">,</span> <span class="n">SymFloat</span><span class="p">,</span> <span class="n">SymInt</span>
<span class="kn">from</span> <span class="nn">torch._guards</span> <span class="kn">import</span> <span class="n">ShapeGuard</span><span class="p">,</span> <span class="n">Source</span><span class="p">,</span> <span class="n">TracingContext</span>
<span class="kn">from</span> <span class="nn">torch.utils._python_dispatch</span> <span class="kn">import</span> <span class="n">is_traceable_wrapper_subclass</span>
<span class="kn">from</span> <span class="nn">torch.utils._sympy.functions</span> <span class="kn">import</span> <span class="n">FloorDiv</span><span class="p">,</span> <span class="n">Mod</span><span class="p">,</span> <span class="n">IsNonOverlappingAndDenseIndicator</span>
<span class="kn">from</span> <span class="nn">torch.utils._sympy.solve</span> <span class="kn">import</span> <span class="n">try_solve</span>
<span class="kn">from</span> <span class="nn">torch.utils._sympy.value_ranges</span> <span class="kn">import</span> <span class="n">bound_sympy</span><span class="p">,</span> <span class="n">SymPyValueRangeAnalysis</span><span class="p">,</span> <span class="n">ValueRanges</span><span class="p">,</span> <span class="n">ValueRangeError</span>
<span class="kn">from</span> <span class="nn">torch.utils._sympy.singleton_int</span> <span class="kn">import</span> <span class="n">SingletonInt</span>
<span class="kn">from</span> <span class="nn">torch.utils._traceback</span> <span class="kn">import</span> <span class="n">format_frame</span><span class="p">,</span> <span class="n">CapturedTraceback</span>
<span class="kn">from</span> <span class="nn">torch._utils_internal</span> <span class="kn">import</span> <span class="n">signpost_event</span>

<span class="kn">from</span> <span class="nn">torch._logging</span> <span class="kn">import</span> <span class="n">LazyString</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">torch._dynamo.source</span> <span class="kn">import</span> <span class="n">TensorPropertySource</span>

<span class="n">InputList</span> <span class="o">=</span> <span class="n">List</span>
<span class="n">DimList</span> <span class="o">=</span> <span class="n">List</span>

<span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">GuardOnDataDependentSymNode</span><span class="p">(</span><span class="ne">RuntimeError</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="kn">import</span> <span class="nn">sympy</span>
<span class="kn">from</span> <span class="nn">sympy.printing.str</span> <span class="kn">import</span> <span class="n">StrPrinter</span>
<span class="kn">from</span> <span class="nn">sympy.printing.precedence</span> <span class="kn">import</span> <span class="n">precedence</span><span class="p">,</span> <span class="n">PRECEDENCE</span>

<span class="n">aten</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">aten</span>  <span class="c1"># type: ignore[has-type]</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;has_symbolic_sizes_strides&quot;</span><span class="p">,</span> <span class="s2">&quot;create_contiguous&quot;</span><span class="p">,</span> <span class="s2">&quot;ShapeEnv&quot;</span><span class="p">,</span> <span class="s2">&quot;is_concrete_int&quot;</span><span class="p">,</span>
    <span class="s2">&quot;guard_int&quot;</span><span class="p">,</span> <span class="s2">&quot;guard_float&quot;</span><span class="p">,</span> <span class="s2">&quot;guard_scalar&quot;</span><span class="p">,</span> <span class="s2">&quot;canonicalize_bool_expr&quot;</span><span class="p">,</span>
    <span class="s2">&quot;hint_int&quot;</span><span class="p">,</span> <span class="s2">&quot;SYMPY_INTERP&quot;</span><span class="p">,</span> <span class="s2">&quot;free_symbols&quot;</span><span class="p">,</span> <span class="s2">&quot;is_symbol_binding_fx_node&quot;</span><span class="p">,</span>
    <span class="s2">&quot;is_concrete_bool&quot;</span><span class="p">,</span> <span class="s2">&quot;is_singleton&quot;</span><span class="p">,</span> <span class="s2">&quot;SHAPEENV_EVENT_KEY&quot;</span><span class="p">,</span> <span class="s2">&quot;CURRENT_NODE_KEY&quot;</span><span class="p">,</span>
    <span class="s2">&quot;has_free_symbols&quot;</span><span class="p">,</span> <span class="s2">&quot;sym_eq&quot;</span><span class="p">,</span> <span class="s2">&quot;SymbolicContext&quot;</span><span class="p">,</span> <span class="s2">&quot;StatelessSymbolicContext&quot;</span><span class="p">,</span>
    <span class="s2">&quot;StatefulSymbolicContext&quot;</span><span class="p">,</span> <span class="s2">&quot;SubclassSymbolicContext&quot;</span><span class="p">,</span> <span class="s2">&quot;statically_known_true&quot;</span><span class="p">,</span>
    <span class="s2">&quot;guard_size_oblivious&quot;</span><span class="p">,</span>
<span class="p">]</span>

<span class="c1"># FX node metadata keys for symbolic shape FX graph.</span>
<span class="n">SHAPEENV_EVENT_KEY</span> <span class="o">=</span> <span class="s2">&quot;shapeenv_event&quot;</span>
<span class="n">CURRENT_NODE_KEY</span> <span class="o">=</span> <span class="s2">&quot;current_node&quot;</span>

<span class="c1"># These are modules that contain generic code for interacting with ShapeEnv</span>
<span class="c1"># which are unlikely to identify a particular interesting guard statement</span>
<span class="nd">@lru_cache</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">uninteresting_files</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
    <span class="kn">import</span> <span class="nn">torch._inductor.sizevars</span>
    <span class="kn">import</span> <span class="nn">torch._library.abstract_impl</span>
    <span class="kn">import</span> <span class="nn">torch._subclasses.meta_utils</span>
    <span class="kn">import</span> <span class="nn">torch._subclasses.fake_tensor</span>
    <span class="n">mods</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="vm">__name__</span><span class="p">],</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">fx</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">recording</span><span class="p">,</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">fx</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">sym_node</span><span class="p">,</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">fx</span><span class="o">.</span><span class="n">interpreter</span><span class="p">,</span>
        <span class="n">torch</span><span class="p">,</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">_inductor</span><span class="o">.</span><span class="n">sizevars</span><span class="p">,</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">abstract_impl</span><span class="p">,</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">_subclasses</span><span class="o">.</span><span class="n">meta_utils</span><span class="p">,</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">_subclasses</span><span class="o">.</span><span class="n">fake_tensor</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">inspect</span><span class="o">.</span><span class="n">getfile</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mods</span><span class="p">}</span>

<span class="c1"># We don&#39;t bother with the metaclass as all of the dispatching logic happens</span>
<span class="c1"># entirely from Python</span>
<span class="c1">#</span>
<span class="c1"># Didn&#39;t bother with ancestors for now, unlikely to have multiple modes for</span>
<span class="c1"># symints right now</span>

<span class="k">class</span> <span class="nc">ConstraintViolationError</span><span class="p">(</span><span class="ne">RuntimeError</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">has_symbolic_sizes_strides</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">elem</span><span class="o">.</span><span class="n">_has_symbolic_sizes_strides</span>

<span class="n">Int</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">create_contiguous</span><span class="p">(</span><span class="n">shape</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Int</span><span class="p">]:</span>
    <span class="n">strides</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">strides</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dim</span> <span class="o">*</span> <span class="n">strides</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">strides</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">hint_int</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">fallback</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieve the hint for an int (based on the underlying real values as observed</span>
<span class="sd">    at runtime).  If no hint is available (e.g., because data dependent shapes),</span>
<span class="sd">    if fallback is not None, use that instead (otherwise raise an error).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">require_hint</span><span class="p">(</span><span class="n">fallback</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">,</span> <span class="n">a</span>
    <span class="k">return</span> <span class="n">a</span>

<span class="n">Scalar</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">SymFloat</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">SymBool</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">has_hint</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Scalar</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">SymTypes</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">has_hint</span><span class="p">()</span>
    <span class="k">return</span> <span class="kc">True</span>

<span class="k">def</span> <span class="nf">is_concrete_int</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">SymInt</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; Utility to check if underlying object</span>
<span class="sd">    in SymInt is concrete value. Also returns</span>
<span class="sd">    true if integer is passed in.</span>

<span class="sd">    Args:</span>
<span class="sd">        a (SymInt or int): Object to test if it int</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">SymInt</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">numbers</span><span class="o">.</span><span class="n">Integer</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="kc">False</span>

<span class="c1"># In obscure Meta only situations, sympy.logic.boolalg doesn&#39;t exist at runtime.</span>
<span class="c1"># So make sure only type checker evaluates this alias.</span>
<span class="c1"># Xref: https://www.internalfb.com/diff/D53324783</span>
<span class="n">SympyBoolean</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="s2">&quot;sympy.logic.boolalg.Boolean&quot;</span>

<div class="viewcode-block" id="guard_size_oblivious"><a class="viewcode-back" href="../../../../symbolic_shapes.html#torch.fx.experimental.symbolic_shapes.guard_size_oblivious">[docs]</a><span class="k">def</span> <span class="nf">guard_size_oblivious</span><span class="p">(</span><span class="n">expr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">SymBool</span><span class="p">,</span> <span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform a guard on a symbolic boolean expression in a size oblivious way.</span>
<span class="sd">    This is typically used when a non-oblivious test would result in a guard</span>
<span class="sd">    on a data dependent value of which we don&#39;t know the value of at compile time.</span>
<span class="sd">    When a guard is tested this way, we may diverge in behavior from how regular</span>
<span class="sd">    PyTorch semantics would treat it.  For more information, see</span>
<span class="sd">    https://github.com/pytorch/pytorch/pull/118579</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">SymBool</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">guard_size_oblivious</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">expr</span></div>

<span class="k">def</span> <span class="nf">canonicalize_bool_expr</span><span class="p">(</span><span class="n">expr</span><span class="p">:</span> <span class="n">SympyBoolean</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SympyBoolean</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; Canonicalize a boolean expression by transforming it into a lt / le</span>
<span class="sd">    inequality and moving all the non-constant terms to the rhs.</span>
<span class="sd">    We canonicalize And / Ors / Not via cnf and then canonicalize their subexpr</span>
<span class="sd">    recursively</span>
<span class="sd">    nb. sympy.Rel.canonical is not good enough https://github.com/sympy/sympy/issues/25924</span>

<span class="sd">    Args:</span>
<span class="sd">        expr (sympy.Expr): Expression to canonicalize</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Canonicalise an inequality by transforming it into a lt / le</span>
    <span class="c1"># inequality and moving all the non-constant terms to the rhs</span>
    <span class="c1"># We canonicalise And / Ors / Not via cnf</span>
    <span class="c1"># nb. Relational.canonical in sympy is broken</span>
    <span class="c1"># https://github.com/sympy/sympy/issues/25924</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">Rel</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">And</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Or</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Not</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Eq</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Ne</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">And</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Or</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Not</span><span class="p">)):</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">logic</span><span class="o">.</span><span class="n">boolalg</span><span class="o">.</span><span class="n">to_cnf</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_canonicalize_bool_expr_impl</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_canonicalize_bool_expr_impl</span><span class="p">(</span><span class="n">expr</span><span class="p">:</span> <span class="n">SympyBoolean</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SympyBoolean</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">And</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Or</span><span class="p">)):</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">expr</span><span class="p">)(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="n">canonicalize_bool_expr</span><span class="p">,</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">))</span>

    <span class="n">opposite</span> <span class="o">=</span> <span class="p">{</span><span class="n">sympy</span><span class="o">.</span><span class="n">Gt</span><span class="p">:</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Lt</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Ge</span><span class="p">:</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Le</span><span class="p">}</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">opposite</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
        <span class="n">lhs</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">rhs</span> <span class="o">-</span> <span class="n">expr</span><span class="o">.</span><span class="n">lhs</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">opposite</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">expr</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">Lt</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Le</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Eq</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Ne</span><span class="p">))</span>
        <span class="n">lhs</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">expr</span><span class="o">.</span><span class="n">rhs</span>
        <span class="n">t</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="n">rhs</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Add</span><span class="p">):</span>
        <span class="n">cts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">lhs</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">term</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
                <span class="n">cts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
        <span class="n">lhs</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">variables</span><span class="p">)</span>
        <span class="n">rhs</span> <span class="o">=</span> <span class="o">-</span><span class="n">sympy</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">cts</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">is_concrete_bool</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">SymBool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; Utility to check if underlying object</span>
<span class="sd">    in SymBool is concrete value. Also returns</span>
<span class="sd">    true if integer is passed in.</span>
<span class="sd">    Args:</span>
<span class="sd">        a (SymBool or bool): Object to test if it bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">SymBool</span><span class="p">,</span> <span class="nb">bool</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">logic</span><span class="o">.</span><span class="n">boolalg</span><span class="o">.</span><span class="n">BooleanTrue</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">logic</span><span class="o">.</span><span class="n">boolalg</span><span class="o">.</span><span class="n">BooleanFalse</span><span class="p">)):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="kc">False</span>

<span class="k">def</span> <span class="nf">is_singleton</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="c1"># check for SingletonSymNode</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">singleton_int</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="c1"># check for symbolic variable wrapping a SingletonSymNode (fake-ifying causes this)</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">s</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">is_symbolic</span><span class="p">()</span>
        <span class="ow">and</span> <span class="n">s</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">hint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">hint</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">)</span>
        <span class="ow">and</span> <span class="n">s</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">hint</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">singleton_int</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="p">)</span>

<span class="k">def</span> <span class="nf">_iterate_exprs</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">SymInt</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">Basic</span><span class="p">]:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">SymTypes</span><span class="p">):</span>
        <span class="c1"># This allow applies to the jagged layout NestedTensor case as</span>
        <span class="c1"># singleton ints are not symbolic</span>
        <span class="k">if</span> <span class="n">is_symbolic</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">val</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Basic</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">val</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)):</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
        <span class="k">yield from</span> <span class="n">_iterate_exprs</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">size</span><span class="p">())</span>
        <span class="k">yield from</span> <span class="n">_iterate_exprs</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">stride</span><span class="p">())</span>
        <span class="k">yield from</span> <span class="n">_iterate_exprs</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">storage_offset</span><span class="p">())</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">val</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="n">_iterate_exprs</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot extract sympy expressions from </span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">free_symbols</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">SymInt</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">]:</span>
    <span class="n">itr</span> <span class="o">=</span> <span class="n">_iterate_exprs</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="c1"># we need at least 1 to call union, so we hand code the identity</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">first_expr</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">itr</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">first_expr</span><span class="o">.</span><span class="n">free_symbols</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">free_symbols</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">itr</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">has_free_symbols</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">SymInt</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Faster version of bool(free_symbols(val))&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">is_number</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">_iterate_exprs</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>

<span class="c1"># Like free_symbols, but filtered to only report unbacked symbols</span>
<span class="k">def</span> <span class="nf">free_unbacked_symbols</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="c1"># NB: keep synced with is_unbacked_symint</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">free_symbols</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">((</span><span class="s2">&quot;u&quot;</span><span class="p">,</span> <span class="s2">&quot;f&quot;</span><span class="p">))}</span>

<span class="c1"># WARNING: Don&#39;t use this on Dynamo produced graphs, they don&#39;t have meta</span>
<span class="c1"># setup!</span>
<span class="k">def</span> <span class="nf">is_symbol_binding_fx_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">]:</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;placeholder&quot;</span> <span class="ow">and</span>
        <span class="s2">&quot;val&quot;</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">meta</span> <span class="ow">and</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">)</span> <span class="ow">and</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span>
    <span class="k">return</span> <span class="kc">None</span>

<span class="k">def</span> <span class="nf">find_symbol_binding_fx_nodes</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="n">node</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="p">:</span> <span class="n">node</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span>
        <span class="k">if</span> <span class="n">is_symbol_binding_fx_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="p">}</span>

<span class="k">def</span> <span class="nf">definitely_true</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True only if we can tell that a is True, possibly introducing</span>
<span class="sd">    a guard in the process.  If a depends on some unbacked SymInt, we may</span>
<span class="sd">    return False even though there may exist a possible value of the SymInt</span>
<span class="sd">    that would cause the expression to return True.</span>

<span class="sd">    When is it appropriate to use definitely_true?  First, if you can use</span>
<span class="sd">    a higher level combinator like parallel_or/parallel_and, prefer using</span>
<span class="sd">    those instead, they are definitely safe (modulo short-circuiting).</span>
<span class="sd">    Second, it can be used if the program would behave equivalently if</span>
<span class="sd">    definitely_true always returned False (parallel_or/parallel_and are</span>
<span class="sd">    examples of this pattern, modulo short-circuiting).  Finally, it even</span>
<span class="sd">    be OK if the program wouldn&#39;t behave equivalently, so long as the</span>
<span class="sd">    change is semantics preserving.  It can be semantics preserving if</span>
<span class="sd">    the program errors in more cases than it did previously (but otherwise</span>
<span class="sd">    behaves identically), or if it changes some quantity in a way that</span>
<span class="sd">    doesn&#39;t matter (e.g., strides often fall in this bucket.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">SymBool</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">has_hint</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">guard_bool</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">definitely_false</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True only if we can tell that a is False, possibly introducing</span>
<span class="sd">    a guard in the process.  If a depends on some unbacked SymInt, we may</span>
<span class="sd">    return False even though there may exist a possible value of the SymInt</span>
<span class="sd">    that would cause the expression a to be False.  See definitely_true</span>
<span class="sd">    for more usage guidance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">SymBool</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">has_hint</span><span class="p">():</span>
            <span class="k">return</span> <span class="ow">not</span> <span class="n">guard_bool</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">statically_known_true</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">SymBool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns True if x can be simplified to a constant and is true.</span>

<span class="sd">    NOTE: This function doesn&#39;t introduce new guards, so the expression may end</span>
<span class="sd">    up evaluating to true at runtime even if this function returns False.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">SymBool</span><span class="p">):</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span>
        <span class="n">shape_env</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">shape_env</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">simplified</span> <span class="o">=</span> <span class="n">shape_env</span><span class="o">.</span><span class="n">_maybe_evaluate_static</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">simplified</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">simplified</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Could not simplify </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span>


<span class="k">def</span> <span class="nf">parallel_or</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate the logical OR of several arguments, avoiding guarding on</span>
<span class="sd">    unbacked SymInts if another argument is definitely True.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">statically_known_true</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">definitely_true</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">parallel_and</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate the logical FALSE of several arguments, avoiding guarding on</span>
<span class="sd">    unbacked SymInts if another argument is definitely False.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">statically_known_true</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">sym_not</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">definitely_false</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">sym_eq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Like ==, but when run on list/tuple, it will recursively test equality</span>
<span class="sd">    and use sym_and to join the results together, without guarding.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">and_</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="n">sym_eq</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unexpected sym_eq between </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">guard_scalar</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">SymBool</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">guard_bool</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">SymInt</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">guard_int</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">SymFloat</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">guard_float</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unrecognized scalar </span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="nd">@record_shapeenv_event</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">_constrain_symbol_range</span><span class="p">(</span><span class="n">shape_env</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">compiler_min</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">compiler_max</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="n">upd_vr</span> <span class="o">=</span> <span class="n">ValueRanges</span><span class="p">(</span><span class="n">compiler_min</span><span class="p">,</span> <span class="n">compiler_max</span><span class="p">)</span>
    <span class="n">old_vr</span> <span class="o">=</span> <span class="n">shape_env</span><span class="o">.</span><span class="n">var_to_range</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ValueRanges</span><span class="o">.</span><span class="n">unknown</span><span class="p">())</span>
    <span class="n">new_vr</span> <span class="o">=</span> <span class="n">shape_env</span><span class="o">.</span><span class="n">var_to_range</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_vr</span> <span class="o">&amp;</span> <span class="n">upd_vr</span>
    <span class="k">if</span> <span class="n">new_vr</span> <span class="o">!=</span> <span class="n">old_vr</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;_constrain_symbol_range </span><span class="si">%s</span><span class="s2"> [</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">]&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">new_vr</span><span class="o">.</span><span class="n">lower</span><span class="p">,</span> <span class="n">new_vr</span><span class="o">.</span><span class="n">upper</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_advise_is_size</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Don&#39;t use this directly; use torch._check_is_size instead.</span>

<span class="sd">    This is a softer version of _constrain_range_for_size (with min=0,</span>
<span class="sd">    max=Inf).  Instead of forcibly constraining a variable (and erroring if we</span>
<span class="sd">    failed to constrain it), it will simply advise us that a size is</span>
<span class="sd">    constrained in some way.  We will always defer a runtime assert for this</span>
<span class="sd">    constraint if we cannot prove it at compile-time, but we we only</span>
<span class="sd">    *sometimes* learn useful extra information at compile-time with this</span>
<span class="sd">    information.  This is in contrast to constrain_range_for_size, where if</span>
<span class="sd">    you don&#39;t call that on a fresh unbacked symint, chances are we will choke.</span>

<span class="sd">    TODO: Make Dynamo handle this appropriately if this is seen in Dynamo-ed</span>
<span class="sd">    code.  Right now this is only really used in code with AOTAutograd trace</span>
<span class="sd">    through, so it is not a big problem that this isn&#39;t supported, but in</span>
<span class="sd">    principle all of this code should be Dynamo&#39;able too.</span>

<span class="sd">    TODO: I didn&#39;t support min/max because I didn&#39;t have a use case where this</span>
<span class="sd">    actually helped.  In principle we can support it, it just makes the</span>
<span class="sd">    implementation below more complicated.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># This must always succeed, because the sole allowed caller _check_is_size</span>
    <span class="c1"># was responsible for expect_true&#39;ing this</span>
    <span class="k">assert</span> <span class="n">a</span> <span class="o">&gt;=</span> <span class="mi">0</span>

    <span class="c1"># NB: it&#39;s important not to constrain range for size for *hinted* SymInts,</span>
    <span class="c1"># because it is not only unsound, it will immediately trip our asserts</span>
    <span class="c1"># that hints have to be consistent with static analysis!  If you somehow</span>
    <span class="c1"># have an unbounded SymInt that later constrains to 1, this will be</span>
    <span class="c1"># inconsistent with the range</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">SymInt</span><span class="p">)</span>
        <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="n">SymNode</span><span class="p">)</span>
        <span class="ow">and</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">has_hint</span><span class="p">()</span>
        <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="n">_constrain_range_for_size</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="nd">@record_shapeenv_event</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">_constrain_range_for_size</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">min</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">max</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function is NOT INTENDED to be used by itself.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">SymFloat</span><span class="p">,</span> <span class="n">SymBool</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Constraining SymFloat/SymBool is nyi&quot;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">SymInt</span><span class="p">),</span> <span class="s2">&quot;can only constrain range for SymInt&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">),</span> <span class="s2">&quot;constraining non-Symbols NYI&quot;</span>

    <span class="k">if</span> <span class="nb">min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">min</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="nb">max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">max</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">oo</span>

    <span class="k">if</span> <span class="nb">max</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Maximum value to constrain_as_size can&#39;t be less than the specified min value, &quot;</span>
            <span class="s2">&quot;received min=</span><span class="si">{min}</span><span class="s2"> and max=</span><span class="si">{max}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">_constrain_symbol_range</span><span class="p">(</span>
        <span class="n">a</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">shape_env</span><span class="p">,</span>
        <span class="n">a</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span>
        <span class="n">compiler_min</span><span class="o">=</span><span class="nb">min</span><span class="p">,</span>
        <span class="n">compiler_max</span><span class="o">=</span><span class="nb">max</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">a</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">shape_env</span><span class="o">.</span><span class="n">size_like</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>


<span class="c1"># inclusive both ways</span>
<span class="nd">@record_shapeenv_event</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">constrain_range</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="nb">min</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">max</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies a constraint that the passed in SymInt must lie between min-max</span>
<span class="sd">    inclusive-inclusive, WITHOUT introducing a guard on the SymInt (meaning</span>
<span class="sd">    that it can be used on unbacked SymInts).  If min/max are None, we assume</span>
<span class="sd">    that the dimension is unbounded in that direction.  Repeated application</span>
<span class="sd">    of constrain_range intersects the ranges.  This is a fairly low level API</span>
<span class="sd">    that doesn&#39;t have a lot of safety guarantees (TODO: provide higher level</span>
<span class="sd">    APIs).</span>

<span class="sd">    Currently, we use this API in the following circumstance: when we allocate</span>
<span class="sd">    an unbacked SymInt, denoting an integer quantity which is data dependent,</span>
<span class="sd">    we ordinarily do not know anything about what values it may take.  This</span>
<span class="sd">    means that any sort of guard on it will immediately fail.  However, in</span>
<span class="sd">    many cases, we know something about the unbacked SymInt: for example, we</span>
<span class="sd">    know that nonzero(x).size(0) must be &gt;= 0.  We use constrain_range to</span>
<span class="sd">    narrow the possible range, declaring that negative symbols are impossible.</span>
<span class="sd">    This permits to definitely answer True to queries like &#39;nnz &gt;= 0&#39;, even if</span>
<span class="sd">    we don&#39;t know what the actual (hinted) value of &#39;nnz&#39; is.  In fact, we</span>
<span class="sd">    actually use constrain_range to unsoundly discharge common guards: for an</span>
<span class="sd">    unbacked SymInt produced by nonzero, we will also assume that it is not</span>
<span class="sd">    equal to 0/1 (even though these are perfectly possible values at runtime),</span>
<span class="sd">    because we generally expect graphs that are valid for N=2 to also be valid</span>
<span class="sd">    for N=1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">min</span> <span class="o">=</span> <span class="o">-</span><span class="n">sympy</span><span class="o">.</span><span class="n">oo</span>
    <span class="k">if</span> <span class="nb">max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">max</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">oo</span>

    <span class="k">if</span> <span class="nb">max</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Maximum value to constrain_as_size can&#39;t be less than the specified min value, &quot;</span>
            <span class="s2">&quot;received min=</span><span class="si">{min}</span><span class="s2"> and max=</span><span class="si">{max}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">min</span> <span class="o">&lt;=</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="nb">max</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid value </span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s2"> for range [</span><span class="si">{</span><span class="nb">min</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="nb">max</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Integer</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">min</span> <span class="o">&lt;=</span> <span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">max</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ValueRangeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid value </span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span><span class="si">}</span><span class="s2"> for range [</span><span class="si">{</span><span class="nb">min</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="nb">max</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">),</span> <span class="s2">&quot;constraining non-Symbols NYI&quot;</span>

    <span class="c1"># TODO: Shouldn&#39;t we install a guard if the symbol is backed?  Or is the</span>
    <span class="c1"># semantics that this is an &quot;unchecked&quot; assert (but it this actually</span>
    <span class="c1"># something useful?  Might be better to restrict only for unbacked</span>
    <span class="c1"># SymInt).</span>
    <span class="n">_constrain_symbol_range</span><span class="p">(</span>
        <span class="n">a</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">shape_env</span><span class="p">,</span>
        <span class="n">a</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span>
        <span class="n">compiler_min</span><span class="o">=</span><span class="nb">min</span><span class="p">,</span>
        <span class="n">compiler_max</span><span class="o">=</span><span class="nb">max</span><span class="p">,</span>
    <span class="p">)</span>


<span class="nd">@record_shapeenv_event</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">constrain_unify</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given two SymInts, constrain them so that they must be equal.  NB:</span>
<span class="sd">    this will not work with SymInts that represent nontrivial expressions</span>
<span class="sd">    (yet!)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: this does not install a deferred runtime assert yet</span>

    <span class="c1"># TODO: Maybe dedupe this with _maybe_guard_eq?</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">SymInt</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">SymInt</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">),</span> <span class="s2">&quot;constraining non-Symbols NYI&quot;</span>
            <span class="n">shape_env</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">shape_env</span>
            <span class="n">shape_env</span><span class="o">.</span><span class="n">replacements</span><span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="p">]</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Integer</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># TODO: Actually, we can support this as long as one of them is a symbol.</span>
        <span class="c1"># NB: We can&#39;t actually do &quot;unification&quot; as our operators are not</span>
        <span class="c1"># injective</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">),</span> <span class="s2">&quot;constraining non-Symbols NYI&quot;</span>
        <span class="n">shape_env</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">shape_env</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">SymInt</span><span class="p">):</span>
            <span class="n">shape_env</span><span class="o">.</span><span class="n">replacements</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="p">]</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Integer</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">a</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">shape_env</span> <span class="ow">is</span> <span class="n">b</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">shape_env</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">),</span> <span class="s2">&quot;constraining non-Symbols NYI&quot;</span>
            <span class="n">new_var</span> <span class="o">=</span> <span class="n">shape_env</span><span class="o">.</span><span class="n">_find</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>
            <span class="n">shape_env</span><span class="o">.</span><span class="n">replacements</span><span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_var</span>

<span class="c1"># Assume that a boolean is true for the purposes of subsequent symbolic</span>
<span class="c1"># reasoning.  This will keep track of corresponding runtime checks to verify</span>
<span class="c1"># that the result is upheld: either as a regular guard, or as a special set</span>
<span class="c1"># of asserts which are triggered when an unbacked SymInt is allocated.</span>
<span class="c1">#</span>
<span class="c1"># DO NOT use this function for these cases:</span>
<span class="c1">#</span>
<span class="c1">#  - This is inappropriate for &quot;branching&quot; conditions (where both</span>
<span class="c1">#    true and false result in valid programs).  We will always assume</span>
<span class="c1">#    the condition evaluates true, and so it will never be possible</span>
<span class="c1">#    to trace the false condition when you use it.  For true branching</span>
<span class="c1">#    on unbacked SymInts, you must use torch.cond; if you incorrectly</span>
<span class="c1">#    use expect_true in this case, you will make the false branch</span>
<span class="c1">#    unreachable (as we will simply assume that only the true branch</span>
<span class="c1">#    is ever exercised).</span>
<span class="c1">#</span>
<span class="c1">#  - This is inappropriate for situations where you know some other system</span>
<span class="c1">#    invariant guarantees that this property holds, since you don&#39;t</span>
<span class="c1">#    really need to insert a runtime check in that case.  Use something</span>
<span class="c1">#    like constrain_range in that case.</span>
<span class="c1">#</span>
<span class="c1"># This API has a hitch.  To avoid having to reimplement error reporting</span>
<span class="c1"># capabilities, this function CAN return False.  The invariant is that</span>
<span class="c1"># the surrounding code must raise an error when this function returns</span>
<span class="c1"># False.  This is quite low level, so we recommend using other functions</span>
<span class="c1"># like check() which enforce this in a more intuitive way.</span>
<span class="c1">#</span>
<span class="c1"># By the way, this name is a nod to the __builtin_expect macro,</span>
<span class="c1"># which is used similarly (but unlike __builtin_expect, you MUST fail</span>
<span class="c1"># in the unlikely branch.)  (I think expect is a good name; in recent</span>
<span class="c1"># versions of C++, this is replaced with [[likely]], which is weaker</span>
<span class="c1"># and not accurate for this function!)</span>
<span class="k">def</span> <span class="nf">expect_true</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">skip</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">SymBool</span><span class="p">):</span>
        <span class="c1"># TODO: check perf implications of this</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">currentframe</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">skip</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># always run this loop at least once</span>
            <span class="n">frame</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">f_back</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">expect_true</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_filename</span><span class="p">,</span> <span class="n">frame</span><span class="o">.</span><span class="n">f_lineno</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">a</span>
    <span class="k">return</span> <span class="n">a</span>

<span class="k">def</span> <span class="nf">guard_bool</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">SymBool</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">guard_bool</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># NB: uses Python backtrace</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">a</span>
    <span class="k">return</span> <span class="n">a</span>

<span class="k">def</span> <span class="nf">guard_int</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">SymInt</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">guard_int</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># NB: uses Python backtrace</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">,</span> <span class="n">a</span>
    <span class="k">return</span> <span class="n">a</span>

<span class="k">def</span> <span class="nf">guard_float</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">SymFloat</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">guard_float</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># NB: uses Python backtrace</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span> <span class="n">a</span>
    <span class="k">return</span> <span class="n">a</span>

<span class="c1"># Given a GraphModule, return all the FakeTensors for all the placeholders</span>
<span class="k">def</span> <span class="nf">fx_placeholder_vals</span><span class="p">(</span><span class="n">gm</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">gm</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span> <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;placeholder&quot;</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">fx_placeholder_targets</span><span class="p">(</span><span class="n">gm</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">target</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">gm</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span> <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;placeholder&quot;</span><span class="p">]</span>

<span class="c1"># Given a GraphModule and arguments to run it with, evaluate that the guards</span>
<span class="c1"># for its associated ShapeEnv are satisfied by the passed arguments.  This</span>
<span class="c1"># WILL check for duck sizing.</span>
<span class="k">def</span> <span class="nf">eval_guards</span><span class="p">(</span><span class="n">gm</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">ignore_static</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">gm</span><span class="o">.</span><span class="n">shape_env</span><span class="o">.</span><span class="n">evaluate_guards_for_args</span><span class="p">(</span><span class="n">fx_placeholder_vals</span><span class="p">(</span><span class="n">gm</span><span class="p">),</span> <span class="n">args</span><span class="p">,</span> <span class="n">ignore_static</span><span class="o">=</span><span class="n">ignore_static</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">bind_symbols</span><span class="p">(</span><span class="n">gm</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">gm</span><span class="o">.</span><span class="n">shape_env</span><span class="o">.</span><span class="n">bind_symbols</span><span class="p">(</span><span class="n">fx_placeholder_vals</span><span class="p">(</span><span class="n">gm</span><span class="p">),</span> <span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_assert_bound_is_rational</span><span class="p">(</span><span class="n">expr</span><span class="p">:</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Expr</span><span class="p">,</span> <span class="n">bound</span><span class="p">:</span> <span class="n">ValueRanges</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    We assert that the bounds are either Boolean, or not finite, or can be computed</span>
<span class="sd">    in exact prevision via rational arithmetic.</span>
<span class="sd">    The only exception to this is the rare case when the user calls `sqrt(s0)`</span>
<span class="sd">    sqrt is turned into sympy.Pow so we just match for that (it matches more things, but still)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">bound</span><span class="o">.</span><span class="n">lower</span><span class="o">.</span><span class="n">is_rational</span> <span class="ow">or</span> <span class="n">bound</span><span class="o">.</span><span class="n">lower</span><span class="o">.</span><span class="n">is_Boolean</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">bound</span><span class="o">.</span><span class="n">lower</span><span class="o">.</span><span class="n">is_finite</span> <span class="ow">or</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">Pow</span><span class="p">),</span> <span class="p">(</span><span class="n">bound</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">bound</span><span class="o">.</span><span class="n">upper</span><span class="o">.</span><span class="n">is_rational</span> <span class="ow">or</span> <span class="n">bound</span><span class="o">.</span><span class="n">upper</span><span class="o">.</span><span class="n">is_Boolean</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">bound</span><span class="o">.</span><span class="n">upper</span><span class="o">.</span><span class="n">is_finite</span> <span class="ow">or</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">Pow</span><span class="p">),</span> <span class="p">(</span><span class="n">bound</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">DimDynamic</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Controls how to perform symbol allocation for a dimension.  It is always</span>
<span class="sd">    sound to default this to DYNAMIC, but the policies DUCK and STATIC can</span>
<span class="sd">    result in better trace-time and compile-time performance, as they reduce</span>
<span class="sd">    the number of allocated symbols and generally make your graph more static.</span>

<span class="sd">    NB: If we notice you&#39;ve applied a constraint to the dimension, we will</span>
<span class="sd">    force it to DYNAMIC for simplicity.</span>

<span class="sd">    DimDynamic is controlled by a variety of higher level UX features.</span>
<span class="sd">    Currently:</span>

<span class="sd">    - In eager mode, the default policy is DUCK.</span>
<span class="sd">        - The default is changed to STATIC with assume_static_by_default.</span>
<span class="sd">        - An individual dim is marked DYNAMIC if you mark_dynamic_dim.</span>
<span class="sd">    - In export mode, the default policy is STATIC.</span>
<span class="sd">        - An individual dim is marked DYNAMIC if you mention it as dynamic_dim</span>
<span class="sd">          in the constraints kwarg.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Treat the dimension symbolically</span>
    <span class="n">DYNAMIC</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># Treat the dimension symbolically, but if its hint matches another</span>
    <span class="c1"># dynamic dimension, unify the two symbols (&quot;duck sizing&quot;)</span>
    <span class="n">DUCK</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="c1"># Treat the dimension statically based on its hint</span>
    <span class="n">STATIC</span> <span class="o">=</span> <span class="mi">2</span>


<span class="c1"># NB: These constraints affect both clients and backends: given some</span>
<span class="c1"># constraint C, the client must pass inputs that satisfy the constraint,</span>
<span class="c1"># while a backend must not introduce guards BEYOND this constraint.</span>
<span class="c1"># For clarity, we document the implications on both sides for both the client</span>
<span class="c1"># and the backend.</span>
<span class="c1">#</span>
<span class="c1"># NB: These constraints are on a *single* dimension.  In principle, we could</span>
<span class="c1"># also have multi-dimension constraints, but our guess is that this is not</span>
<span class="c1"># actually useful and so we are not supporting it right now.</span>
<span class="c1">#</span>
<span class="c1"># NB: Strict constraints are typically only suitable for export, as in eager</span>
<span class="c1"># a backend like inductor may validly introduce extra, discretionary guards</span>
<span class="c1"># to improve performance of code.  A StrictMinMaxConstraint would be brittle</span>
<span class="c1"># under future optimizations performed by inductor; we don&#39;t guarantee</span>
<span class="c1"># eager code with StrictMinMaxConstraint will keep working in the future!</span>

<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Constraint</span><span class="p">:</span>
    <span class="n">warn_only</span><span class="p">:</span> <span class="nb">bool</span>

<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">StrictMinMaxConstraint</span><span class="p">(</span><span class="n">Constraint</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For clients: the size at this dimension must be within &#39;vr&#39; (which</span>
<span class="sd">    specifies a lower and upper bound, inclusive-inclusive) AND it</span>
<span class="sd">    must be non-negative and should not be 0 or 1 (but see NB below).</span>

<span class="sd">    For backends: there must not be any guards on this dimension which</span>
<span class="sd">    are not implied by the given lower and upper bound.  Regardless of</span>
<span class="sd">    the lower bound, the backend can assume the size is non-negative</span>
<span class="sd">    and that it is not 0 or 1.</span>

<span class="sd">    An unbounded StrictMinMaxConstraint can be thought of as a strict version</span>
<span class="sd">    of &quot;RelaxedUnspecConstraint&quot;.</span>

<span class="sd">    NB: Export will often unsoundly assume that a graph works for 0/1, even</span>
<span class="sd">    though at trace time we assumed size is not 0 or 1.  The idea is that</span>
<span class="sd">    if we produce a graph that works for a range of values, it will be OK</span>
<span class="sd">    for N=0/1 too.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vr</span><span class="p">:</span> <span class="n">ValueRanges</span>

    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="n">Source</span><span class="p">):</span>
        <span class="c1"># TODO: better printing for -oo and oo</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">vr</span><span class="o">.</span><span class="n">lower</span><span class="si">}</span><span class="s2"> &lt;= </span><span class="si">{</span><span class="n">source</span><span class="o">.</span><span class="n">name</span><span class="p">()</span><span class="si">}</span><span class="s2"> &lt;= </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">vr</span><span class="o">.</span><span class="n">upper</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">RelaxedUnspecConstraint</span><span class="p">(</span><span class="n">Constraint</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For clients: no explicit constraint; constraint is whatever is implicitly</span>
<span class="sd">    inferred by guards from tracing.</span>

<span class="sd">    For backends: there must exist at least TWO possible values for the</span>
<span class="sd">    size at this dimension which satisfy the guards for this dimension.</span>

<span class="sd">    In other words, this constraint helps us distinguish between &quot;we don&#39;t</span>
<span class="sd">    care if this dimension specializes or not&quot; versus &quot;this dimension must be</span>
<span class="sd">    unspecialized.&quot;  However, this constraint doesn&#39;t say very much about what</span>
<span class="sd">    specialization is permitted; for example, if we guard on a size being</span>
<span class="sd">    even, this would still be acceptable under an unspec constraint.  This</span>
<span class="sd">    makes RelaxedUnspecConstraint useful for eager mode, where your backend compiler</span>
<span class="sd">    may add constraints to otherwise dynamic dimensions; we can&#39;t assert that</span>
<span class="sd">    there are NO guards as this is brittle because compilers should be able to</span>
<span class="sd">    add extra constraints.  If you want to assert that there are no guards,</span>
<span class="sd">    use StrictMinMaxConstraint with an unbounded ValueRanges.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="n">Source</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;RelaxedUnspecConstraint(</span><span class="si">{</span><span class="n">source</span><span class="o">.</span><span class="n">name</span><span class="p">()</span><span class="si">}</span><span class="s2">)&quot;</span>

<span class="c1"># NB: None here indicates the client constraint is whatever is implicitly</span>
<span class="c1"># inferred by guards from tracing, and that a backend can add whatever guards</span>
<span class="c1"># it wants (including fully specializing the value).</span>
<span class="n">DimConstraint</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">StrictMinMaxConstraint</span><span class="p">,</span> <span class="n">RelaxedUnspecConstraint</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">EqualityConstraint</span><span class="p">(</span><span class="n">Constraint</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given pairs of sources corresponding to pairs of dynamic dimensions that</span>
<span class="sd">    are specified equal, represent them in a union-find data structure so that</span>
<span class="sd">    we can efficiently check whether two such sources are transitively equal.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">source_pairs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Source</span><span class="p">,</span> <span class="n">Source</span><span class="p">]]</span>

    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_parents&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="k">for</span> <span class="n">source1</span><span class="p">,</span> <span class="n">source2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_pairs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_union</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_find</span><span class="p">(</span><span class="n">source1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find</span><span class="p">(</span><span class="n">source2</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">source</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">source</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">source</span>

    <span class="k">def</span> <span class="nf">_union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root1</span><span class="p">,</span> <span class="n">root2</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">root1</span> <span class="o">!=</span> <span class="n">root2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="n">root1</span><span class="p">]</span> <span class="o">=</span> <span class="n">root2</span>

    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">source1</span><span class="o">.</span><span class="n">name</span><span class="p">()</span><span class="si">}</span><span class="s2"> == </span><span class="si">{</span><span class="n">source2</span><span class="o">.</span><span class="n">name</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">source1</span><span class="p">,</span> <span class="n">source2</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_pairs</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="n">buf</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span>

    <span class="k">def</span> <span class="nf">is_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source1</span><span class="p">,</span> <span class="n">source2</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find</span><span class="p">(</span><span class="n">source1</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find</span><span class="p">(</span><span class="n">source2</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_assert_symbol_context</span><span class="p">(</span><span class="n">symbolic_context</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">symbolic_context</span><span class="p">,</span> <span class="n">SymbolicContext</span><span class="p">),</span> <span class="s2">&quot;Invalid symbolic_context object&quot;</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">symbolic_context</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">SymbolicContext</span><span class="p">,</span> <span class="s2">&quot;Illegal usage of symbolic_context ABC&quot;</span>


<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">SymbolicContext</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Data structure specifying how we should create symbols in</span>
<span class="sd">    ``create_symbolic_sizes_strides_storage_offset``; e.g., should</span>
<span class="sd">    they be static or dynamic.</span>

<span class="sd">    This is an abstract base class because we are probably going to add</span>
<span class="sd">    another version of this that says &quot;use exactly these SymInts, don&#39;t</span>
<span class="sd">    allocate fresh symbols.&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>


<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">StatelessSymbolicContext</span><span class="p">(</span><span class="n">SymbolicContext</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create symbols in ``create_symbolic_sizes_strides_storage_offset`` via</span>
<span class="sd">    a symbolic_context determination as given by ``DimDynamic`` and ``DimConstraint``.</span>
<span class="sd">    This will cause fresh symbols to be allocated</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dynamic_sizes</span><span class="p">:</span> <span class="n">DimList</span><span class="p">[</span><span class="n">DimDynamic</span><span class="p">]</span>
    <span class="n">constraint_sizes</span><span class="p">:</span> <span class="n">DimList</span><span class="p">[</span><span class="n">DimConstraint</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># TODO: add storage offset and stride symbolic_context</span>

    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraint_sizes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;constraint_sizes&#39;</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_sizes</span><span class="p">))</span>


<span class="c1"># note [Tensor Fakification and Symbol Caching]</span>
<span class="c1">#</span>
<span class="c1"># As of the time of this note, dynamo creates a fresh fake tensor mode for backends.</span>
<span class="c1"># The reason we do this is because there are certain classes of operations, namely,</span>
<span class="c1"># metadata mutations, that change tensor size, stride, etc. This means that the fake tensor</span>
<span class="c1"># state at the end of a dynamo trace is different than the fake tensor state at the beginning</span>
<span class="c1"># of a trace. Backends like aot_autograd need a fresh fake tensor to correctly track metadata mutation,</span>
<span class="c1"># view relationships, etc.</span>
<span class="c1">#</span>
<span class="c1"># As we create a new fake mode, we also lose the memoization that comes with it. Rather than</span>
<span class="c1"># transfer the memoization cache, we instead transfer the shape env. However, with this</span>
<span class="c1"># comes nuance - as dynamo is selective in how it makes symbolic shapes. Due to strategies in</span>
<span class="c1"># automatic dynamic and constraints, the policy for which dims are dynamic is nuanced and varies across</span>
<span class="c1"># recompilations.</span>
<span class="c1">#</span>
<span class="c1"># In order to preserve the symbolic decisions made during dynamo tensor fakification, we pass</span>
<span class="c1"># a StatefulSymbolicContext at creation time. This object is tracked, per tensor, on the TracingContext.</span>
<span class="c1"># The lifecycle of this object should match the lifecycle of the original dynamo tracked tensor, and it is</span>
<span class="c1"># safe to reuse this object as many times as necessary to create a fake tensor. Fake tensors</span>
<span class="c1"># created with new fake modes should produce the same exact symbols as the original, providing the same shape_env</span>
<span class="c1"># is used.</span>
<span class="c1"># TODO(voz): Shape env validation</span>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">StatefulSymbolicContext</span><span class="p">(</span><span class="n">StatelessSymbolicContext</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create symbols in ``create_symbolic_sizes_strides_storage_offset`` via</span>
<span class="sd">    a symbolic_context determination as given by a cache of Source:Symbol. A cache hit</span>
<span class="sd">    will reuse a stored symbol, and a cache miss will write to this cache.</span>

<span class="sd">    This behaves like StatelessSymbolicContext, except the cache supersedes the</span>
<span class="sd">    other values - dynamic_sizes and constraint_sizes will not be read if we cache</span>
<span class="sd">    hit.</span>

<span class="sd">    It is the cache owners responsibility to maintain the lifecycle of the cache</span>
<span class="sd">    w/r/t different shape_envs, clearing, etc.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tensor_source</span><span class="p">:</span> <span class="n">Source</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># Why is this keyd on int first?</span>
    <span class="c1"># That integer is actually the id of the shape_env. This cache short-circuits symbol</span>
    <span class="c1"># creation, and we must store it per shape env. Now, while tracing invariants are a single</span>
    <span class="c1"># shape env per tracing context, and every new frame gets a new shape_env. So where would we have</span>
    <span class="c1"># multiple shape envs? The answer lies in recording. When we are replaying, replay_shape_env_events</span>
    <span class="c1"># is invoked, and creates a new shape_env. Replaying events against this new shape_env will</span>
    <span class="c1"># cause it to fail with unknown symbols, as the symbols cached here will skip creation, and never</span>
    <span class="c1"># get recorded in var_to_val, etc.</span>
    <span class="c1"># TODO(voz): consider a weakref to the shape_env here</span>
    <span class="n">shape_env_to_source_to_symbol_cache</span> <span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="s2">&quot;TensorPropertySource&quot;</span><span class="p">,</span> <span class="s2">&quot;sympy.Expr&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># The None default is annoying, but required because of dataclass limitations</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensor_source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_env_to_source_to_symbol_cache</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;shape_env_to_source_to_symbol_cache&#39;</span><span class="p">,</span> <span class="p">{})</span>


<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">SubclassSymbolicContext</span><span class="p">(</span><span class="n">StatefulSymbolicContext</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The correct symbolic context for a given inner tensor of a traceable tensor subclass</span>
<span class="sd">    may differ from that of the outer symbolic context. This structure allows for this</span>
<span class="sd">    flexibility, with inner symbolic contexts mapped via attr -&gt; symbolic context.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">inner_contexts</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">SymbolicContext</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inner_contexts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inner_contexts</span> <span class="o">=</span> <span class="p">{}</span>


<span class="k">def</span> <span class="nf">is_symbolic</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">SymInt</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">SymFloat</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">SymBool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="n">val</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">is_symbolic</span><span class="p">()</span>

<span class="n">IndicatorTypes</span> <span class="o">=</span> <span class="p">(</span><span class="n">IsNonOverlappingAndDenseIndicator</span><span class="p">,)</span>

<span class="nd">@lru_cache</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">safe_expand</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="s1">&#39;expand&#39;</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sympy</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">RecursionError</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;RecursionError in sympy.expand(</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">r</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">r</span>

<span class="k">def</span> <span class="nf">error</span><span class="p">():</span>
    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;shouldn&#39;t be hit&quot;</span><span class="p">)</span>


<span class="c1"># TODO: Deduplicate this with torch/_prims_common/__init__.py</span>
<span class="k">def</span> <span class="nf">eval_is_non_overlapping_and_dense</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="n">strides</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">guard_bool</span><span class="p">(</span><span class="n">_eval_is_non_overlapping_and_dense</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="n">strides</span><span class="p">)))</span>

<span class="k">def</span> <span class="nf">_eval_is_non_overlapping_and_dense</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="n">strides</span><span class="p">):</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span>

    <span class="c1"># Short-circuits for tensors of rank one, which are</span>
    <span class="c1"># non-overlapping and &quot;dense&quot; if their stride is one</span>
    <span class="c1"># or it is a 0/1 element tensor</span>
    <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">strides</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span>

    <span class="c1"># Checks that there exists a permutation of the strides s.t. the tensor would be contiguous</span>
    <span class="c1"># Sorts (length, stride) pairs by stride</span>
    <span class="n">lengths_and_strides</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
        <span class="nb">zip</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="n">strides</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Unlike the C++ code, we don&#39;t move the 0/1 size dimensions to the</span>
    <span class="c1"># end.  So we have to keep going for this code.</span>
    <span class="n">expected_stride</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">length</span><span class="p">,</span> <span class="n">stride</span> <span class="ow">in</span> <span class="n">lengths_and_strides</span><span class="p">:</span>

        <span class="k">if</span> <span class="n">length</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">stride</span> <span class="o">!=</span> <span class="n">expected_stride</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">expected_stride</span> <span class="o">*=</span> <span class="n">length</span>

    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">cast_symbool_to_symint_guardless</span><span class="p">(</span><span class="n">symbool</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">SymBool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">:</span>
    <span class="n">int_sym</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Piecewise</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">symbool</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">symbool</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">shape_env</span><span class="o">.</span><span class="n">create_symintnode</span><span class="p">(</span><span class="n">int_sym</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">symbool</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">require_hint</span><span class="p">()))</span>

<span class="n">SYMPY_INTERP</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;Abs&#39;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">abs</span><span class="p">,</span>
    <span class="s1">&#39;Eq&#39;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">eq</span><span class="p">,</span>
    <span class="s1">&#39;Ne&#39;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">ne</span><span class="p">,</span>
    <span class="s1">&#39;Gt&#39;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">gt</span><span class="p">,</span>
    <span class="s1">&#39;Lt&#39;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">lt</span><span class="p">,</span>
    <span class="s1">&#39;Le&#39;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">,</span>
    <span class="s1">&#39;Ge&#39;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">ge</span><span class="p">,</span>
    <span class="s1">&#39;Min&#39;</span><span class="p">:</span> <span class="nb">min</span><span class="p">,</span>
    <span class="s1">&#39;Max&#39;</span><span class="p">:</span> <span class="nb">max</span><span class="p">,</span>
    <span class="s1">&#39;Mod&#39;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">mod</span><span class="p">,</span>
    <span class="s1">&#39;FloorDiv&#39;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">floordiv</span><span class="p">,</span>
    <span class="s1">&#39;TrueDiv&#39;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">truediv</span><span class="p">,</span>
    <span class="s1">&#39;IsNonOverlappingAndDenseIndicator&#39;</span><span class="p">:</span> <span class="n">eval_is_non_overlapping_and_dense</span><span class="p">,</span>
    <span class="s1">&#39;floor&#39;</span><span class="p">:</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">,</span>
    <span class="s1">&#39;ceiling&#39;</span><span class="p">:</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">,</span>
    <span class="s1">&#39;cast_symbool_to_symint_guardless&#39;</span><span class="p">:</span> <span class="n">cast_symbool_to_symint_guardless</span><span class="p">,</span>
    <span class="s1">&#39;Round&#39;</span><span class="p">:</span> <span class="n">builtins</span><span class="o">.</span><span class="n">round</span><span class="p">,</span>
    <span class="s1">&#39;RoundDecimal&#39;</span><span class="p">:</span> <span class="n">builtins</span><span class="o">.</span><span class="n">round</span><span class="p">,</span>
<span class="p">}</span>


<span class="k">def</span> <span class="nf">_lru_cache</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">maxsize</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper around lru_cache that clears when new info about shapes has been</span>
<span class="sd">    updated.</span>

<span class="sd">    Use lru_cache if the output is always the same, regardless of the</span>
<span class="sd">    constraints we know now (i.e. evaluate_expr)</span>

<span class="sd">    Use _lru_cache otherwise.</span>

<span class="sd">    Also note that this depends on _update_version_counter being called on the</span>
<span class="sd">    shape environment whenever the constraints are updated, otherwise the cache</span>
<span class="sd">    will not be cleared.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fn_cache</span> <span class="o">=</span> <span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="p">)(</span><span class="n">fn</span><span class="p">)</span>
    <span class="n">prior_version</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">validate_shape_env_version_key</span><span class="p">:</span>
        <span class="n">prior_key</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">nonlocal</span> <span class="n">prior_version</span><span class="p">,</span> <span class="n">prior_key</span>
            <span class="k">if</span> <span class="n">prior_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">prior_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_key</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">prior_version</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_version_counter</span><span class="p">:</span>
                <span class="n">fn_cache</span><span class="o">.</span><span class="n">cache_clear</span><span class="p">()</span>
                <span class="n">prior_version</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_version_counter</span>
                <span class="n">prior_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_key</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">prior_key</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_key</span><span class="p">(),</span> \
                    <span class="s2">&quot;ShapeEnv cache key changed without version being updated!&quot;</span>

            <span class="k">return</span> <span class="n">fn_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">nonlocal</span> <span class="n">prior_version</span>
            <span class="k">if</span> <span class="n">prior_version</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_version_counter</span><span class="p">:</span>
                <span class="n">fn_cache</span><span class="o">.</span><span class="n">cache_clear</span><span class="p">()</span>
                <span class="n">prior_version</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_version_counter</span>

            <span class="k">return</span> <span class="n">fn_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">wrapper</span><span class="o">.</span><span class="n">cache_clear</span> <span class="o">=</span> <span class="n">fn_cache</span><span class="o">.</span><span class="n">cache_clear</span>
    <span class="n">wrapper</span><span class="o">.</span><span class="n">cache_info</span> <span class="o">=</span> <span class="n">fn_cache</span><span class="o">.</span><span class="n">cache_info</span>  <span class="c1"># type: ignore[attr-defined]</span>
    <span class="k">return</span> <span class="n">wrapper</span>


<span class="c1"># This is pretty similar to ShapeGuard but it also comes with a message,</span>
<span class="c1"># and is exclusively used for things that MUST be true (unlike guards,</span>
<span class="c1"># which can evaluate False, in which case you just choose not to use</span>
<span class="c1"># a particular specialization)</span>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">RuntimeAssert</span><span class="p">:</span>
    <span class="n">expr</span><span class="p">:</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Expr</span>
    <span class="n">msg</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="nb">repr</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">stack</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="nb">repr</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ShapeGuardPrinter</span><span class="p">(</span><span class="n">StrPrinter</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">symbol_to_source</span><span class="p">,</span>
        <span class="n">source_ref</span><span class="p">,</span>
        <span class="n">var_to_sources</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symbol_to_source</span> <span class="o">=</span> <span class="n">symbol_to_source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source_ref</span> <span class="o">=</span> <span class="n">source_ref</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">var_to_sources</span> <span class="o">=</span> <span class="n">var_to_sources</span>

    <span class="k">def</span> <span class="nf">_print_Not</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;not </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parenthesize</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">PRECEDENCE</span><span class="p">[</span><span class="s2">&quot;Not&quot;</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">_print_And</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stringify</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="s2">&quot; and &quot;</span><span class="p">,</span> <span class="n">PRECEDENCE</span><span class="p">[</span><span class="s2">&quot;And&quot;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_print_Or</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stringify</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="s2">&quot; or &quot;</span><span class="p">,</span> <span class="n">PRECEDENCE</span><span class="p">[</span><span class="s2">&quot;Or&quot;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_print_Symbol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">repr_symbol_to_source</span><span class="p">():</span>
            <span class="k">return</span> <span class="nb">repr</span><span class="p">({</span>
                <span class="n">symbol</span><span class="p">:</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">sources</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol_to_source</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">})</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol_to_source</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">expr</span><span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">expr</span><span class="si">}</span><span class="s2"> (could be from </span><span class="si">{</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="p">()</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">var_to_sources</span><span class="p">[</span><span class="n">expr</span><span class="p">]]</span><span class="si">}</span><span class="s2">) &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;not in </span><span class="si">{</span><span class="n">repr_symbol_to_source</span><span class="p">()</span><span class="si">}</span><span class="s2">.  If this assert is failing, it could be &quot;</span>
            <span class="s2">&quot;due to the issue described in https://github.com/pytorch/pytorch/pull/90665&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symbol_to_source</span><span class="p">[</span><span class="n">expr</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>


<span class="k">class</span> <span class="nc">LoggingShapeGuardPrinter</span><span class="p">(</span><span class="n">ShapeGuardPrinter</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_to_sources</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">var_to_sources</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span> <span class="n">var_to_sources</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">DynamicDimConstraintPrinter</span><span class="p">(</span><span class="n">StrPrinter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Printer for dynamic dim constraints.</span>
<span class="sd">    - Instead of t.size()[d] it prints dynamic_dim(t, d)</span>
<span class="sd">    - Instead of Eq(_, _), Mod(_, _), etc. it prints _ == _, _ % _, etc.</span>

<span class="sd">    We use this to suggest code for specifying dynamic dim constraints.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symbol_to_source</span><span class="p">,</span> <span class="n">source_name_to_debug_name</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symbol_to_source</span> <span class="o">=</span> <span class="n">symbol_to_source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source_name_to_debug_name</span> <span class="o">=</span> <span class="n">source_name_to_debug_name</span>

    <span class="k">def</span> <span class="nf">print_source</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_name_to_debug_name</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">source</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;dynamic_dim(</span><span class="si">{</span><span class="n">source</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">name</span><span class="p">()</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">source</span><span class="o">.</span><span class="n">idx</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span> <span class="nf">_print_Symbol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol_to_source</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">expr</span><span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unknown symbol </span><span class="si">{</span><span class="n">expr</span><span class="si">}</span><span class="s2"> created by constraints solver&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_source</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symbol_to_source</span><span class="p">[</span><span class="n">expr</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_print_Relational</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parenthesize</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="n">precedence</span><span class="p">(</span><span class="n">expr</span><span class="p">)),</span>
            <span class="n">expr</span><span class="o">.</span><span class="n">rel_op</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parenthesize</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">rhs</span><span class="p">,</span> <span class="n">precedence</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
        <span class="p">)</span>


<span class="k">class</span> <span class="nc">DimConstraints</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Custom solver for a system of constraints on symbolic dimensions.</span>
<span class="sd">    Solutions are &quot;static&quot; values or simplified &quot;dynamic&quot; constraints.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symbol_to_source</span><span class="p">,</span> <span class="n">var_to_val</span><span class="p">,</span> <span class="n">marked_dynamic</span><span class="p">,</span> <span class="n">source_name_to_debug_name</span><span class="p">):</span>
        <span class="c1"># We try to solve systems of inequalities with 1 free variable.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_univariate_inequalities</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">Set</span><span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">Expr</span><span class="p">]]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="c1"># Among them, we prioritize solving for a free variable that has equalities.</span>
        <span class="c1"># NOTE: _symbols_with_equalities is always a subset of _univariate_inequalities.keys()</span>
        <span class="c1"># and removing a symbol from the former =&gt; removing it from the latter.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_symbols_with_equalities</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="c1"># A solution of a free variable with equalities becomes a substitution.</span>
        <span class="c1"># We use these substitutions to simplify other constraints.</span>
        <span class="c1"># NOTE: removing a symbol from _symbols_with_equalities =&gt; adding it to _substitutions.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_substitutions</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Integer</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># In general, constraints may have // and % operations.</span>
        <span class="c1"># Of course, // can be expressed in terms of / and %.</span>
        <span class="c1"># Our inequality solver can handle / but not %. So we need to transform them away.</span>
        <span class="c1"># We do so by using the values of variables as hints to evaluate %.</span>
        <span class="c1"># For soundness we record additional congruence guards and solve them separately.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_var_to_val</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Integer</span><span class="p">]</span> <span class="o">=</span> <span class="n">var_to_val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_congruences</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">Expr</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>

        <span class="c1"># We do not try to (directly) solve inequalities with &gt; 1 free variables.</span>
        <span class="c1"># NOTE: free variables in these inequalities cannot also be in _substitutions.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_multivariate_inequalities</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">Expr</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># We park external equalities between free variables here.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_symbolic_equivalences</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Source</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Expr</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Solutions come in two forms:</span>
        <span class="c1"># - (static) specializations</span>
        <span class="c1"># - (dynamic) inequalities / congruences</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_static_results</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_results</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># printer for solutions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dcp</span> <span class="o">=</span> <span class="n">DynamicDimConstraintPrinter</span><span class="p">(</span><span class="n">symbol_to_source</span><span class="p">,</span> <span class="n">source_name_to_debug_name</span><span class="p">)</span>

        <span class="c1"># inconsistencies found on substituting with concrete values / static solutions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inconsistencies</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># symbols that are marked dynamic</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_marked_dynamic</span> <span class="o">=</span> <span class="n">marked_dynamic</span>

    <span class="k">def</span> <span class="nf">rewrite_with_congruences</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Eliminate expressions of the form b // d and b % d while adding congruences of the form b % d == k.</span>
<span class="sd">        This leaves rational operators (in particular of the form b / d) that our inequality solver can handle.</span>
<span class="sd">        We solve the added congruences separately (using our congruence solver, see below).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">mod_handler</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="c1"># Suppose that we have an expression of the form b % d with free variable s.</span>
            <span class="c1"># Using the value of s as a &quot;hint,&quot; we can evaluate b % d to a value k.</span>
            <span class="c1"># Then we can rewrite b % d to k while adding the guard b % d == k.</span>

            <span class="c1"># NOTE(avik): This abstraction is provably sound but, in general, incomplete. It is complete IFF</span>
            <span class="c1"># the original expression always evaluates to a constant value (i.e., it does not vary with s).</span>
            <span class="c1"># In other words,</span>
            <span class="c1"># - solutions of s with the rewritten expression are guaranteed to also be solutions of s with</span>
            <span class="c1">#   the original expression;</span>
            <span class="c1"># - while it may be possible to find solutions of s with the original expression that are not</span>
            <span class="c1">#   solutions with the rewritten expression, in that case the original expression cannot evaluate</span>
            <span class="c1">#   to the same value for all solutions of s.</span>
            <span class="c1">#</span>
            <span class="c1"># Should we be worried about this incompleteness? No, because of the following reasons:</span>
            <span class="c1"># 1. It unblocks dramatic simplification that would not be otherwise possible with current tech</span>
            <span class="c1">#    (i.e., &quot;don&#39;t let perfect be the enemy of the good&quot;).</span>
            <span class="c1"># 2. We already have a tradition of using hints to add guards in the compiler for making progress.</span>
            <span class="c1"># 3. We have not yet seen a counterexample arise in practice! In particular, any congruence guards</span>
            <span class="c1">#    we generate (or simplify to) seem to be of the form b % d == k where k is a constant.</span>
            <span class="c1">#</span>
            <span class="c1"># Here&#39;s a theoretical counterexample: 3*s % (s + 1) == s - 2, that is satisfied by all s &gt;= 2.</span>
            <span class="c1"># With any hint (say) s = k, we&#39;d rewrite this to: 3*s % (s + 1) == k - 2. But, substituting, we</span>
            <span class="c1"># would then get k - 2 == s - 2, and thus s = k as the (only, constant) solution!</span>
            <span class="n">base</span><span class="p">,</span> <span class="n">divisor</span> <span class="o">=</span> <span class="n">args</span>
            <span class="n">base</span><span class="p">,</span> <span class="n">divisor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rewrite_with_congruences</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">base</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">rewrite_with_congruences</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">divisor</span><span class="p">)</span>
            <span class="n">mod_reduced</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_var_to_val</span><span class="p">)</span> <span class="o">%</span> <span class="n">divisor</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_var_to_val</span><span class="p">)</span>
            <span class="n">congruence</span> <span class="o">=</span> <span class="p">(</span><span class="n">base</span> <span class="o">-</span> <span class="n">mod_reduced</span><span class="p">)</span> <span class="o">%</span> <span class="n">divisor</span>
            <span class="k">if</span> <span class="n">congruence</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_congruences</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">congruence</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">mod_reduced</span>

        <span class="k">def</span> <span class="nf">floor_div_handler</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="c1"># Suppose that we have an expression of the form b // d with free variable s.</span>
            <span class="c1"># Using the value of s, we can evaluate b % d to a value k.</span>
            <span class="c1"># Then we can rewrite b // d to (b - k) / d, while adding the guard b % d == k.</span>

            <span class="c1"># NOTE(avik): This is exactly equivalent to rewriting b // d as (b - (b % d)) / d</span>
            <span class="c1"># and eliminating b % d as above.</span>
            <span class="n">base</span><span class="p">,</span> <span class="n">divisor</span> <span class="o">=</span> <span class="n">args</span>
            <span class="n">base</span><span class="p">,</span> <span class="n">divisor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rewrite_with_congruences</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">base</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">rewrite_with_congruences</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">divisor</span><span class="p">)</span>
            <span class="n">mod_reduced</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_var_to_val</span><span class="p">)</span> <span class="o">%</span> <span class="n">divisor</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_var_to_val</span><span class="p">)</span>
            <span class="n">congruence</span> <span class="o">=</span> <span class="p">(</span><span class="n">base</span> <span class="o">-</span> <span class="n">mod_reduced</span><span class="p">)</span> <span class="o">%</span> <span class="n">divisor</span>
            <span class="k">if</span> <span class="n">congruence</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_congruences</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">congruence</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">base</span> <span class="o">-</span> <span class="n">mod_reduced</span><span class="p">)</span> <span class="o">/</span> <span class="n">divisor</span>

        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">Mod</span><span class="p">):</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">Mod</span><span class="p">,</span> <span class="n">mod_handler</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">FloorDiv</span><span class="p">):</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">FloorDiv</span><span class="p">,</span> <span class="n">floor_div_handler</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># Add an expression to the set of constraints.</span>
        <span class="c1"># Return whether the expression is a trivial constraint (i.e., an obvious tautology).</span>
        <span class="k">if</span> <span class="n">expr</span> <span class="o">==</span> <span class="n">sympy</span><span class="o">.</span><span class="n">true</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="n">orig_expr</span> <span class="o">=</span> <span class="n">expr</span>
        <span class="n">orig_reduced</span> <span class="o">=</span> <span class="n">orig_expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_var_to_val</span><span class="p">)</span>
        <span class="c1"># TODO(avik): https://github.com/pytorch/pytorch/issues/101093</span>
        <span class="c1"># It is possible that `expr` will fail the consistency check because of</span>
        <span class="c1"># precision errors. Specifically, on substituting its free symbols with</span>
        <span class="c1"># their concrete values, we might end up comparing floats. Until we have</span>
        <span class="c1"># a fix for this issue, we delay raising such failures. See solve().</span>
        <span class="k">if</span> <span class="n">orig_reduced</span> <span class="o">==</span> <span class="n">sympy</span><span class="o">.</span><span class="n">false</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inconsistencies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">orig_expr</span><span class="si">}</span><span class="s2"> is inconsistent!&quot;</span><span class="p">)</span>
        <span class="n">free_symbols</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">free_symbols</span>
        <span class="k">assert</span> <span class="n">free_symbols</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Did not expect constraint with no free variables: </span><span class="si">{</span><span class="n">expr</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">free_symbols</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># multivariate: record and move on</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_multivariate_inequalities</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># univariate: can solve these immediately</span>
            <span class="n">s</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">free_symbols</span><span class="p">))</span>
            <span class="c1"># eliminate // and % (see documentation of `rewrite_with_congruences` above)</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rewrite_with_congruences</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">expr</span> <span class="o">==</span> <span class="n">sympy</span><span class="o">.</span><span class="n">true</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="n">reduced</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_var_to_val</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">reduced</span> <span class="o">==</span> <span class="n">sympy</span><span class="o">.</span><span class="n">false</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_inconsistencies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">expr</span><span class="si">}</span><span class="s2">, obtained by rewriting </span><span class="si">{</span><span class="n">orig_expr</span><span class="si">}</span><span class="s2"> with congruences, &quot;</span>
                    <span class="s2">&quot;is inconsistent!&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Eq</span><span class="p">):</span>
                <span class="c1"># special status for symbols that have equalities (see `solve` below)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_symbols_with_equalities</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_univariate_inequalities</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">add_equality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
            <span class="c1"># specialization, right here</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_static_results</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">source</span><span class="o">.</span><span class="n">name</span><span class="p">()</span><span class="si">}</span><span class="s2"> == </span><span class="si">{</span><span class="n">expr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># these will resolve to either specializations or dynamic equality constraints</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_symbolic_equivalences</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">source</span><span class="p">,</span> <span class="n">expr</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">reduce_congruences</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">reduced_congruences</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">congruences</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_congruences</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">remainder_modulus_pairs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">congruences_to_check</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">congruence</span> <span class="ow">in</span> <span class="n">congruences</span><span class="p">:</span>
                <span class="n">base</span><span class="p">,</span> <span class="n">divisor</span> <span class="o">=</span> <span class="n">congruence</span><span class="o">.</span><span class="n">args</span>
                <span class="c1"># We are given a congruence of the form base % divisor == 0 with a free variable s. So:</span>
                <span class="c1"># - we transform this into an equation of the form base = divisor * tmp;</span>
                <span class="c1"># - we solve this equation for s to get a linear solution with free variable tmp.</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;tmp&quot;</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">symbol</span><span class="p">,</span> <span class="n">solution</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">solve_linear</span><span class="p">(</span><span class="n">base</span> <span class="o">-</span> <span class="n">divisor</span> <span class="o">*</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
                <span class="c1"># See https://docs.sympy.org/latest/modules/solvers/solvers.html#sympy.solvers.solvers.solve_linear</span>
                <span class="c1"># for how to interpret the results.</span>
                <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">symbol</span><span class="p">:</span>
                    <span class="c1"># This means the solution is of the form s = modulus*tmp + remainder.</span>
                    <span class="n">modulus</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">polys</span><span class="o">.</span><span class="n">polytools</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">solution</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">modulus</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Integer</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">remainder</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Integer</span><span class="p">):</span>
                        <span class="c1"># Make sure 0 &lt;= remainder &lt;= modulus.</span>
                        <span class="n">remainder</span> <span class="o">=</span> <span class="n">remainder</span> <span class="o">%</span> <span class="n">modulus</span>
                        <span class="n">remainder_modulus_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">remainder</span><span class="p">,</span> <span class="n">modulus</span><span class="p">))</span>
                        <span class="k">continue</span>
                <span class="c1"># This means that we did not get a unique solution to the equation.</span>
                <span class="c1"># No problem, we will check it.</span>
                <span class="n">congruences_to_check</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">congruence</span><span class="p">)</span>
            <span class="c1"># Finally we solve for a congruence s such that s = r_i mod m_i for each (r_i, m_i).</span>
            <span class="c1"># The solution will be a congruence of the form s = r mod m.</span>
            <span class="c1"># NOTE(avik): Since the given m_i may not be pairwise coprime, we can&#39;t just use CRT.</span>
            <span class="k">if</span> <span class="n">remainder_modulus_pairs</span><span class="p">:</span>
                <span class="n">remainder</span><span class="p">,</span> <span class="n">modulus</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">ntheory</span><span class="o">.</span><span class="n">modular</span><span class="o">.</span><span class="n">solve_congruence</span><span class="p">(</span><span class="o">*</span><span class="n">remainder_modulus_pairs</span><span class="p">)</span>
                <span class="n">reduced_congruences</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="p">{(</span><span class="n">s</span> <span class="o">-</span> <span class="n">remainder</span><span class="p">)</span> <span class="o">%</span> <span class="n">modulus</span><span class="p">}</span>
                <span class="n">substitution</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span><span class="p">:</span> <span class="n">modulus</span> <span class="o">*</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;tmp&quot;</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">+</span> <span class="n">remainder</span><span class="p">}</span>
                <span class="n">reduced_congruences</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="n">congruence</span> <span class="k">for</span> <span class="n">congruence</span> <span class="ow">in</span> <span class="n">congruences_to_check</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">sympy</span><span class="o">.</span><span class="n">checksol</span><span class="p">(</span><span class="n">congruence</span><span class="p">,</span> <span class="n">substitution</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">reduced_congruences</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">congruences_to_check</span>

        <span class="k">return</span> <span class="n">reduced_congruences</span>

    <span class="k">def</span> <span class="nf">raise_inconsistencies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inconsistencies</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_inconsistencies</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inconsistencies</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The following inconsistencies were found:</span><span class="se">\n</span><span class="si">{</span><span class="n">msg</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_force_specialization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_to_val</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_static_results</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_dcp</span><span class="o">.</span><span class="n">symbol_to_source</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">()</span><span class="si">}</span><span class="s2"> == </span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_substitutions</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="k">def</span> <span class="nf">specialize_divisor_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multivariate_inequalities</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">FloorDiv</span><span class="p">,</span> <span class="n">Mod</span><span class="p">):</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">divisor</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">args</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">divisor</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_force_specialization</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

        <span class="n">multivariate_inequalities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multivariate_inequalities</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_multivariate_inequalities</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">multivariate_inequalities</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_substitutions</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raise_inconsistencies</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_univariate_inequalities</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">s</span><span class="p">:</span> <span class="n">exprs</span>
            <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">exprs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_univariate_inequalities</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_substitutions</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_congruences</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">s</span><span class="p">:</span> <span class="n">congruences</span>
            <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">congruences</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_congruences</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_substitutions</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">disable_congruences</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">disable_equivalences</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raise_inconsistencies</span><span class="p">()</span>
        <span class="c1"># as long as there are symbols with equalities, solve for them</span>
        <span class="c1"># NOTE(avik): this is guaranteed to terminate (#iterations &lt;= #symbols)</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_symbols_with_equalities</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_symbols_with_equalities</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">exprs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_univariate_inequalities</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">solution</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">solvers</span><span class="o">.</span><span class="n">inequalities</span><span class="o">.</span><span class="n">reduce_inequalities</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">solution</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">And</span><span class="p">):</span>
                <span class="n">solution</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">arg</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">solution</span><span class="o">.</span><span class="n">args</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Eq</span><span class="p">)),</span> <span class="n">solution</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">solution</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Eq</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Expected an equality constraint for </span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2">, got </span><span class="si">{</span><span class="n">solution</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">symbol</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="n">args</span>
            <span class="k">assert</span> <span class="n">symbol</span> <span class="o">==</span> <span class="n">s</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Expected a constraint on </span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2"> instead of on </span><span class="si">{</span><span class="n">symbol</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="c1"># because this is univariate, the solution is a specialization</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_static_results</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_dcp</span><span class="o">.</span><span class="n">symbol_to_source</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">()</span><span class="si">}</span><span class="s2"> == </span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># add this as a substitution to simplify other constraints</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_substitutions</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

            <span class="c1"># simplify multivariate inequalities: some of them will now become univariate!</span>
            <span class="n">multivariate_inequalities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multivariate_inequalities</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_multivariate_inequalities</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">multivariate_inequalities</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_substitutions</span><span class="p">[</span><span class="n">s</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">raise_inconsistencies</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">specialize_divisor_symbols</span><span class="p">()</span>

        <span class="c1"># solve linear congruences</span>
        <span class="c1"># NOTE(avik): We do not need to solve them for symbols that have already been specialized.</span>
        <span class="n">reduced_congruences</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduce_congruences</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">congruences</span> <span class="ow">in</span> <span class="n">reduced_congruences</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">congruence</span> <span class="ow">in</span> <span class="n">congruences</span><span class="p">:</span>
                <span class="c1"># any congruence that cannot be checked becomes a dynamic constraint as well</span>
                <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_substitutions</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">sympy</span><span class="o">.</span><span class="n">checksol</span><span class="p">(</span><span class="n">congruence</span><span class="p">,</span> <span class="p">{</span><span class="n">s</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_substitutions</span><span class="p">[</span><span class="n">s</span><span class="p">]}):</span>
                    <span class="k">if</span> <span class="n">disable_congruences</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_force_specialization</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_univariate_inequalities</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_results</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dcp</span><span class="o">.</span><span class="n">doprint</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">Eq</span><span class="p">(</span><span class="n">congruence</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>

        <span class="c1"># remaining symbols have only pure inequalities (no equalities)</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">exprs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_univariate_inequalities</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">solution</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">solvers</span><span class="o">.</span><span class="n">inequalities</span><span class="o">.</span><span class="n">reduce_inequalities</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
                <span class="c1"># because this is univariate, the solution is a dynamic (range) constraint</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">solution</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">And</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">solution</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_results</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dcp</span><span class="o">.</span><span class="n">doprint</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_results</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dcp</span><span class="o">.</span><span class="n">doprint</span><span class="p">(</span><span class="n">solution</span><span class="p">))</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">NotImplementedError</span><span class="p">,</span> <span class="ne">AssertionError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Failed to reduce inequalities: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">exprs</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_results</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dcp</span><span class="o">.</span><span class="n">doprint</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>

        <span class="c1"># simplify symbolic equivalences: some of them will now become specializations!</span>
        <span class="n">symbolic_equivalences</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_symbolic_equivalences</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_symbolic_equivalences</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">source</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">symbolic_equivalences</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">disable_equivalences</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_force_specialization</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                    <span class="n">sexpr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dcp</span><span class="o">.</span><span class="n">_print_Symbol</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_results</span> <span class="o">=</span> <span class="p">{</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_results</span> <span class="k">if</span> <span class="n">sexpr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">r</span><span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_equality</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_substitutions</span><span class="p">))</span>

        <span class="c1"># remaining symbolic equivalences become dynamic equality constraints</span>
        <span class="k">for</span> <span class="n">source</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_symbolic_equivalences</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_results</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_dcp</span><span class="o">.</span><span class="n">print_source</span><span class="p">(</span><span class="n">source</span><span class="p">)</span><span class="si">}</span><span class="s2"> == </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_dcp</span><span class="o">.</span><span class="n">doprint</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forced_specializations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">debug_name</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dcp</span><span class="o">.</span><span class="n">source_name_to_debug_name</span><span class="p">:</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_dcp</span><span class="o">.</span><span class="n">source_name_to_debug_name</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">name</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="n">debug_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dcp</span><span class="o">.</span><span class="n">symbol_to_source</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="mi">0</span><span class="p">]):</span> <span class="n">val</span>
            <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_substitutions</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_marked_dynamic</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">remove_redundant_dynamic_results</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">candidates_for_removal</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dynamic_results</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">dc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_results</span><span class="p">:</span>
            <span class="c1"># Instead of 2 &lt;= dynamic_dim(...) simply suggest dynamic_dim(...).</span>
            <span class="c1"># There is no change in behavior since 2 is the default lower bound.</span>
            <span class="n">dc_</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;2 &lt;= dynamic_dim(.+)&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;dynamic_dim\1&quot;</span><span class="p">,</span> <span class="n">dc</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dc</span> <span class="o">!=</span> <span class="n">dc_</span><span class="p">:</span>
                <span class="n">candidates_for_removal</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dc_</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dynamic_results</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dc_</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">dc</span> <span class="ow">in</span> <span class="n">candidates_for_removal</span><span class="p">:</span>
            <span class="c1"># remove dynamic_dim(t, 0) as a constraint when dynamic_dim(t, 0) also</span>
            <span class="c1"># appears as part of another constraint</span>
            <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">other_dc</span> <span class="ow">in</span> <span class="n">dynamic_results</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dc</span> <span class="ow">in</span> <span class="n">other_dc</span><span class="p">:</span>
                    <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
                <span class="n">dynamic_results</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_results</span> <span class="o">=</span> <span class="n">dynamic_results</span>

    <span class="k">def</span> <span class="nf">prettify_results</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">original_signature</span><span class="p">:</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Signature</span><span class="p">,</span>
        <span class="n">constraint_violation_error</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">forced_specializations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dcp</span><span class="o">.</span><span class="n">source_name_to_debug_name</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dcp</span><span class="o">.</span><span class="n">source_name_to_debug_name</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">s</span>

            <span class="n">results</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">flip</span><span class="p">(</span><span class="n">op</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;&lt;=&quot;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="s2">&quot;&gt;=&quot;</span>
                <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;&gt;=&quot;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="s2">&quot;&lt;=&quot;</span>
                <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;&lt;&quot;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="s2">&quot;&gt;&quot;</span>
                <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="s2">&quot;&lt;&quot;</span>
                <span class="k">assert</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;==&quot;</span>
                <span class="k">return</span> <span class="n">op</span>

            <span class="k">def</span> <span class="nf">relation_with_digit</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">digit</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;&lt;=&quot;</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">expr</span><span class="p">][</span><span class="s2">&quot;max&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">digit</span>
                <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;&lt;&quot;</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">expr</span><span class="p">][</span><span class="s2">&quot;max&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">digit</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;&gt;=&quot;</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">expr</span><span class="p">][</span><span class="s2">&quot;min&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">digit</span>
                <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">expr</span><span class="p">][</span><span class="s2">&quot;min&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">digit</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;==&quot;</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">expr</span><span class="p">][</span><span class="s2">&quot;eq&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">digit</span>

            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_static_results</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_results</span><span class="p">):</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="n">s</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">left</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;==&quot;</span> <span class="ow">and</span> <span class="n">left</span> <span class="o">==</span> <span class="n">right</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">right</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
                    <span class="n">relation_with_digit</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">right</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">left</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
                    <span class="n">relation_with_digit</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">flip</span><span class="p">(</span><span class="n">op</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">left</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;==&quot;</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">left</span><span class="p">][</span><span class="s2">&quot;eq&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">right</span>

            <span class="n">buf</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="n">debug_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">forced_specializations</span><span class="p">:</span>
                <span class="n">debug_names</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; = &quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">forced_specializations</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="n">buf</span> <span class="o">+=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Specializations unexpectedly required (</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">debug_names</span><span class="p">)</span><span class="si">}</span><span class="s2">)! &quot;</span>
                    <span class="s2">&quot;For more information, run with TORCH_LOGS=</span><span class="se">\&quot;</span><span class="s2">+dynamic</span><span class="se">\&quot;</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">forced_specializations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">buf</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;  - </span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2"> must be specialized to </span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2"> because the guards generated for it are too complex.</span><span class="se">\n</span><span class="s2">&quot;</span>

            <span class="n">dims</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">others</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">match</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">constraint_violation_error</span><span class="p">:</span>
                <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Constraints violated \((.*)\)&quot;</span><span class="p">,</span> <span class="n">constraint_violation_error</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">debug_names</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">results</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">debug_names</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="s2">&quot;eq&quot;</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
                    <span class="n">other</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="s2">&quot;eq&quot;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                        <span class="n">others</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> = None  # </span><span class="si">{</span><span class="n">other</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">others</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">other</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">min_</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;min&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">min_</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">min_</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">max_</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;max&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">min_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">max_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> = Dim(&#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&#39;, min=</span><span class="si">{</span><span class="n">min_</span><span class="si">}</span><span class="s2">, max=</span><span class="si">{</span><span class="n">max_</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">min_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> = Dim(&#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&#39;, min=</span><span class="si">{</span><span class="n">min_</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">max_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> = Dim(&#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&#39;, max=</span><span class="si">{</span><span class="n">max_</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> = Dim(&#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&#39;)&quot;</span><span class="p">)</span>

            <span class="n">buf</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Suggested fixes:</span><span class="se">\n</span><span class="s2">  &quot;</span>
            <span class="n">buf</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dims</span> <span class="o">+</span> <span class="n">others</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">buf</span>

        <span class="c1"># Note: Model inputs are wrapped as LocalSource in dynamo.</span>
        <span class="c1"># LocalSource.name() wraps the name with L[&quot;&quot;]. We use regular</span>
        <span class="c1"># expression to do the replacement to avoid traversing up</span>
        <span class="c1"># the source hierarchy manually.</span>
        <span class="k">def</span> <span class="nf">extract_and_rewrite_local</span><span class="p">(</span><span class="n">dc</span><span class="p">):</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;L\[&#39;(.+?)&#39;\]&quot;</span><span class="p">,</span> <span class="n">dc</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\1&#39;</span><span class="p">)</span>
            <span class="n">dc</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;L\[&#39;(.+?)&#39;\]&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\1&#39;</span><span class="p">,</span> <span class="n">dc</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">arg</span><span class="p">,</span> <span class="n">dc</span>

        <span class="k">def</span> <span class="nf">group</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">args_index</span><span class="p">):</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">dc</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                <span class="n">local</span> <span class="o">=</span> <span class="n">extract_and_rewrite_local</span><span class="p">(</span><span class="n">dc</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">local</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># This can happen, e.g., with `assume_constant_result`.</span>
                    <span class="c1"># In that case, we drop the constraint.</span>
                    <span class="c1"># TODO(avik) Maybe we should generate an assertion here?</span>
                    <span class="k">continue</span>
                <span class="n">arg</span><span class="p">,</span> <span class="n">dc</span> <span class="o">=</span> <span class="n">local</span>
                <span class="k">if</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args_index</span><span class="p">:</span>
                    <span class="n">groups</span><span class="p">[</span><span class="n">args_index</span><span class="p">[</span><span class="n">arg</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dc</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># This can happen, e.g., with decorators that change the signature.</span>
                    <span class="c1"># In that case, we drop the constraint. Seems hard to do better. :/</span>
                    <span class="c1"># TODO(avik) Maybe warn that `arg` in not in `signature`?</span>
                    <span class="k">continue</span>
            <span class="n">sorted_groups</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">dcs</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">groups</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">arg</span> <span class="o">=</span> <span class="n">idx</span>
                <span class="n">sorted_groups</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">arg</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dcs</span><span class="p">)))</span>
            <span class="k">return</span> <span class="n">sorted_groups</span>

        <span class="n">signature</span> <span class="o">=</span> <span class="n">original_signature</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">return_annotation</span><span class="o">=</span><span class="n">inspect</span><span class="o">.</span><span class="n">Signature</span><span class="o">.</span><span class="n">empty</span><span class="p">)</span>
        <span class="n">args_index</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">signature</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">args_index</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">print_results</span><span class="p">(</span><span class="n">grouped</span><span class="p">,</span> <span class="n">indent</span><span class="p">,</span> <span class="n">result_fn</span><span class="p">):</span>
            <span class="k">nonlocal</span> <span class="n">buf</span>

            <span class="n">space</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">results</span> <span class="ow">in</span> <span class="n">grouped</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">space</span><span class="p">:</span>
                    <span class="n">buf</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">space</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">buf</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="n">indent</span><span class="si">}</span><span class="s2"># </span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="s2">:&quot;</span>
                <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                    <span class="n">buf</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="n">indent</span><span class="si">}{</span><span class="n">result_fn</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="n">buf</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="n">forced_specializations</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="s2">&quot;Some dynamic dimensions need to be specialized because &quot;</span>
                <span class="s2">&quot;the constraints inferred for them are too complex to specify.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">forced_specializations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">buf</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;  - </span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2">, which was marked dynamic, must be specialized to </span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">indent</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="s2">&quot; &quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_static_results</span><span class="p">:</span>
            <span class="n">grouped_static_results</span> <span class="o">=</span> <span class="n">group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_static_results</span><span class="p">,</span> <span class="n">args_index</span><span class="p">)</span>
            <span class="n">buf</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">The following dimensions have been specialized and CANNOT be dynamic.&quot;</span>
            <span class="n">buf</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">```</span><span class="se">\n</span><span class="s2">def specializations</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">signature</span><span class="p">)</span><span class="si">}</span><span class="s2">:&quot;</span>
            <span class="n">print_results</span><span class="p">(</span>
                <span class="n">grouped_static_results</span><span class="p">,</span>
                <span class="n">indent</span><span class="p">,</span>
                <span class="k">lambda</span> <span class="n">result</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;assert </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">buf</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">```</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_results</span><span class="p">:</span>
            <span class="n">grouped_dynamic_results</span> <span class="o">=</span> <span class="n">group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_results</span><span class="p">,</span> <span class="n">args_index</span><span class="p">)</span>
            <span class="n">buf</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">The following dimensions CAN be dynamic.&quot;</span>
            <span class="n">buf</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Please use the following code to specify the constraints they must satisfy:&quot;</span>
            <span class="n">buf</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">```</span><span class="se">\n</span><span class="s2">def specify_constraints</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">signature</span><span class="p">)</span><span class="si">}</span><span class="s2">:&quot;</span>
            <span class="n">buf</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="n">indent</span><span class="si">}</span><span class="s2">return [&quot;</span>
            <span class="n">print_results</span><span class="p">(</span>
                <span class="n">grouped_dynamic_results</span><span class="p">,</span>
                <span class="n">indent</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
                <span class="k">lambda</span> <span class="n">result</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">buf</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="n">indent</span><span class="si">}</span><span class="s2">]</span><span class="se">\n</span><span class="s2">```</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">buf</span>



<span class="n">TLS</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">local</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">ShapeEnv</span><span class="p">:</span>
    <span class="c1"># This is a wrapper over the actual __init__ function.</span>
    <span class="c1">#</span>
    <span class="c1"># Where to add a new constructor parameter to ShapeEnv?</span>
    <span class="c1"># =====================================================</span>
    <span class="c1"># This __init__ function should be used only for parameters related to event recording.</span>
    <span class="c1"># These are parameters that we don&#39;t wish to pass down the road to new ShapeEnv instances</span>
    <span class="c1"># created from replaying events.</span>
    <span class="c1">#</span>
    <span class="c1"># If you wish to add a parameter to the constructor of ShapeEnv, unrelated to event</span>
    <span class="c1"># recording, do so in the _init function.</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
        <span class="n">should_record_events</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tracked_fakes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Disable event recording when replaying.</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;should_record_events&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="kn">from</span> <span class="nn">torch.fx.experimental.validator</span> <span class="kn">import</span> <span class="n">translation_validation_enabled</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_translation_validation_enabled</span> <span class="o">=</span> <span class="n">translation_validation_enabled</span><span class="p">()</span>

        <span class="c1"># If not specified, enable event recording if both:</span>
        <span class="c1">#   - Translation validation is on</span>
        <span class="c1">#   - Translation validation bisection is not disabled</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">should_record_events</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">should_record_events</span>
            <span class="k">if</span> <span class="n">should_record_events</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_translation_validation_enabled</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">config</span><span class="o">.</span><span class="n">translation_validation_no_bisect</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Enable event recording check if both:</span>
        <span class="c1">#   - It should record events</span>
        <span class="c1">#   - The recording check is enabled</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_recorded_events</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">should_record_events</span> <span class="ow">and</span> <span class="n">config</span><span class="o">.</span><span class="n">check_shape_env_recorded_events</span>
        <span class="p">)</span>

        <span class="c1"># This will make sure we only record the top-level function call.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_recording</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">should_record_events</span>
        <span class="c1"># Keep track of the list of tracked fakes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracked_fakes</span> <span class="o">=</span> <span class="n">tracked_fakes</span>
        <span class="c1"># List of events for reconstructing ShapeEnv at arbitrary points in time.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ShapeEnvEvent</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">[</span><span class="n">ShapeEnvEvent</span><span class="p">(</span><span class="n">ShapeEnv</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">should_record_events</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
        <span class="n">allow_scalar_outputs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">allow_dynamic_output_shape_ops</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="c1"># NB: These are legacy configuration that help us make good choices</span>
        <span class="c1"># when the constraint/dynamic dims are not explicitly passed to us.</span>
        <span class="c1"># Ideally we will fix all call sites to be explicit and not have</span>
        <span class="c1"># implicit choices, but this apparently was pretty involved.</span>
        <span class="n">assume_static_by_default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="c1"># Note - On 0/1 specialization</span>
        <span class="c1">#</span>
        <span class="c1"># The following options affect decisions we make about eager</span>
        <span class="c1"># specialization.  Disabling them will increase trace time (as we do</span>
        <span class="c1"># more symbolic reasoning) and can also harm the quality of generated</span>
        <span class="c1"># code (because inductor may not be able to specialize for bounds</span>
        <span class="c1"># being equal--although if we later respecialize because of a guard,</span>
        <span class="c1"># your code may be just as good as it was before.)</span>
        <span class="c1">#</span>
        <span class="c1"># When True, eagerly specialize input sizes which have 0/1.</span>
        <span class="n">specialize_zero_one</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="c1"># When True, assume input sizes which have the same size are</span>
        <span class="c1"># symbolically equal.</span>
        <span class="n">duck_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="c1"># For debugging</span>
        <span class="n">co_fields</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="c1"># XXX Add any new settings that could affect FakeTensor evaluation</span>
        <span class="c1"># to: torch._subclasses.fake_tensor._ShapeEnvSettings</span>
    <span class="p">):</span>
        <span class="c1"># Not directly used by ShapeEnv; indirectly used by FakeTensor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allow_scalar_outputs</span> <span class="o">=</span> <span class="n">allow_scalar_outputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allow_dynamic_output_shape_ops</span> <span class="o">=</span> <span class="n">allow_dynamic_output_shape_ops</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">guards</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ShapeGuard</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Maps symbolic ints to their original concrete values</span>
        <span class="c1"># Currently populated from tensors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">var_to_val</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Integer</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Maps symbolic ints to their min/max range.  These ranges</span>
        <span class="c1"># are conservative: the int MUST fall in the range, but the</span>
        <span class="c1"># range may contain ints which may not actually appear in</span>
        <span class="c1"># practice</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">var_to_range</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">ValueRanges</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source_name_to_debug_name</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">var_to_sources</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Source</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">var_to_stack</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">CapturedTraceback</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Maps symbolic ints to the guards that refine their lower/upper</span>
        <span class="c1"># bound. If one of them is None, it means that there are no guards</span>
        <span class="c1"># that refine that respective bound.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">var_to_guards</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">ShapeGuard</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ShapeGuard</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Maps from sympy ints to expressions representing them</span>
        <span class="c1"># Populated from equality guards (i.e. a.shape[0] == b.shape[0])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replacements</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Expr</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1">#</span>
        <span class="c1"># Set holds a % b expressions that evaluate to 0.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">divisible</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">Expr</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="c1"># Set that holds &quot;size-like&quot; expressions.  When we perform</span>
        <span class="c1"># &quot;size-oblivious&quot; tests, these can be assumed to be &gt;= 2.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size_like</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">Expr</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="c1"># Duck-shaping says that if two input tensors have the same size,</span>
        <span class="c1"># they get assigned the same symbolic variable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val_to_var</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Expr</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">specialize_zero_one</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">val_to_var</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Integer</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">:</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Integer</span><span class="p">(</span><span class="mi">1</span><span class="p">)}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unbacked_symfloat_counter</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unbacked_symint_counter</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
        <span class="c1"># Similar to guards, but these MUST evaluate to true and can</span>
        <span class="c1"># only be evaluated at runtime midway through (i.e., they always</span>
        <span class="c1"># involve unbacked symints)</span>
        <span class="c1">#</span>
        <span class="c1"># For efficiency reasons, we index in the following way.  Suppose you have</span>
        <span class="c1"># a runtime assert i0 + i1 &lt;= s1.  We pick the most recently allocated</span>
        <span class="c1"># symbol in the source expression and add the assert to the list for</span>
        <span class="c1"># that symbol e.g., {i1: [i0 + i1 &lt;= s1]}.</span>
        <span class="c1">#</span>
        <span class="c1"># We access the runtime asserts in two situations:</span>
        <span class="c1">#</span>
        <span class="c1">#   - When we are guarding on an expression, we will attempt to</span>
        <span class="c1">#     statically evaluate it, in case the unbacked SymInts can</span>
        <span class="c1">#     simplify away.  If we have a runtime assert, we may be able</span>
        <span class="c1">#     to discharge the guard entirely.  We only need to attempt</span>
        <span class="c1">#     runtime asserts that mention freevars of the expression in</span>
        <span class="c1">#     question.</span>
        <span class="c1">#</span>
        <span class="c1">#   - When we are performing codegen (in Inductor for eager, or</span>
        <span class="c1">#     when finalizing the export FX graph), we need to know what</span>
        <span class="c1">#     extra runtime asserts to insert.  Whenever an unbacked</span>
        <span class="c1">#     SymInt comes into scope, all runtime asserts involving it</span>
        <span class="c1">#     become eligible for insertion (so long as all of their other</span>
        <span class="c1">#     free unbacked symbols are also in scope).  We technically</span>
        <span class="c1">#     can handle any choice of key by kicking inexpressible asserts</span>
        <span class="c1">#     to the next unbacked symbol to wait on, but if we choose the</span>
        <span class="c1">#     latest key, an assert will only show up at the moment when</span>
        <span class="c1">#     we can actually codegen it.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deferred_runtime_asserts</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">RuntimeAssert</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># This exists so we can efficiently invalidate the cache (it&#39;s used as</span>
        <span class="c1"># part of the cache key); otherwise we&#39;d have to iterate through</span>
        <span class="c1"># deferred_runtime_asserts to compute its length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_deferred_runtime_asserts</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assume_static_by_default</span> <span class="o">=</span> <span class="n">assume_static_by_default</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">specialize_zero_one</span> <span class="o">=</span> <span class="n">specialize_zero_one</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duck_shape</span> <span class="o">=</span> <span class="n">duck_shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">log</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;create_env&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frozen</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim_constraints</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DimConstraints</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">counter</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">()</span>
        <span class="c1"># A selection of important fields on co_field; solely used for</span>
        <span class="c1"># signpost_event</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">co_fields</span> <span class="o">=</span> <span class="n">co_fields</span> <span class="k">if</span> <span class="n">co_fields</span> <span class="k">else</span> <span class="p">{}</span>

        <span class="c1"># Version counter used to invalidate cached values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prev_cache_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_key</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_version_counter</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Cache for FX nodes.</span>
        <span class="c1"># Maps an already built node a tuple of:</span>
        <span class="c1">#   1. node&#39;s target</span>
        <span class="c1">#   2. list of arguments</span>
        <span class="c1"># This drastically reduces the size of the FX graph, avoiding</span>
        <span class="c1"># duplicated nodes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fx_node_cache</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Callable</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span> <span class="n">torch</span><span class="o">.</span><span class="n">fx</span><span class="o">.</span><span class="n">Node</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source_to_symbol</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="kn">from</span> <span class="nn">torch.fx.experimental.validator</span> <span class="kn">import</span> <span class="n">translation_validation_enabled</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_translation_validation_enabled</span> <span class="o">=</span> <span class="n">translation_validation_enabled</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_translation_validation_enabled</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">torch.fx.experimental.validator</span> <span class="kn">import</span> <span class="n">TranslationValidator</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">validator</span> <span class="o">=</span> <span class="n">TranslationValidator</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">fx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
            <span class="c1"># Create an output graph and start inserting before that.</span>
            <span class="c1"># This is needed when &#39;deepcopy&#39;-ing this object.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">inserting_before</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">output</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>

            <span class="c1"># Mapping of each node name to the node itself.</span>
            <span class="c1">#</span>
            <span class="c1"># This is useful for matching an FX node from a recorded ShapeEnv.graph</span>
            <span class="c1"># to the FX node of the ShapeEnv we are running the event on.</span>
            <span class="c1">#</span>
            <span class="c1"># Whenever you add a node to self.graph, you must add a mapping to this</span>
            <span class="c1"># variable. Otherwise, the built FX graph on the replayed ShapeEnv will</span>
            <span class="c1"># not be valid.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name_to_node</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">fx</span><span class="o">.</span><span class="n">Node</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">check_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;ShapeEnv&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># ShapeEnv fields that are not relevant for the outcome of</span>
        <span class="c1"># ShapeEnv.produce_guards call:</span>
        <span class="c1">#   - Debugging variables</span>
        <span class="c1">#   - Translation validation related variables</span>
        <span class="c1">#   - Events recording related variables</span>
        <span class="n">non_state_variable_names</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;counter&quot;</span><span class="p">,</span>
            <span class="s2">&quot;log&quot;</span><span class="p">,</span>
            <span class="s2">&quot;var_to_stack&quot;</span><span class="p">,</span>
            <span class="s2">&quot;fx_node_cache&quot;</span><span class="p">,</span>
            <span class="s2">&quot;graph&quot;</span><span class="p">,</span>
            <span class="s2">&quot;validator&quot;</span><span class="p">,</span>
            <span class="s2">&quot;check_recorded_events&quot;</span><span class="p">,</span>
            <span class="s2">&quot;should_record_events&quot;</span><span class="p">,</span>
            <span class="s2">&quot;is_recording&quot;</span><span class="p">,</span>
            <span class="s2">&quot;tracked_fakes&quot;</span><span class="p">,</span>
            <span class="s2">&quot;events&quot;</span><span class="p">,</span>
            <span class="s2">&quot;source_name_to_debug_name&quot;</span><span class="p">,</span>
            <span class="s2">&quot;_prev_cache_key&quot;</span><span class="p">,</span>
            <span class="s2">&quot;_version_counter&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Mapping of the value of each to-be-compared field into the values that</span>
        <span class="c1"># should actually be compared.</span>
        <span class="c1">#</span>
        <span class="c1"># You should modify this if, for example, the field that holds state and</span>
        <span class="c1"># debugging information. e.g. ShapeGuard holds the actual guard (sympy.Expr)</span>
        <span class="c1"># and the stack when it was added to the set of guards. In order to compare</span>
        <span class="c1"># it, we throw away the stack information.</span>
        <span class="k">def</span> <span class="nf">map_value</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;unbacked_symfloat_counter&quot;</span><span class="p">,</span> <span class="s2">&quot;unbacked_symint_counter&quot;</span><span class="p">):</span>
                <span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>

                <span class="c1"># For itertools.count(), we compare the next integer returned</span>
                <span class="c1"># by the count iterators. Not that we need to copy the iterator</span>
                <span class="c1"># first. Otherwise we are mutating the object.</span>
                <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">copy</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;guards&quot;</span><span class="p">:</span>
                <span class="c1"># Transform the list of ShapeGuard into a list of expressions.</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">expr</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">value</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;var_to_guards&quot;</span><span class="p">:</span>
                <span class="c1"># Transform the tuple of optional ShapeGuards of each entry into</span>
                <span class="c1"># a tuple of optional expressions.</span>
                <span class="k">return</span> <span class="p">{</span>
                    <span class="n">s</span><span class="p">:</span> <span class="p">(</span>
                        <span class="n">lb</span><span class="o">.</span><span class="n">expr</span> <span class="k">if</span> <span class="n">lb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">ub</span><span class="o">.</span><span class="n">expr</span> <span class="k">if</span> <span class="n">ub</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">)</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">}</span>
            <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;deferred_runtime_asserts&quot;</span><span class="p">:</span>
                <span class="c1"># Transform the list of RuntimeAsserts into a list of expressions.</span>
                <span class="k">return</span> <span class="p">{</span><span class="n">s</span><span class="p">:</span> <span class="p">[</span><span class="n">ra</span><span class="o">.</span><span class="n">expr</span> <span class="k">for</span> <span class="n">ra</span> <span class="ow">in</span> <span class="n">ras</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">ras</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;name_to_node&quot;</span><span class="p">:</span>
                <span class="c1"># Compare just the set of keys is the same.</span>
                <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="n">shape_env_check_state_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">non_state_variable_names</span><span class="p">,</span> <span class="n">map_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">snapshot_tracked_fakes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracked_fakes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="kn">from</span> <span class="nn">torch._dynamo.variables.builder</span> <span class="kn">import</span> <span class="n">TrackedFake</span>

        <span class="k">def</span> <span class="nf">maybe_transform_fake</span><span class="p">(</span><span class="n">fake</span><span class="p">:</span> <span class="n">TrackedFake</span><span class="p">):</span>
            <span class="n">inner_fake</span> <span class="o">=</span> <span class="n">fake</span><span class="o">.</span><span class="n">fake</span> \
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fake</span><span class="o">.</span><span class="n">fake</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">)</span> \
                <span class="k">else</span> <span class="n">FakeTensorMeta</span><span class="o">.</span><span class="n">from_fake</span><span class="p">(</span><span class="n">fake</span><span class="o">.</span><span class="n">fake</span><span class="p">)</span>
            <span class="c1"># Even though TrackedFake accepts either a Union[SymInt, FakeTensor], here we give it a</span>
            <span class="c1"># FakeTensorMeta for two reasons:</span>
            <span class="c1">#   1. this is all the information we need when recording ShapeEnvEvents.</span>
            <span class="c1">#   2. it works even if each TrackedFake changes its metadata.</span>
            <span class="k">return</span> <span class="n">TrackedFake</span><span class="p">(</span><span class="n">inner_fake</span><span class="p">,</span> <span class="n">fake</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">fake</span><span class="o">.</span><span class="n">symbolic_context</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">maybe_transform_fake</span><span class="p">(</span><span class="n">fake</span><span class="p">)</span> <span class="k">for</span> <span class="n">fake</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracked_fakes</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">inc_tracked_fakes_length</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracked_fakes_length</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">set_tracked_fakes_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracked_fakes_length</span> <span class="o">=</span> <span class="n">i</span>

    <span class="k">def</span> <span class="nf">last_event_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="nd">@contextmanager</span>
    <span class="k">def</span> <span class="nf">recording</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_recording</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">yield</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_recording</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@record_shapeenv_event</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">freeze</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frozen</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_create_symbol_for_source</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="n">Source</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_translation_validation_enabled</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">srcname</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">source</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_to_symbol</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">source_to_symbol</span><span class="p">[</span><span class="n">srcname</span><span class="p">]</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="n">srcname</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_to_symbol</span><span class="p">[</span><span class="n">srcname</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_add_z3var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symbol</span><span class="p">:</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="n">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_translation_validation_enabled</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">validator</span><span class="o">.</span><span class="n">add_var</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_target_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_translation_validation_enabled</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">validator</span><span class="o">.</span><span class="n">add_target_expr</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_assertion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_translation_validation_enabled</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">validator</span><span class="o">.</span><span class="n">add_assertion</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_translation_validate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_translation_validation_enabled</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">validator</span><span class="o">.</span><span class="n">validate</span><span class="p">()</span>

    <span class="nd">@record_shapeenv_event</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">create_fx_call_function</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">op</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
            <span class="n">args</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">fx</span><span class="o">.</span><span class="n">Node</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]:</span>
        <span class="c1"># Cache this tuple in order to avoid duplicated nodes.</span>
        <span class="n">node_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="c1"># Flags whether the returned node was cached or not.</span>
        <span class="n">fresh</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_translation_validation_enabled</span> <span class="ow">and</span> <span class="n">node_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fx_node_cache</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">torch.fx.experimental.validator</span> <span class="kn">import</span> <span class="n">z3op</span>

            <span class="c1"># Presence of None in the arguments implies that we should ignore this operation.</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">):</span>
                <span class="c1"># We check if we are not mixing SymNode that should not be ignored</span>
                <span class="c1"># (fx_node is not None) with those that should (fx_node is None).</span>
                <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">fx</span><span class="o">.</span><span class="n">Node</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">fresh</span>

            <span class="n">fresh</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">lifted_op</span> <span class="o">=</span> <span class="n">z3op</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">validator</span><span class="p">)</span>

            <span class="c1"># If translation validation is enabled, all arguments must have its</span>
            <span class="c1"># own FX node.</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;missing arg in FX graph (</span><span class="si">{</span><span class="n">op</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">args</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fx_node_cache</span><span class="p">[</span><span class="n">node_key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">call_function</span><span class="p">(</span><span class="n">lifted_op</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name_to_node</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fx_node_cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node_key</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">fresh</span>

    <span class="k">def</span> <span class="nf">create_fx_placeholder_and_z3var</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">symbol</span><span class="p">:</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">,</span>
            <span class="nb">type</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">fx</span><span class="o">.</span><span class="n">Node</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_translation_validation_enabled</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">node_key</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">placeholder</span><span class="p">,</span> <span class="p">(</span><span class="n">symbol</span><span class="p">,))</span>

        <span class="c1"># Check if we haven&#39;t added this symbol already.</span>
        <span class="c1"># If so, skip the placeholder creation, as it</span>
        <span class="c1"># generates invalid Python code.</span>
        <span class="k">if</span> <span class="n">node_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fx_node_cache</span><span class="p">:</span>
            <span class="c1"># Add a Z3 variable according to &#39;type&#39;.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_z3var</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
            <span class="c1"># Create the FX placeholder out of a mangled name.</span>
            <span class="n">mangled_name</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[^a-zA-Z0-9]&#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[()]&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">symbol</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fx_node_cache</span><span class="p">[</span><span class="n">node_key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">placeholder</span><span class="p">(</span><span class="n">mangled_name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name_to_node</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
            <span class="c1"># Attach the &#39;symbol&#39; to the placeholder so that we can retrieve</span>
            <span class="c1"># the Z3 variable later.</span>
            <span class="n">node</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s2">&quot;symbol&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">symbol</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fx_node_cache</span><span class="p">[</span><span class="n">node_key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">remove_fx_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">fx</span><span class="o">.</span><span class="n">Node</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_translation_validation_enabled</span> <span class="ow">and</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name_to_node</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">erase_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_fx_node_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">fx</span><span class="o">.</span><span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">torch._dynamo.utils</span> <span class="kn">import</span> <span class="n">get_current_node</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">should_record_events</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="n">SHAPEENV_EVENT_KEY</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_event_index</span><span class="p">()</span>
            <span class="n">node</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="n">CURRENT_NODE_KEY</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_current_node</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_suppress_guards_tls</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">TLS</span><span class="p">,</span> <span class="s2">&quot;suppress_guards&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="nd">@record_shapeenv_event</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">suppress_guards_enter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">TLS</span><span class="o">.</span><span class="n">suppress_guards</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="nd">@record_shapeenv_event</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">suppress_guards_exit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">TLS</span><span class="o">.</span><span class="n">suppress_guards</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@contextmanager</span>
    <span class="k">def</span> <span class="nf">suppress_guards</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">suppress_guards_enter</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">yield</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">suppress_guards_exit</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_get_key</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Defines the current &quot;state&quot; of the guards we&#39;ve accumulated in this ShapeEnv.</span>
<span class="sd">        Determines when we need to invalidate our cache</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replacements</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">divisible</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_deferred_runtime_asserts</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_version_counter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># The shape environment is queried orders of magnitude more often than</span>
        <span class="c1"># it is changed, so we summarise the cache key into a linearly</span>
        <span class="c1"># increasing version counter which is cheaper to check in _lru_cache</span>

        <span class="c1"># Only update version counter if the state actually changed</span>
        <span class="n">cur_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_key</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prev_cache_key</span> <span class="o">!=</span> <span class="n">cur_key</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_prev_cache_key</span> <span class="o">=</span> <span class="n">cur_key</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_version_counter</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_produce_dyn_sizes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                           <span class="n">ex_size</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                           <span class="n">source</span><span class="p">:</span> <span class="n">Source</span><span class="p">,</span>
                           <span class="n">symbolic_context</span><span class="p">:</span> <span class="n">SymbolicContext</span>
                           <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">Expr</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_produce_dyn_sizes_from_int_tuple</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ex_size</span><span class="p">),</span> <span class="n">source</span><span class="p">,</span> <span class="n">symbolic_context</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_produce_dyn_sizes_from_int_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                          <span class="n">tensor_size</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                                          <span class="n">source</span><span class="p">:</span> <span class="n">Source</span><span class="p">,</span>
                                          <span class="n">symbolic_context</span><span class="p">:</span> <span class="n">SymbolicContext</span><span class="p">,</span>
                                          <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">Expr</span><span class="p">]:</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="n">is_symbolic</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">tensor_size</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Expect size to be a plain tuple of ints but got </span><span class="si">{</span><span class="n">tensor_size</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="kn">from</span> <span class="nn">torch._dynamo.source</span> <span class="kn">import</span> <span class="n">TensorPropertySource</span><span class="p">,</span> <span class="n">TensorProperty</span>
        <span class="n">_assert_symbol_context</span><span class="p">(</span><span class="n">symbolic_context</span><span class="p">)</span>
        <span class="n">dynamic_dims</span> <span class="o">=</span> <span class="n">symbolic_context</span><span class="o">.</span><span class="n">dynamic_sizes</span>
        <span class="n">constraint_dims</span> <span class="o">=</span> <span class="n">symbolic_context</span><span class="o">.</span><span class="n">constraint_sizes</span>
        <span class="n">size</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tensor_size</span><span class="p">):</span>
            <span class="n">size</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">create_symbol</span><span class="p">(</span>
                <span class="n">val</span><span class="p">,</span>
                <span class="n">TensorPropertySource</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">TensorProperty</span><span class="o">.</span><span class="n">SIZE</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span>
                <span class="n">dynamic_dims</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">constraint_dims</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">symbolic_context</span><span class="o">=</span><span class="n">symbolic_context</span>
            <span class="p">))</span>
        <span class="k">return</span> <span class="n">size</span>

    <span class="k">def</span> <span class="nf">create_symbolic_sizes_strides_storage_offset</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ex</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">source</span><span class="p">:</span> <span class="n">Source</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">symbolic_context</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SymbolicContext</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of symbolic sizes and strides for the given tensor.</span>
<span class="sd">        We try our best to express stride in terms of the sizes, so as to not</span>
<span class="sd">        introduce new symbolic variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Dynamo may want to wrap FakeTensors with SymInt sizes up e.g. make_fx(opt_f(), tracing_mode=&quot;symbolic&quot;).</span>
        <span class="c1"># We create symbols in shape_env using the backed hints behind SymInt.</span>

        <span class="c1"># Case 1: when SymInt is backed, dynamo can proceed with FakeTensors that have concrete shape.</span>
        <span class="c1"># produce_guards will trigger specializations on the outer stuff</span>

        <span class="c1"># Case 2: when the SymInt is unbacked, we will throw an data dependent error in require_hint().</span>
        <span class="c1">#</span>
        <span class="c1"># It&#39;s probably good for now but it&#39;s important to note that this approach has implications for</span>
        <span class="c1"># the original shape_env when checking guards in different order.</span>

        <span class="c1"># Example:</span>
        <span class="c1"># ---------</span>
        <span class="c1"># Consider a function &quot;opt_f&quot; as shown below:</span>

        <span class="c1"># @torch.compile()</span>
        <span class="c1"># def opt_f(x: bool, y: Tensor):</span>
        <span class="c1">#   if x == True:</span>
        <span class="c1">#     return y + torch.randn([4])</span>
        <span class="c1">#   else:</span>
        <span class="c1">#     return y</span>
        <span class="c1"># Depending on the sequence of calls, we might install two different sets of guards:</span>

        <span class="c1"># 1. opt_f(False, y):</span>
        <span class="c1">#    - &quot;x == False&quot; (always works for any size y)</span>

        <span class="c1"># 2. opt_f(True, y):</span>
        <span class="c1">#    - Triggers recompilation and results in guards like:</span>
        <span class="c1">#      - &quot;x == True and y.size(0) == 4&quot;</span>
        <span class="c1">#      - (or &quot;y.size(0) == 4 and x == True&quot;)</span>

        <span class="c1"># The order of checking the guards matters. In this specific example:</span>
        <span class="c1"># If True branch guard check precedes False branch and for True branch, y.size(0) check precedes x == True,</span>
        <span class="c1"># we may have an unnessary shape speciliazation for y.</span>
        <span class="k">def</span> <span class="nf">maybe_specialize_sym_int_with_hint</span><span class="p">(</span><span class="n">maybe_sym</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">maybe_sym</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">is_symbolic</span><span class="p">(</span><span class="n">maybe_sym</span><span class="p">):</span>
                <span class="k">assert</span> <span class="n">maybe_sym</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">shape_env</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">,</span> \
                    <span class="s2">&quot;expect the symbol is created from an shape env other than current one.&quot;</span>
                <span class="k">return</span> <span class="n">maybe_sym</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">require_hint</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">maybe_sym</span>

        <span class="n">ex_size</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">maybe_specialize_sym_int_with_hint</span><span class="p">(</span><span class="n">sz</span><span class="p">)</span> <span class="k">for</span> <span class="n">sz</span> <span class="ow">in</span> <span class="n">ex</span><span class="o">.</span><span class="n">size</span><span class="p">())</span>
        <span class="n">ex_stride</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">maybe_specialize_sym_int_with_hint</span><span class="p">(</span><span class="n">sd</span><span class="p">)</span> <span class="k">for</span> <span class="n">sd</span> <span class="ow">in</span> <span class="n">ex</span><span class="o">.</span><span class="n">stride</span><span class="p">())</span>
        <span class="n">ex_storage_offset</span> <span class="o">=</span> <span class="n">maybe_specialize_sym_int_with_hint</span><span class="p">(</span><span class="n">ex</span><span class="o">.</span><span class="n">storage_offset</span><span class="p">())</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_symbolic_sizes_strides_storage_offset</span><span class="p">(</span>
            <span class="n">ex_size</span><span class="p">,</span>
            <span class="n">ex_stride</span><span class="p">,</span>
            <span class="n">ex_storage_offset</span><span class="p">,</span>
            <span class="p">[</span><span class="n">_is_dim_dynamic</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ex</span><span class="o">.</span><span class="n">dim</span><span class="p">())],</span>
            <span class="n">source</span><span class="p">,</span>
            <span class="n">symbolic_context</span><span class="o">=</span><span class="n">symbolic_context</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@record_shapeenv_event</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">_create_symbolic_sizes_strides_storage_offset</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ex_size</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">ex_stride</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">ex_storage_offset</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">is_dim_dynamic</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span>
        <span class="n">source</span><span class="p">:</span> <span class="n">Source</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">symbolic_context</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SymbolicContext</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ex_size</span><span class="p">)</span>

        <span class="c1"># Reimplement the legacy behavior</span>
        <span class="k">if</span> <span class="n">symbolic_context</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">constraint_dims</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">dim</span>
            <span class="n">dynamic_dims</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
                <span class="c1"># NB: This is encapsulation breaking!  Legacy behavior was</span>
                <span class="c1"># bad.</span>
                <span class="k">if</span> <span class="n">is_dim_dynamic</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">DimDynamic</span><span class="o">.</span><span class="n">DYNAMIC</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">assume_static_by_default</span><span class="p">:</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">DimDynamic</span><span class="o">.</span><span class="n">STATIC</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">DimDynamic</span><span class="o">.</span><span class="n">DUCK</span>
                <span class="n">dynamic_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="n">dynamic_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">DimDynamic</span><span class="o">.</span><span class="n">DUCK</span><span class="p">]</span> <span class="o">*</span> <span class="n">dim</span>
            <span class="c1"># symbolic_context is None - set one</span>
            <span class="n">symbolic_context</span> <span class="o">=</span> <span class="n">StatelessSymbolicContext</span><span class="p">(</span><span class="n">dynamic_sizes</span><span class="o">=</span><span class="n">dynamic_dims</span><span class="p">,</span> <span class="n">constraint_sizes</span><span class="o">=</span><span class="n">constraint_dims</span><span class="p">)</span>
        <span class="c1"># We got a StatelessSymbolicContext</span>
        <span class="n">_assert_symbol_context</span><span class="p">(</span><span class="n">symbolic_context</span><span class="p">)</span>
        <span class="n">constraint_dims</span> <span class="o">=</span> <span class="n">symbolic_context</span><span class="o">.</span><span class="n">constraint_sizes</span>
        <span class="n">dynamic_dims</span> <span class="o">=</span> <span class="n">symbolic_context</span><span class="o">.</span><span class="n">dynamic_sizes</span>

        <span class="c1"># TODO: make this configurable from outside symbolic_context; we made a symbolic_context</span>
        <span class="c1"># decision here where if all sizes are static, we are going to</span>
        <span class="c1"># specialize all of the inner strides/offset too. We don&#39;t have to</span>
        <span class="c1"># do this, and arguably we should ALWAYS allow for dynamic offset,</span>
        <span class="c1"># this is cheap.</span>
        <span class="c1"># TODO: This should be DYNAMIC, using DUCK for BC</span>
        <span class="n">dynamic_strides_offset</span> <span class="o">=</span> <span class="n">DimDynamic</span><span class="o">.</span><span class="n">STATIC</span> <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">DimDynamic</span><span class="o">.</span><span class="n">STATIC</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">dynamic_dims</span><span class="p">)</span> <span class="k">else</span> <span class="n">DimDynamic</span><span class="o">.</span><span class="n">DUCK</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">dynamic_dims</span><span class="p">)</span> <span class="o">==</span> <span class="n">dim</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">dynamic_dims</span><span class="p">)</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">constraint_dims</span><span class="p">)</span> <span class="o">==</span> <span class="n">dim</span>

        <span class="kn">from</span> <span class="nn">torch._dynamo.source</span> <span class="kn">import</span> <span class="n">TensorPropertySource</span><span class="p">,</span> <span class="n">TensorProperty</span>
        <span class="n">size</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">Expr</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_produce_dyn_sizes_from_int_tuple</span><span class="p">(</span><span class="n">ex_size</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">symbolic_context</span><span class="p">)</span>
        <span class="n">stride</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">Expr</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ex_stride</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">val</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">stride</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Integer</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">while</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">stride</span><span class="p">):</span>
            <span class="n">candidates</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">ex_size</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">ex_stride</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">size</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">stride</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">stride</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ex_stride</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span>
            <span class="p">}</span>
            <span class="c1"># iterate over unbound strides in sorted order</span>
            <span class="n">val_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="p">[(</span><span class="n">ex_stride</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stride</span><span class="p">))</span> <span class="k">if</span> <span class="n">stride</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">],</span>
                <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tup</span><span class="p">:</span> <span class="p">(</span>
                    <span class="c1"># Order singletons by their coefficients.</span>
                    <span class="c1"># 1 here to order singletons after non-singletons.</span>
                    <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">singleton_coeff</span><span class="p">(),</span> <span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="n">is_singleton</span><span class="p">(</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">else</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">tup</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">val_list</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">stride</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ex_stride</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
                    <span class="n">stride</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">candidates</span><span class="p">[</span><span class="n">ex_stride</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                    <span class="n">candidates</span><span class="p">[</span><span class="n">ex_size</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">ex_stride</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">size</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">stride</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">stride</span><span class="p">):</span>
                <span class="c1"># bind the smallest unbound stride to a new variable</span>
                <span class="n">val</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="p">(</span><span class="n">ex_stride</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stride</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">stride</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span>
                    <span class="p">]</span>
                <span class="p">)</span>
                <span class="n">stride</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_symbol</span><span class="p">(</span>
                    <span class="n">val</span><span class="p">,</span>
                    <span class="n">TensorPropertySource</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">TensorProperty</span><span class="o">.</span><span class="n">STRIDE</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span>
                    <span class="n">dynamic_dim</span><span class="o">=</span><span class="n">dynamic_strides_offset</span><span class="p">,</span>
                    <span class="n">constraint_dim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">symbolic_context</span><span class="o">=</span><span class="n">symbolic_context</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">stride</span><span class="p">)</span>

        <span class="n">sym_sizes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">create_symintnode</span><span class="p">(</span>
                <span class="n">sym</span><span class="p">,</span>
                <span class="n">hint</span><span class="o">=</span><span class="n">hint</span><span class="p">,</span>
                <span class="n">source</span><span class="o">=</span><span class="n">TensorPropertySource</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">TensorProperty</span><span class="o">.</span><span class="n">SIZE</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">hint</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">ex_size</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="n">sym_stride</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">stride_expr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stride</span><span class="p">):</span>
            <span class="c1"># NB: Don&#39;t duck size the stride; instead use the expression</span>
            <span class="c1"># we computed</span>
            <span class="k">assert</span> <span class="n">stride_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">sym_stride</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">create_symintnode</span><span class="p">(</span>
                <span class="n">stride_expr</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="n">ex_stride</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">source</span><span class="o">=</span><span class="n">TensorPropertySource</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">TensorProperty</span><span class="o">.</span><span class="n">STRIDE</span><span class="p">,</span> <span class="n">i</span><span class="p">)))</span>
        <span class="n">sym_storage_offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_symintnode</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">create_symbol</span><span class="p">(</span>
                <span class="n">ex_storage_offset</span><span class="p">,</span>
                <span class="n">TensorPropertySource</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">TensorProperty</span><span class="o">.</span><span class="n">STORAGE_OFFSET</span><span class="p">),</span>
                <span class="n">dynamic_dim</span><span class="o">=</span><span class="n">dynamic_strides_offset</span><span class="p">,</span>
                <span class="n">constraint_dim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">symbolic_context</span><span class="o">=</span><span class="n">symbolic_context</span>
            <span class="p">),</span>
            <span class="n">hint</span><span class="o">=</span><span class="n">ex_storage_offset</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">TensorPropertySource</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">TensorProperty</span><span class="o">.</span><span class="n">STORAGE_OFFSET</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sym_sizes</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sym_stride</span><span class="p">),</span> <span class="n">sym_storage_offset</span>

    <span class="c1"># If you know what the current hint value of the SymInt to be created</span>
    <span class="c1"># is, pass it into hint.  Otherwise, pass None and we will make our best</span>
    <span class="c1"># guess</span>
    <span class="nd">@record_shapeenv_event</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">create_symintnode</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">sym</span><span class="p">:</span> <span class="s2">&quot;sympy.Expr&quot;</span><span class="p">,</span>
            <span class="o">*</span><span class="p">,</span>
            <span class="n">hint</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
            <span class="n">source</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Source</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">source_name</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="k">if</span> <span class="n">source</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_translation_validation_enabled</span> <span class="ow">and</span> <span class="n">source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Create a new symbol for this source.</span>
            <span class="n">symbol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_symbol_for_source</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">symbol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

            <span class="c1"># Create a new FX placeholder and Z3 variable for &#39;symbol&#39;.</span>
            <span class="n">fx_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_fx_placeholder_and_z3var</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

            <span class="c1"># Add an equality assertion for the newly created symbol and &#39;sym&#39;.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_assertion</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">Eq</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">sym</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fx_node</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Integer</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">hint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">int</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span> <span class="o">==</span> <span class="n">hint</span>
            <span class="n">out</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">SymInt</span><span class="p">(</span><span class="n">SymNode</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">hint</span><span class="p">,</span> <span class="n">fx_node</span><span class="o">=</span><span class="n">fx_node</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="nd">@record_shapeenv_event</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">create_unspecified_symint_and_symbol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">dynamic_dim</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_symintnode</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">create_unspecified_symbol</span><span class="p">(</span>
                <span class="n">value</span><span class="p">,</span>
                <span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">,</span>
                <span class="n">dynamic_dim</span><span class="o">=</span><span class="n">dynamic_dim</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">hint</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">create_symboolnode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sym</span><span class="p">:</span> <span class="s2">&quot;sympy.Expr&quot;</span><span class="p">):</span>
        <span class="c1"># This function is only being used in serialization, so we do not track it</span>
        <span class="c1"># for validation.</span>
        <span class="k">return</span> <span class="n">SymBool</span><span class="p">(</span><span class="n">SymNode</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

    <span class="nd">@record_shapeenv_event</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">create_unbacked_symfloat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">symbol</span><span class="p">:</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;f</span><span class="si">{</span><span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unbacked_symfloat_counter</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">counter</span><span class="p">[</span><span class="s2">&quot;create_unbacked_symbol&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">var_to_stack</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span> <span class="o">=</span> <span class="n">CapturedTraceback</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">skip</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">vr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_to_range</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span> <span class="o">=</span> <span class="n">ValueRanges</span><span class="o">.</span><span class="n">unknown</span><span class="p">()</span>

        <span class="c1"># Create a new FX placeholder and Z3 variable for &#39;symbol&#39;.</span>
        <span class="n">fx_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_fx_placeholder_and_z3var</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="n">fsummary</span><span class="p">,</span> <span class="n">user_tb</span><span class="p">,</span> <span class="n">maybe_user_loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_stack_summary</span><span class="p">()</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;create_unbacked_symfloat </span><span class="si">%s</span><span class="s2"> [</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">]</span><span class="si">%s</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">vr</span><span class="o">.</span><span class="n">lower</span><span class="p">,</span> <span class="n">vr</span><span class="o">.</span><span class="n">upper</span><span class="p">,</span> <span class="n">maybe_user_loc</span><span class="p">,</span> <span class="n">format_frame</span><span class="p">(</span><span class="n">fsummary</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">SymFloat</span><span class="p">(</span><span class="n">SymNode</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">fx_node</span><span class="o">=</span><span class="n">fx_node</span><span class="p">))</span>

    <span class="nd">@record_shapeenv_event</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">create_unbacked_symint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">symbol</span><span class="p">:</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;u</span><span class="si">{</span><span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unbacked_symint_counter</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">counter</span><span class="p">[</span><span class="s2">&quot;create_unbacked_symbol&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">var_to_stack</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span> <span class="o">=</span> <span class="n">CapturedTraceback</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">skip</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">vr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_to_range</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_unspecified_value_range</span><span class="p">()</span>

        <span class="c1"># Create a new FX placeholder and Z3 variable for &#39;symbol&#39;.</span>
        <span class="n">fx_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_fx_placeholder_and_z3var</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

        <span class="n">fsummary</span><span class="p">,</span> <span class="n">user_tb</span><span class="p">,</span> <span class="n">maybe_user_loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_stack_summary</span><span class="p">()</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;create_unbacked_symint </span><span class="si">%s</span><span class="s2"> [</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">]</span><span class="si">%s</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">vr</span><span class="o">.</span><span class="n">lower</span><span class="p">,</span> <span class="n">vr</span><span class="o">.</span><span class="n">upper</span><span class="p">,</span> <span class="n">maybe_user_loc</span><span class="p">,</span> <span class="n">format_frame</span><span class="p">(</span><span class="n">fsummary</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">SymInt</span><span class="p">(</span><span class="n">SymNode</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">fx_node</span><span class="o">=</span><span class="n">fx_node</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">is_unbacked_symint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symbol</span><span class="p">:</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># NB: keep synced with free_unbacked_symbols</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;u&quot;</span><span class="p">)</span>

    <span class="nd">@record_shapeenv_event</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">create_unbacked_symbool</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">symbol</span><span class="p">:</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;u</span><span class="si">{</span><span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unbacked_symint_counter</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">counter</span><span class="p">[</span><span class="s2">&quot;create_unbacked_symbol&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">var_to_stack</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span> <span class="o">=</span> <span class="n">CapturedTraceback</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">skip</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">vr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_to_range</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span> <span class="o">=</span> <span class="n">ValueRanges</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Create a new FX placeholder and Z3 variable for &#39;symbol&#39;.</span>
        <span class="n">fx_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_fx_placeholder_and_z3var</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>

        <span class="n">fsummary</span><span class="p">,</span> <span class="n">user_tb</span><span class="p">,</span> <span class="n">maybe_user_loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_stack_summary</span><span class="p">()</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;create_unbacked_symbool </span><span class="si">%s</span><span class="s2"> [</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">]</span><span class="si">%s</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">vr</span><span class="o">.</span><span class="n">lower</span><span class="p">,</span> <span class="n">vr</span><span class="o">.</span><span class="n">upper</span><span class="p">,</span> <span class="n">maybe_user_loc</span><span class="p">,</span> <span class="n">format_frame</span><span class="p">(</span><span class="n">fsummary</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">SymBool</span><span class="p">(</span><span class="n">SymNode</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">Eq</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">fx_node</span><span class="o">=</span><span class="n">fx_node</span><span class="p">))</span>

    <span class="nd">@record_shapeenv_event</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">create_unspecified_symbol</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">SymInt</span><span class="p">],</span>
        <span class="n">source</span><span class="p">:</span> <span class="n">Source</span><span class="p">,</span>
        <span class="n">dynamic_dim</span><span class="p">:</span> <span class="n">DimDynamic</span> <span class="o">=</span> <span class="n">DimDynamic</span><span class="o">.</span><span class="n">DUCK</span><span class="p">,</span>
        <span class="n">constraint_dim</span><span class="p">:</span> <span class="n">DimConstraint</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># NB: includes None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;sympy.Expr&quot;</span><span class="p">:</span>
        <span class="c1"># &#39;positive&#39; is None for unspecified symbols, since we can&#39;t</span>
        <span class="c1"># assume that it will be neither positive nor negative.</span>

        <span class="c1"># We don&#39;t want to specialize zero one val for unspecified symbol</span>
        <span class="c1"># so that we can always get a new symbol despite val.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_symbol</span><span class="p">(</span>
            <span class="n">val</span><span class="p">,</span>
            <span class="n">source</span><span class="p">,</span>
            <span class="n">dynamic_dim</span><span class="p">,</span>
            <span class="n">constraint_dim</span><span class="p">,</span>
            <span class="n">positive</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">do_not_specialize_zero_one</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">symbolic_context</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="nd">@record_shapeenv_event</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">create_symbol</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">source</span><span class="p">:</span> <span class="n">Source</span><span class="p">,</span>
        <span class="n">dynamic_dim</span><span class="p">:</span> <span class="n">DimDynamic</span> <span class="o">=</span> <span class="n">DimDynamic</span><span class="o">.</span><span class="n">DUCK</span><span class="p">,</span>
        <span class="n">constraint_dim</span><span class="p">:</span> <span class="n">DimConstraint</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># NB: includes None</span>
        <span class="n">positive</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">do_not_specialize_zero_one</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">symbolic_context</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;sympy.Expr&quot;</span><span class="p">:</span>
        <span class="c1"># see note [Tensor Fakification and Symbol Caching]</span>
        <span class="n">source_name</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">symbolic_context</span><span class="p">,</span> <span class="n">StatefulSymbolicContext</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">symbolic_context</span><span class="o">.</span><span class="n">shape_env_to_source_to_symbol_cache</span><span class="p">):</span>
            <span class="n">symbolic_context</span><span class="o">.</span><span class="n">shape_env_to_source_to_symbol_cache</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">symbolic_context</span><span class="p">,</span> <span class="n">StatefulSymbolicContext</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">source_name</span>
                <span class="ow">and</span> <span class="p">(</span><span class="n">source_name</span> <span class="ow">in</span> <span class="n">symbolic_context</span><span class="o">.</span><span class="n">shape_env_to_source_to_symbol_cache</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)])):</span>
            <span class="k">return</span> <span class="n">symbolic_context</span><span class="o">.</span><span class="n">shape_env_to_source_to_symbol_cache</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)][</span><span class="n">source_name</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">do_not_specialize_zero_one</span><span class="p">:</span>
            <span class="n">specialize_zero_one</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">specialize_zero_one</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">specialize_zero_one</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">Source</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">source</span><span class="p">)</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">source</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="n">positive</span> <span class="ow">and</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;positive set for negative value: </span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="c1"># It&#39;s always sound to allocate a symbol as DYNAMIC.  If the user</span>
        <span class="c1"># constrained the symbol, force the symbolic_context to DYNAMIC, because our</span>
        <span class="c1"># constraint code will do weird stuff if, e.g., it&#39;s duck shaped</span>
        <span class="k">if</span> <span class="n">constraint_dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dynamic_dim</span> <span class="o">=</span> <span class="n">DimDynamic</span><span class="o">.</span><span class="n">DYNAMIC</span>

        <span class="k">if</span> <span class="n">dynamic_dim</span> <span class="ow">is</span> <span class="n">DimDynamic</span><span class="o">.</span><span class="n">STATIC</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Integer</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">symbolic_context</span><span class="p">,</span> <span class="n">StatefulSymbolicContext</span><span class="p">)</span> <span class="ow">and</span> <span class="n">source_name</span><span class="p">:</span>
                <span class="n">symbolic_context</span><span class="o">.</span><span class="n">shape_env_to_source_to_symbol_cache</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)][</span><span class="n">source_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="k">elif</span> <span class="n">dynamic_dim</span> <span class="ow">is</span> <span class="n">DimDynamic</span><span class="o">.</span><span class="n">DUCK</span><span class="p">:</span>
            <span class="c1"># duck_shape can be used to globally turn off duck shaping, even</span>
            <span class="c1"># if it was requested</span>
            <span class="n">duck</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">duck_shape</span>
        <span class="k">elif</span> <span class="n">dynamic_dim</span> <span class="ow">is</span> <span class="n">DimDynamic</span><span class="o">.</span><span class="n">DYNAMIC</span><span class="p">:</span>
            <span class="n">duck</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unhandled dynamic_dim </span><span class="si">{</span><span class="n">dynamic_dim</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">val</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">specialize_zero_one</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_to_var</span><span class="p">[</span><span class="n">val</span><span class="p">]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">duck</span> <span class="ow">or</span> <span class="n">val</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_to_var</span><span class="p">:</span>
            <span class="c1"># If we&#39;re not duck shaping, we always create a new symbol</span>
            <span class="c1"># Even if we&#39;re duck shaping, if we haven&#39;t seen this particular</span>
            <span class="c1"># value before, we also create a new symbol</span>
            <span class="n">sympy_expr</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;s</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_to_val</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="n">positive</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># We always associate vars to vals</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">var_to_val</span><span class="p">[</span><span class="n">sympy_expr</span><span class="p">]</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Integer</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Only used for jagged layout nested tensors</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">var_to_val</span><span class="p">[</span><span class="n">sympy_expr</span><span class="p">]</span> <span class="o">=</span> <span class="n">SingletonInt</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">singleton_int</span><span class="p">(),</span> <span class="n">coeff</span><span class="o">=</span><span class="n">val</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">singleton_coeff</span><span class="p">())</span>

            <span class="c1"># Do the appending later, because we always want to populate this</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">var_to_sources</span><span class="p">[</span><span class="n">sympy_expr</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Create a Z3 variable for the new symbol.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_z3var</span><span class="p">(</span><span class="n">sympy_expr</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">duck</span><span class="p">:</span>
                <span class="c1"># Make sure to reuse this symbol for subsequent duck shaping</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">val_to_var</span><span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="n">sympy_expr</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">positive</span><span class="p">:</span>
                    <span class="c1"># Add assertions for the newly created symbols</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_add_assertion</span><span class="p">(</span><span class="n">sympy_expr</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>

                    <span class="c1"># Apply default range, which assumes not zero-one</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">var_to_range</span><span class="p">[</span><span class="n">sympy_expr</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_value_range</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">var_to_range</span><span class="p">[</span><span class="n">sympy_expr</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_unspecified_value_range</span><span class="p">()</span>

                <span class="c1"># Small performance optimization: if we have a min-max constraint,</span>
                <span class="c1"># we can proactively narrow to that range</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">constraint_dim</span><span class="p">,</span> <span class="n">StrictMinMaxConstraint</span><span class="p">):</span>
                    <span class="k">assert</span> <span class="ow">not</span> <span class="n">duck</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">var_to_range</span><span class="p">[</span><span class="n">sympy_expr</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">constraint_dim</span><span class="o">.</span><span class="n">vr</span>

                <span class="n">vr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_to_range</span><span class="p">[</span><span class="n">sympy_expr</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">val</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">vr</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ConstraintViolationError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2"> not in range [</span><span class="si">{</span><span class="n">vr</span><span class="o">.</span><span class="n">lower</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">vr</span><span class="o">.</span><span class="n">upper</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>

                <span class="n">range_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">vr</span><span class="o">.</span><span class="n">lower</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">vr</span><span class="o">.</span><span class="n">upper</span><span class="si">}</span><span class="s2">]&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Skip var_range logic for SingletonInt</span>
                <span class="c1"># Only used for jagged layout nested tensors</span>
                <span class="n">range_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

            <span class="n">r</span> <span class="o">=</span> <span class="n">sympy_expr</span>

            <span class="n">fsummary</span><span class="p">,</span> <span class="n">user_tb</span><span class="p">,</span> <span class="n">maybe_user_loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_stack_summary</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;create_symbol </span><span class="si">%s</span><span class="s2"> = </span><span class="si">%s</span><span class="s2"> for </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s%s</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span>
                <span class="n">sympy_expr</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">source</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span> <span class="n">range_str</span><span class="p">,</span>
                <span class="n">maybe_user_loc</span><span class="p">,</span> <span class="n">format_frame</span><span class="p">(</span><span class="n">fsummary</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">counter</span><span class="p">[</span><span class="s2">&quot;create_symbol&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This implements duck-shaping: input sizes that match are assigned</span>
            <span class="c1"># the same symint</span>
            <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_to_var</span><span class="p">[</span><span class="n">val</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;create_symbol </span><span class="si">%s</span><span class="s2"> duck sized </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">source</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">var_to_sources</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">symbolic_context</span><span class="p">,</span> <span class="n">StatefulSymbolicContext</span><span class="p">)</span> <span class="ow">and</span> <span class="n">source_name</span><span class="p">:</span>
            <span class="n">symbolic_context</span><span class="o">.</span><span class="n">shape_env_to_source_to_symbol_cache</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)][</span><span class="n">source_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
        <span class="k">return</span> <span class="n">r</span>

    <span class="k">def</span> <span class="nf">debug_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="n">src_name</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_name_to_debug_name</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">src_name</span><span class="p">,</span> <span class="n">src_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">render_range_for_constraint_violation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">StrictMinMaxConstraint</span><span class="p">):</span>
            <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">vr</span><span class="o">.</span><span class="n">lower</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">vr</span><span class="o">.</span><span class="n">upper</span>
            <span class="n">default</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_value_range</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">lower</span> <span class="o">&lt;=</span> <span class="n">default</span><span class="o">.</span><span class="n">lower</span><span class="p">:</span>
                <span class="n">lower</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">upper</span> <span class="o">&gt;=</span> <span class="n">default</span><span class="o">.</span><span class="n">upper</span><span class="p">:</span>
                <span class="n">upper</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">c_render</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">debug_name</span><span class="p">(</span><span class="n">source</span><span class="p">)</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">source</span><span class="o">.</span><span class="n">name</span><span class="p">()</span><span class="si">}</span><span class="s2"> in the specified range&quot;</span>
            <span class="k">if</span> <span class="n">lower</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">upper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">c_render</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">lower</span><span class="si">}</span><span class="s2"> &lt;= </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">debug_name</span><span class="p">(</span><span class="n">source</span><span class="p">)</span><span class="si">}</span><span class="s2"> &lt;= </span><span class="si">{</span><span class="n">upper</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">elif</span> <span class="n">lower</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">upper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">c_render</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">debug_name</span><span class="p">(</span><span class="n">source</span><span class="p">)</span><span class="si">}</span><span class="s2"> &lt;= </span><span class="si">{</span><span class="n">upper</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">elif</span> <span class="n">lower</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">upper</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">c_render</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">lower</span><span class="si">}</span><span class="s2"> &lt;= </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">debug_name</span><span class="p">(</span><span class="n">source</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">return</span> <span class="n">c_render</span>
        <span class="k">return</span> <span class="n">c</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>

    <span class="c1"># Generates a list of guards strings which, when evaluated in a context that</span>
    <span class="c1"># defines tensors for all the sources, returns True or False depending</span>
    <span class="c1"># on if the guards in the list evaluated to True or not.  Primarily used by Dynamo,</span>
    <span class="c1"># but this is also helpful for manual testing of guards (see</span>
    <span class="c1"># evaluate_guards_for_args)</span>
    <span class="c1">#</span>
    <span class="c1"># For convenience in testing, a source is allowed to be a str,</span>
    <span class="c1"># in which case we will assume it is a LocalSource</span>
    <span class="c1">#</span>
    <span class="c1"># simplified lets you omit duck sizing, equality and 0/1 guards.</span>
    <span class="c1"># This is useful for testing when you don&#39;t care about the boilerplate</span>
    <span class="c1"># guards, and it may be helpful for user output too (be careful though;</span>
    <span class="c1"># some equality guards are nontrivial!  It would be nice to get simplified</span>
    <span class="c1"># output to print them too).  It&#39;s private because it&#39;s not</span>
    <span class="c1"># intended for normal use</span>
    <span class="k">def</span> <span class="nf">produce_guards</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">placeholders</span><span class="p">,</span>
        <span class="n">sources</span><span class="p">,</span>
        <span class="n">source_ref</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">input_contexts</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DimList</span><span class="p">[</span><span class="n">SymbolicContext</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">equalities_inputs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Source</span><span class="p">,</span> <span class="n">Source</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_simplified</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="c1"># Indicates if we should produce guards for known static values.</span>
        <span class="n">ignore_static</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;produce_guards&quot;</span><span class="p">)</span>

        <span class="c1"># Check if we get to the same ShapeEnv state by replaying the recorded events.</span>
        <span class="c1"># This will create a new ShapeEnv instance, and call all recorded function</span>
        <span class="c1"># calls on this new instance. Finally, it will check whether this new instance</span>
        <span class="c1"># has equal state.</span>
        <span class="c1">#</span>
        <span class="c1"># It&#39;s important that we do it in the begining of this function, since it modifies</span>
        <span class="c1"># self.dim_constraints through its execution. Changes that happen in this method</span>
        <span class="c1"># aren&#39;t interesting, since this is the function call we wish to reproduce at the</span>
        <span class="c1"># end. If we wish to simply reproduce ShapeEnv instances even after this call,</span>
        <span class="c1"># this method should also be recorded.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_recorded_events</span><span class="p">:</span>
            <span class="n">shape_env</span> <span class="o">=</span> <span class="n">replay_shape_env_events</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_equal</span><span class="p">(</span><span class="n">shape_env</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">placeholders</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span>
        <span class="n">Tensorlike</span> <span class="o">=</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">FakeTensorMeta</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_create_no_constraints_context</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">StatelessSymbolicContext</span><span class="p">(</span>
                <span class="c1"># Ignored; only the constraints part is relevant below.</span>
                <span class="n">dynamic_sizes</span><span class="o">=</span><span class="p">[</span><span class="n">DimDynamic</span><span class="o">.</span><span class="n">DYNAMIC</span><span class="p">]</span> <span class="o">*</span> <span class="n">t</span><span class="o">.</span><span class="n">dim</span><span class="p">(),</span>
                <span class="n">constraint_sizes</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">t</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span>
            <span class="p">)</span>

        <span class="c1"># Expand optional inputs, or verify invariants are upheld</span>
        <span class="k">if</span> <span class="n">input_contexts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">input_contexts</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">_create_no_constraints_context</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">Tensorlike</span><span class="p">)</span>
                <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">placeholders</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_contexts</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">placeholders</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">placeholders</span><span class="p">,</span> <span class="n">input_contexts</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">Tensorlike</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">context</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">input_contexts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_create_no_constraints_context</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="n">SymInt</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span>
                    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>

        <span class="c1"># It took a lot of sweat to figure out the algorithm here.  Let&#39;s</span>
        <span class="c1"># explain how it works.</span>
        <span class="c1">#</span>
        <span class="c1"># The ShapeEnv lifecycle looks something like this:</span>
        <span class="c1">#</span>
        <span class="c1"># - For each input, you either generate a fresh Sympy symbol (s0) to</span>
        <span class="c1">#   represent its value (a binding site), or you reuse some</span>
        <span class="c1">#   preexisting symbol or expression, skipping the symbol allocation</span>
        <span class="c1">#   (e.g., duck sizing to a preexisting symbol, or expressing a</span>
        <span class="c1">#   stride as a multiplication of a separate stride and size.)</span>
        <span class="c1">#   Naively, you might expect to bind a fresh Sympy symbol for</span>
        <span class="c1">#   every input, but this is fairly wasteful as most of these</span>
        <span class="c1">#   symbols immediately simplify away, and if you don&#39;t eagerly</span>
        <span class="c1">#   specialize, e.g., 0/1 symbols, you end up with very complicated</span>
        <span class="c1">#   expressions that are not optimizable in practice.</span>
        <span class="c1">#</span>
        <span class="c1"># - You perform some compute on these symbols, occasionally</span>
        <span class="c1">#   introducing guards on boolean expressions on these symbols.</span>
        <span class="c1">#   In particular, whenever we guard on equality (_maybe_guard_eq),</span>
        <span class="c1">#   we can simplify shapes; e.g., when s0 == s1 * 2, we can now</span>
        <span class="c1">#   replace all occurrences of s0 with s1 * 2.  Sometimes, a</span>
        <span class="c1">#   boolean expression evaluation doesn&#39;t introduce a guard, as</span>
        <span class="c1">#   the guard is already entailed by the simplifications we have</span>
        <span class="c1">#   applied.</span>
        <span class="c1">#</span>
        <span class="c1"># - In the end, you have a bunch of replacements (saying how to</span>
        <span class="c1">#   simplify shapes) and a bunch of guards (all the equality guards</span>
        <span class="c1">#   are trivial, because they&#39;re covered by the replacements).</span>
        <span class="c1">#</span>
        <span class="c1"># From the ShapeEnv, we must generate a Python expression that, when</span>
        <span class="c1"># evaluated on a set of inputs, tells us whether or not these boolean</span>
        <span class="c1"># expressions would have evaluated in the same way.  However,</span>
        <span class="c1"># we cannot easily compute this, as we elide recording boolean</span>
        <span class="c1"># expressions when we think they are vacuously true.  Thus, we seek</span>
        <span class="c1"># an approximation: we must generate an expression, if true, would have</span>
        <span class="c1"># produced an &quot;equivalent&quot; ShapeEnv, which would answer guard</span>
        <span class="c1"># expressions in the same way.</span>
        <span class="c1">#</span>
        <span class="c1"># Our notion of equivalence is a bit subtle.  For example, consider</span>
        <span class="c1"># the ShapeEnv created from an input of size (5, 4) versus (4, 4)</span>
        <span class="c1"># (no other guards.)  Duck sizing would generate (s0, s1) in the first</span>
        <span class="c1"># case but (s0, s0) in the second.  We do NOT assume that size</span>
        <span class="c1"># variables are disjoint; so in fact a graph that assumes the input</span>
        <span class="c1"># could be (s0, s1) subsumes (s0, s0) (setting s0 == s1), but not</span>
        <span class="c1"># vice versa.  However, consider an analogous case (1,) versus (2,).</span>
        <span class="c1"># Duck sizing generates (1,) and (s0,); the (s0,) graph does NOT</span>
        <span class="c1"># subsume the (1,) graph because we assume that any size variables</span>
        <span class="c1"># is NOT 0/1 (and make simplifications according to this; e.g., if</span>
        <span class="c1"># we queried s0 == 0, we would immediately return False without</span>
        <span class="c1"># returning a guard.)</span>
        <span class="c1">#</span>
        <span class="c1"># So, it is perhaps easier to flip things on their head: the guard</span>
        <span class="c1"># expressions we generate here say what simplifications are valid,</span>
        <span class="c1"># and what are not.  Below, we explain each of the guard expressions</span>
        <span class="c1"># we generate</span>

        <span class="c1"># TODO: Make this more efficient by binding all the size/stride/offsets</span>
        <span class="c1"># to locals before performing tests on them.</span>

        <span class="kn">from</span> <span class="nn">torch._dynamo.source</span> <span class="kn">import</span> <span class="n">TensorPropertySource</span><span class="p">,</span> <span class="n">TensorProperty</span><span class="p">,</span> <span class="n">NegateSource</span>

        <span class="c1"># Actual codegen must be delayed as we don&#39;t necessarily know what</span>
        <span class="c1"># the symbol mapping is</span>
        <span class="n">input_guards</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">symbol_to_source</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">symbol_to_constraints</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="n">constraint_violations</span> <span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">def</span> <span class="nf">record_constraint_violation</span><span class="p">(</span><span class="n">warn_only</span><span class="p">,</span> <span class="n">debug_name</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">constraint_violations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span><span class="n">warn_only</span><span class="p">,</span> <span class="n">debug_name</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">msg</span><span class="si">}{</span><span class="n">hint</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">hint</span> <span class="k">else</span> <span class="n">msg</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">def</span> <span class="nf">is_dim</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">TensorPropertySource</span><span class="p">)</span> <span class="ow">and</span> <span class="n">src</span><span class="o">.</span><span class="n">prop</span> <span class="ow">is</span> <span class="n">TensorProperty</span><span class="o">.</span><span class="n">SIZE</span>

        <span class="k">if</span> <span class="n">equalities_inputs</span><span class="p">:</span>
            <span class="n">source_index</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">src</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sources</span><span class="p">):</span>
                <span class="n">source_index</span><span class="p">[</span><span class="n">src</span><span class="o">.</span><span class="n">name</span><span class="p">()]</span> <span class="o">=</span> <span class="n">i</span>

            <span class="k">def</span> <span class="nf">get_symbol</span><span class="p">(</span><span class="n">tensor_dim_src</span><span class="p">):</span>
                <span class="n">fake</span> <span class="o">=</span> <span class="n">placeholders</span><span class="p">[</span><span class="n">source_index</span><span class="p">[</span><span class="n">tensor_dim_src</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">name</span><span class="p">()]]</span>
                <span class="n">symint</span> <span class="o">=</span> <span class="n">fake</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">tensor_dim_src</span><span class="o">.</span><span class="n">idx</span><span class="p">]</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">symint</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">symint</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span>

            <span class="k">for</span> <span class="n">src1</span><span class="p">,</span> <span class="n">src2</span> <span class="ow">in</span> <span class="n">equalities_inputs</span><span class="o">.</span><span class="n">source_pairs</span><span class="p">:</span>
                <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">get_symbol</span><span class="p">(</span><span class="n">src1</span><span class="p">),</span> <span class="n">get_symbol</span><span class="p">(</span><span class="n">src2</span><span class="p">)</span>
                <span class="n">concrete_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_expr</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">Eq</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">concrete_val</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ConstraintViolationError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">src1</span><span class="o">.</span><span class="n">name</span><span class="p">()</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">var_to_val</span><span class="p">[</span><span class="n">s1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="s2">&quot; is not equal to &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">src2</span><span class="o">.</span><span class="n">name</span><span class="p">()</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">var_to_val</span><span class="p">[</span><span class="n">s2</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

        <span class="c1"># How do we know what the value of s0 is?  Fresh variables can only be</span>
        <span class="c1"># bound by inputs, so there MUST be some other input which binds the</span>
        <span class="c1"># variable.  If there is no such input, this is an error in our</span>
        <span class="c1"># system.  We record where all symbols come from, to help you diagnose</span>
        <span class="c1"># why those symbols didn&#39;t occur.</span>
        <span class="c1">#</span>
        <span class="c1"># In fact, generally speaking it is only possible for the &quot;outermost&quot;</span>
        <span class="c1"># user of a ShapeEnv to evaluate the guards, because some inputs may</span>
        <span class="c1"># not be available to inner levels.  For example, Dynamo can guard on</span>
        <span class="c1"># tensors that never actually become graph arguments (they are</span>
        <span class="c1"># pruned).  In this case, only Dynamo knows about these arguments.</span>
        <span class="k">def</span> <span class="nf">track_symint</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">constraint</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;track_symint </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">LazyString</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="n">val</span><span class="p">,</span> <span class="n">constraint</span><span class="p">)</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">SymInt</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_symbolic</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">SymInt</span><span class="p">)</span> <span class="ow">and</span> <span class="n">val</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">maybe_as_int</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">maybe_as_int</span><span class="p">()</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">SymInt</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">):</span>
                    <span class="n">symbol_to_source</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">constraint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">symbol_to_constraints</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="o">-</span><span class="n">s</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">):</span>
                    <span class="n">symbol_to_source</span><span class="p">[</span><span class="o">-</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">NegateSource</span><span class="p">(</span><span class="n">source</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">constraint_violated</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">constraint</span><span class="p">,</span> <span class="n">StrictMinMaxConstraint</span><span class="p">):</span>
                        <span class="c1"># try inferring the ranges of the expr s</span>
                        <span class="n">sym_vrs</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_to_range</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">}</span>
                        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">vr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">vr</span> <span class="ow">in</span> <span class="n">sym_vrs</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                            <span class="n">expr_vr</span> <span class="o">=</span> <span class="n">bound_sympy</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sym_vrs</span><span class="p">)</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">expr_vr</span> <span class="o">!=</span> <span class="n">constraint</span><span class="o">.</span><span class="n">vr</span><span class="p">):</span>
                                <span class="c1"># the expr and constrain ranges don&#39;t match</span>
                                <span class="n">constraint_violated</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># some of the free symbols in s don&#39;t have ranges</span>
                            <span class="n">constraint_violated</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">constraint</span><span class="p">,</span> <span class="n">RelaxedUnspecConstraint</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
                            <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                            <span class="c1"># Don&#39;t complain about 0/1 specialization, we</span>
                            <span class="c1"># expect to have to compile in this case anyway</span>
                            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                                <span class="n">constraint_violated</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="n">constraint_violated</span><span class="p">:</span>
                        <span class="k">def</span> <span class="nf">hint</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                            <span class="n">sexpr</span> <span class="o">=</span> <span class="n">ShapeGuardPrinter</span><span class="p">(</span><span class="n">symbol_to_source</span><span class="p">,</span> <span class="n">source_ref</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_to_sources</span><span class="p">)</span><span class="o">.</span><span class="n">doprint</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">sexpr</span><span class="si">}</span><span class="s2">.&quot;</span>

                        <span class="n">var_with_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">render_range_for_constraint_violation</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">constraint</span><span class="p">)</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Not all values of </span><span class="si">{</span><span class="n">var_with_range</span><span class="si">}</span><span class="s2"> are valid because &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">debug_name</span><span class="p">(</span><span class="n">source</span><span class="p">)</span><span class="si">}</span><span class="s2"> was inferred to be equal to &quot;</span>
                        <span class="p">)</span>
                        <span class="n">record_constraint_violation</span><span class="p">(</span>
                            <span class="n">constraint</span><span class="o">.</span><span class="n">warn_only</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">debug_name</span><span class="p">(</span><span class="n">source</span><span class="p">),</span>
                            <span class="n">msg</span><span class="p">,</span>
                            <span class="n">hint</span><span class="o">=</span><span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">hint</span><span class="p">,</span> <span class="n">s</span><span class="p">),</span>
                        <span class="p">)</span>

                <span class="n">input_guards</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">source</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Integer</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="n">input_guards</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">source</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
                <span class="n">constraint_violated</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">constraint</span><span class="p">,</span> <span class="n">StrictMinMaxConstraint</span><span class="p">):</span>
                    <span class="n">constraint_violated</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">constraint</span><span class="p">,</span> <span class="n">RelaxedUnspecConstraint</span><span class="p">):</span>
                    <span class="c1"># Don&#39;t complain about 0/1 specialization, we</span>
                    <span class="c1"># expect to have to compile in this case anyway</span>
                    <span class="k">if</span> <span class="n">val</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="n">constraint_violated</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">constraint_violated</span><span class="p">:</span>
                    <span class="n">var_with_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">render_range_for_constraint_violation</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">constraint</span><span class="p">)</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Not all values of </span><span class="si">{</span><span class="n">var_with_range</span><span class="si">}</span><span class="s2"> are valid because &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">debug_name</span><span class="p">(</span><span class="n">source</span><span class="p">)</span><span class="si">}</span><span class="s2"> was inferred to be a constant (</span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">).&quot;</span>
                    <span class="p">)</span>
                    <span class="n">record_constraint_violation</span><span class="p">(</span><span class="n">constraint</span><span class="o">.</span><span class="n">warn_only</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug_name</span><span class="p">(</span><span class="n">source</span><span class="p">),</span> <span class="n">msg</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">context</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">placeholders</span><span class="p">,</span> <span class="n">sources</span><span class="p">,</span> <span class="n">input_contexts</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="kn">from</span> <span class="nn">torch._dynamo.source</span> <span class="kn">import</span> <span class="n">LocalSource</span>
                <span class="n">source</span> <span class="o">=</span> <span class="n">LocalSource</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">Source</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="n">SymInt</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
                <span class="n">track_symint</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">Tensorlike</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_traceable_wrapper_subclass</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
                <span class="kn">from</span> <span class="nn">torch._dynamo.source</span> <span class="kn">import</span> <span class="n">AttrSource</span>

                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">SubclassSymbolicContext</span><span class="p">)</span>

                <span class="c1"># For subclasses, we need to track symints on BOTH the outer</span>
                <span class="c1"># and inner tensors.</span>
                <span class="n">sources_tensors_constraints</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">context</span><span class="o">.</span><span class="n">constraint_sizes</span><span class="p">)</span>
                <span class="p">]</span>
                <span class="n">attrs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">__tensor_flatten__</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
                    <span class="n">inner_t</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
                    <span class="n">inner_context</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">inner_contexts</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span>
                    <span class="n">sources_tensors_constraints</span><span class="o">.</span><span class="n">append</span><span class="p">((</span>
                        <span class="n">AttrSource</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">attr</span><span class="p">),</span>
                        <span class="n">inner_t</span><span class="p">,</span>
                        <span class="n">inner_context</span><span class="o">.</span><span class="n">constraint_sizes</span>
                    <span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sources_tensors_constraints</span> <span class="o">=</span> <span class="p">[(</span><span class="n">source</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">context</span><span class="o">.</span><span class="n">constraint_sizes</span><span class="p">)]</span>

            <span class="k">for</span> <span class="n">src</span><span class="p">,</span> <span class="n">curr_t</span><span class="p">,</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">sources_tensors_constraints</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ss</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">curr_t</span><span class="o">.</span><span class="n">size</span><span class="p">()):</span>
                    <span class="n">property_source</span> <span class="o">=</span> <span class="n">TensorPropertySource</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">TensorProperty</span><span class="o">.</span><span class="n">SIZE</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                    <span class="n">track_symint</span><span class="p">(</span><span class="n">property_source</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">constraint</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ss</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">curr_t</span><span class="o">.</span><span class="n">stride</span><span class="p">()):</span>
                    <span class="n">track_symint</span><span class="p">(</span><span class="n">TensorPropertySource</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">TensorProperty</span><span class="o">.</span><span class="n">STRIDE</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">ss</span><span class="p">)</span>
                <span class="n">track_symint</span><span class="p">(</span><span class="n">TensorPropertySource</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">TensorProperty</span><span class="o">.</span><span class="n">STORAGE_OFFSET</span><span class="p">),</span> <span class="n">curr_t</span><span class="o">.</span><span class="n">storage_offset</span><span class="p">())</span>

        <span class="c1"># 1. Every input must equal the final simplified symbolic expression</span>
        <span class="c1">#    stored on the placeholder.  Given a placeholder (s0*2, s1),</span>
        <span class="c1">#    if we have an input (2, 3), we must show s0*2 == 2 and s1 == 3.</span>
        <span class="c1">#    This does a lot of work: it covers duck sizing and equality guards.</span>
        <span class="n">exprs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim_constraints</span> <span class="o">=</span> <span class="n">DimConstraints</span><span class="p">(</span>
            <span class="n">symbol_to_source</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">var_to_val</span><span class="p">,</span>
            <span class="nb">set</span><span class="p">(</span><span class="n">symbol_to_constraints</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">source_name_to_debug_name</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_simplified</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">source</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">input_guards</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_translation_validation_enabled</span><span class="p">:</span>
                    <span class="c1"># Ignore sources that were not turned into SymInts.</span>
                    <span class="n">srcname</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">srcname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_to_symbol</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_add_target_expr</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">Eq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source_to_symbol</span><span class="p">[</span><span class="n">srcname</span><span class="p">],</span> <span class="n">expr</span><span class="p">))</span>

                <span class="c1"># Small optimization</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="n">symbol_to_source</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="n">source</span> <span class="o">==</span> <span class="n">symbol_to_source</span><span class="p">[</span><span class="n">expr</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># This logic excludes static values found on tensors from guarding, because</span>
                <span class="c1"># dynamo&#39;s check_tensor_fn does that (see guards.cpp).</span>
                <span class="c1"># However, for non tensor sources, we still need to guard here.</span>
                <span class="k">if</span> <span class="n">ignore_static</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">TensorPropertySource</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Skipping guard </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">source_ref</span><span class="p">(</span><span class="n">source</span><span class="p">)</span><span class="si">}</span><span class="s2"> == </span><span class="si">{</span><span class="n">expr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">continue</span>

                <span class="k">if</span> <span class="n">is_dim</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dim_constraints</span><span class="o">.</span><span class="n">add_equality</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>

                <span class="n">sexpr</span> <span class="o">=</span> <span class="n">ShapeGuardPrinter</span><span class="p">(</span><span class="n">symbol_to_source</span><span class="p">,</span> <span class="n">source_ref</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_to_sources</span><span class="p">)</span><span class="o">.</span><span class="n">doprint</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
                <span class="n">exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">source_ref</span><span class="p">(</span><span class="n">source</span><span class="p">)</span><span class="si">}</span><span class="s2"> == </span><span class="si">{</span><span class="n">sexpr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="n">expr</span> <span class="ow">in</span> <span class="n">symbol_to_constraints</span> <span class="ow">and</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">TensorPropertySource</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="n">source</span><span class="o">.</span><span class="n">prop</span> <span class="ow">is</span> <span class="n">TensorProperty</span><span class="o">.</span><span class="n">SIZE</span>
                    <span class="ow">and</span> <span class="n">equalities_inputs</span> <span class="ow">and</span>
                    <span class="ow">not</span> <span class="n">equalities_inputs</span><span class="o">.</span><span class="n">is_equal</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">symbol_to_source</span><span class="p">[</span><span class="n">expr</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="p">):</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;The values of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">debug_name</span><span class="p">(</span><span class="n">source</span><span class="p">)</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">source</span><span class="o">.</span><span class="n">name</span><span class="p">()</span><span class="si">}</span><span class="s2"> and &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">debug_name</span><span class="p">(</span><span class="n">symbol_to_source</span><span class="p">[</span><span class="n">expr</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">symbol_to_source</span><span class="p">[</span><span class="n">expr</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">()</span><span class="si">}</span><span class="s2"> &quot;</span>
                        <span class="s2">&quot;must always be equal.&quot;</span>
                    <span class="p">)</span>
                    <span class="n">record_constraint_violation</span><span class="p">(</span><span class="n">equalities_inputs</span><span class="o">.</span><span class="n">warn_only</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug_name</span><span class="p">(</span><span class="n">source</span><span class="p">),</span> <span class="n">msg</span><span class="p">)</span>
                <span class="c1"># NB: Not necessary to report constraint violations here:</span>
                <span class="c1"># constraints are guaranteed to be on symbols (we&#39;ve already</span>
                <span class="c1"># caught constants and non-atomic expressions), so we only</span>
                <span class="c1"># have relational constraints, but we don&#39;t support those</span>
                <span class="c1"># at the moment</span>

        <span class="c1"># 2. Every guard must evaluate to True (but remember many guards</span>
        <span class="c1">#    like s0 == s1*2 because trivial due to simplification)</span>
        <span class="n">issued</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">issue_guard</span><span class="p">(</span><span class="n">guard</span><span class="p">:</span> <span class="n">ShapeGuard</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">guard</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>

            <span class="c1"># Avoid re-issueing the same guard.</span>
            <span class="k">if</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">issued</span><span class="p">:</span>
                <span class="k">return</span>

            <span class="n">issued</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">is_trivial</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">is_dim</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">free_symbols</span> <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">symbol_to_source</span><span class="p">[</span><span class="n">s</span><span class="p">]):</span>
                    <span class="n">is_trivial</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim_constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
                <span class="n">guard_expr</span> <span class="o">=</span> <span class="n">ShapeGuardPrinter</span><span class="p">(</span><span class="n">symbol_to_source</span><span class="p">,</span> <span class="n">source_ref</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_to_sources</span><span class="p">)</span><span class="o">.</span><span class="n">doprint</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
                <span class="n">exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">guard_expr</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_target_expr</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
                <span class="c1"># A non-relational constraint on a single sizevar can violate</span>
                <span class="c1"># a constraint</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_trivial</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">symbol</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">))</span>
                    <span class="n">source</span> <span class="o">=</span> <span class="n">symbol_to_source</span><span class="p">[</span><span class="n">symbol</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">constraints</span> <span class="o">=</span> <span class="n">symbol_to_constraints</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">constraints</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">StrictMinMaxConstraint</span><span class="p">):</span>
                            <span class="n">var_with_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">render_range_for_constraint_violation</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;Not all values of </span><span class="si">{</span><span class="n">var_with_range</span><span class="si">}</span><span class="s2"> &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;satisfy the generated guard </span><span class="si">{</span><span class="n">guard_expr</span><span class="si">}</span><span class="s2">.&quot;</span>
                            <span class="p">)</span>
                            <span class="n">record_constraint_violation</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">warn_only</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug_name</span><span class="p">(</span><span class="n">source</span><span class="p">),</span> <span class="n">msg</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">RelaxedUnspecConstraint</span><span class="p">):</span>
                            <span class="c1"># This is fine, we allow guards here as long as it</span>
                            <span class="c1"># didn&#39;t constrain it to one value  (we don&#39;t</span>
                            <span class="c1"># actually know this; this depends on our</span>
                            <span class="c1"># ValueRanges reasoning capability)</span>
                            <span class="k">pass</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unrecognized constraint </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Failing guard allocated at: </span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">guard</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">format</span><span class="p">()))</span>
                <span class="k">raise</span>

        <span class="c1"># First, issue all the non-trivial guards.</span>
        <span class="k">for</span> <span class="n">guard</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">guards</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_evaluate_static</span><span class="p">(</span><span class="n">guard</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">issue_guard</span><span class="p">(</span><span class="n">guard</span><span class="p">)</span>

        <span class="c1"># Then, issue the guards that refine the value range of tracked symbols.</span>
        <span class="c1"># We need to explicitly issue these guards, since they are the ones that</span>
        <span class="c1"># guarantee the symbol&#39;s value range. Plus, due to the updated value</span>
        <span class="c1"># range, they may be skipped in the previous step.</span>
        <span class="k">for</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">guards</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_to_guards</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">symbol</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">symbol_to_source</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">guard</span> <span class="ow">in</span> <span class="n">guards</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">guard</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">issue_guard</span><span class="p">(</span><span class="n">guard</span><span class="p">)</span>

        <span class="c1"># 3. Every symbol must be within its value range (this handles 0/1</span>
        <span class="c1"># specialization too).  NB: because we never update value ranges</span>
        <span class="c1"># except in case of explicit user annotation, these are not included</span>
        <span class="c1"># in simplified.  However, when we start updating value ranges</span>
        <span class="c1"># these should probably get reported in tests too</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_simplified</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">sources</span> <span class="ow">in</span> <span class="n">symbol_to_source</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_to_range</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">symbol</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_to_range</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_to_range</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span>

                <span class="k">assert</span> <span class="n">sources</span>
                <span class="k">assert</span> <span class="n">symbol</span><span class="o">.</span><span class="n">is_integer</span>
                <span class="n">g_lower</span><span class="p">,</span> <span class="n">g_upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_to_guards</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">lower</span> <span class="o">!=</span> <span class="o">-</span><span class="n">sympy</span><span class="o">.</span><span class="n">oo</span> <span class="ow">and</span> <span class="n">g_lower</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">is_dim</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">dim_constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">Ge</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">lower</span><span class="p">))</span>
                    <span class="n">bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">lower</span><span class="p">))</span>
                <span class="n">bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">source_ref</span><span class="p">(</span><span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="c1"># NB: This looks like an off-by-one error but it&#39;s not: the</span>
                <span class="c1"># upper bound may be sys.maxsize - 1 because we intentionally</span>
                <span class="c1"># exclude sys.maxsize from our bounds to deal with direct</span>
                <span class="c1"># == INT_MAX guards, but it&#39;s still dumb to actually test it.</span>
                <span class="c1"># Note that you can be off by a pretty large constant and it</span>
                <span class="c1"># won&#39;t matter because sizes in practice will be no where near</span>
                <span class="c1"># the 64-bit limit.</span>
                <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">upper</span> <span class="o">!=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">oo</span> <span class="ow">and</span> <span class="n">r</span><span class="o">.</span><span class="n">upper</span> <span class="o">&lt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">g_upper</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">is_dim</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">dim_constraints</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">Le</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">upper</span><span class="p">))</span>
                    <span class="n">bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">upper</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot; &lt;= &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">bounds</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">constraint_violations</span><span class="p">:</span>
            <span class="n">warn_msgs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">error_msgs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">debug_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">warn_only</span><span class="p">,</span> <span class="n">debug_name</span><span class="p">,</span> <span class="n">msg</span> <span class="ow">in</span> <span class="n">constraint_violations</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">warn_only</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">warn_msgs</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">. </span><span class="si">{</span><span class="n">msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="n">warn_msgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;  - </span><span class="si">{</span><span class="n">msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="n">error_msgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                    <span class="n">debug_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">debug_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">error_msgs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">debug_names</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">debug_names</span><span class="p">)</span>
                <span class="n">err</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">error_msgs</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">ConstraintViolationError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Constraints violated (</span><span class="si">{</span><span class="n">debug_names</span><span class="si">}</span><span class="s2">)! &quot;</span>
                    <span class="s2">&quot;For more information, run with TORCH_LOGS=</span><span class="se">\&quot;</span><span class="s2">+dynamic</span><span class="se">\&quot;</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">err</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">warn_msgs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> Warning only constraints violated&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">warn_msgs</span><span class="p">))</span>

        <span class="n">signpost_event</span><span class="p">(</span>
            <span class="s2">&quot;dynamic&quot;</span><span class="p">,</span>
            <span class="s2">&quot;produce_guards&quot;</span><span class="p">,</span>
            <span class="p">{</span>
                <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">co_fields</span><span class="p">,</span>
                <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">counter</span><span class="p">,</span>
                <span class="s2">&quot;num_guards&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">exprs</span><span class="p">),</span>
                <span class="s2">&quot;free_symbols&quot;</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">symbol_to_source</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span><span class="p">),</span>
            <span class="p">},</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_translation_validation_enabled</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">torch.fx.experimental.validator</span> <span class="kn">import</span> <span class="n">PopulateValidator</span>

            <span class="c1"># Add all deferred runtime assertions; these are not technically</span>
            <span class="c1"># handled by produce_guards but we need to put them in the target</span>
            <span class="c1"># set</span>
            <span class="k">for</span> <span class="n">ras</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deferred_runtime_asserts</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">ra</span> <span class="ow">in</span> <span class="n">ras</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_add_target_expr</span><span class="p">(</span><span class="n">ra</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>

            <span class="c1"># Add value range bound guards for all symbols with no trivial bounds.</span>
            <span class="c1"># Reason: &#39;_maybe_evaluate_static&#39; may eliminate guards based on the</span>
            <span class="c1"># refined value ranges.</span>
            <span class="k">for</span> <span class="n">sym</span><span class="p">,</span> <span class="n">vr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_to_range</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">vr</span><span class="o">.</span><span class="n">lower</span> <span class="o">!=</span> <span class="o">-</span><span class="n">sympy</span><span class="o">.</span><span class="n">oo</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_add_target_expr</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">Le</span><span class="p">(</span><span class="n">vr</span><span class="o">.</span><span class="n">lower</span><span class="p">,</span> <span class="n">sym</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">vr</span><span class="o">.</span><span class="n">upper</span> <span class="o">!=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">oo</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_add_target_expr</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">Le</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">vr</span><span class="o">.</span><span class="n">upper</span><span class="p">))</span>

            <span class="c1"># Before validating, populate the input of the validator with the</span>
            <span class="c1"># built FX graph.</span>
            <span class="k">with</span> <span class="n">fx_traceback</span><span class="o">.</span><span class="n">preserve_node_meta</span><span class="p">():</span>
                <span class="n">PopulateValidator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">validator</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_translation_validate</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">exprs</span>

    <span class="k">def</span> <span class="nf">produce_guards_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">placeholders</span><span class="p">,</span> <span class="n">ignore_static</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Expected to be used with evaluate_guards_expression(). Produces the guards</span>
<span class="sd">        for the given placeholders and returns a string expression to be evaluated</span>
<span class="sd">        by evaluate_guards_expression given concrete values for the placeholders.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">torch._dynamo.source</span> <span class="kn">import</span> <span class="n">LocalSource</span>
        <span class="n">arg_names</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;t</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">placeholders</span><span class="p">))]</span>
        <span class="n">guards</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">produce_guards</span><span class="p">(</span><span class="n">placeholders</span><span class="p">,</span> <span class="p">[</span><span class="n">LocalSource</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arg_names</span><span class="p">],</span> <span class="n">ignore_static</span><span class="o">=</span><span class="n">ignore_static</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">guards</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot; and &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">guards</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">evaluate_guards_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Expected to be used with produce_guards_expression(). Evaluates an expression</span>
<span class="sd">        generated by produce_guards_expression for the given concrete args.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arg_names</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;t</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">))]</span>
        <span class="k">return</span> <span class="nb">eval</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">SYMPY_INTERP</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;L&quot;</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">arg_names</span><span class="p">,</span> <span class="n">args</span><span class="p">))})</span>

    <span class="k">def</span> <span class="nf">evaluate_guards_for_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">placeholders</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">ignore_static</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">code</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">produce_guards_expression</span><span class="p">(</span><span class="n">placeholders</span><span class="p">,</span> <span class="n">ignore_static</span><span class="o">=</span><span class="n">ignore_static</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">code</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_guards_expression</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">bind_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">placeholders</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="c1"># Given a paired list of placeholders (fake tensors with</span>
        <span class="c1"># symbolic sizes) and concrete arguments (regular tensors</span>
        <span class="c1"># with real sizes), returns a dictionary mapping each</span>
        <span class="c1"># symbol to its real value.  So for example, if you</span>
        <span class="c1"># have a placeholder with size (s0, s1), binding</span>
        <span class="c1"># (2, 4) to it will give you {s0: 2, s1: 4}.  This is</span>
        <span class="c1"># not guaranteed to bind ALL symbols in the ShapeEnv;</span>
        <span class="c1"># we can&#39;t bind a symbol if it doesn&#39;t occur in any placeholder,</span>
        <span class="c1"># and symbols that already have replacements won&#39;t get bindings.</span>

        <span class="c1"># This is a little duplicative with evaluate_guards but</span>
        <span class="c1"># it&#39;s different enough that it seemed cleanest to make</span>
        <span class="c1"># another copy.  This assumes the guards are already checked,</span>
        <span class="c1"># though if it&#39;s cheap we&#39;ll check for shenanigans</span>
        <span class="n">bindings</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">def</span> <span class="nf">bind_symint</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">SymInt</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">bindings</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="n">bindings</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">==</span> <span class="n">arg</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">bindings</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">bindings</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="o">-</span><span class="n">s</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">):</span>
                    <span class="k">if</span> <span class="o">-</span><span class="n">s</span> <span class="ow">in</span> <span class="n">bindings</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="n">bindings</span><span class="p">[</span><span class="o">-</span><span class="n">s</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="n">arg</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">bindings</span><span class="p">[</span><span class="o">-</span><span class="n">s</span><span class="p">]</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="o">-</span><span class="n">arg</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">bindings</span><span class="p">[</span><span class="o">-</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">arg</span>

        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">placeholders</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">SymInt</span><span class="p">):</span>
                <span class="n">bind_symint</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">size</span><span class="p">()):</span>
                <span class="n">bind_symint</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">s</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">stride</span><span class="p">()):</span>
                <span class="n">bind_symint</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">stride</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">s</span><span class="p">)</span>
            <span class="n">bind_symint</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">storage_offset</span><span class="p">(),</span> <span class="n">t</span><span class="o">.</span><span class="n">storage_offset</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">bindings</span>

    <span class="k">def</span> <span class="nf">get_nontrivial_guards</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">guard</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span> <span class="k">for</span> <span class="n">guard</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">guards</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_evaluate_static</span><span class="p">(</span><span class="n">guard</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">format_guards</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">format_tb</span><span class="p">(</span><span class="n">tb</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;&quot;</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">   Guarded at:</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;   &#39;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">tb</span><span class="o">.</span><span class="n">format</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; - </span><span class="si">{</span><span class="n">guard</span><span class="o">.</span><span class="n">expr</span><span class="si">}{</span><span class="n">format_tb</span><span class="p">(</span><span class="n">guard</span><span class="o">.</span><span class="n">stack</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">guard</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">guards</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_shape_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">shape_groups</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">replacements</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">shape_groups</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">shape_groups</span>

    <span class="nd">@_lru_cache</span>
    <span class="k">def</span> <span class="nf">_maybe_evaluate_static</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="s2">&quot;sympy.Expr&quot;</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">unbacked_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">compute_hint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">expect_rational</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">size_oblivious</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Optional[sympy.Expr]&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tries to evaluate expr without introducing guards</span>

<span class="sd">        If unbacked_only == True, then we only do substitutions on</span>
<span class="sd">        unbacked SymInts (leaving regular hinted integers alone).  This could</span>
<span class="sd">        result in an expression that still contains backed SymInts, which you</span>
<span class="sd">        could then potentially guard on.</span>

<span class="sd">        Use compute_hint == True if you are trying to compute a non-binding</span>
<span class="sd">        hint for the particular hint values of backed SymInts, e.g., if</span>
<span class="sd">        s0 happens to be 3 this run, compute_hint will subsitute s0 with 3.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">compute_hint</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_to_val</span><span class="p">)</span>

        <span class="n">expr</span> <span class="o">=</span> <span class="n">canonicalize_bool_expr</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

        <span class="n">symbols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span>

        <span class="c1"># Apply known runtime asserts</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">:</span>
            <span class="c1"># Unbacked symints only</span>
            <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_to_val</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">subst</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">ra</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deferred_runtime_asserts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">()):</span>
                <span class="k">if</span> <span class="n">compute_hint</span><span class="p">:</span>
                    <span class="n">e</span> <span class="o">=</span> <span class="n">canonicalize_bool_expr</span><span class="p">(</span><span class="n">ra</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_to_val</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">e</span> <span class="o">=</span> <span class="n">ra</span><span class="o">.</span><span class="n">expr</span>
                <span class="c1"># e is already canonical</span>
                <span class="n">subst</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">true</span>
                <span class="n">subst</span><span class="p">[</span><span class="n">canonicalize_bool_expr</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">Not</span><span class="p">(</span><span class="n">e</span><span class="p">))]</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">false</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Eq</span><span class="p">):</span>
                    <span class="n">subst</span><span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">Le</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">rhs</span><span class="p">)]</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">true</span>
                    <span class="n">subst</span><span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">Le</span><span class="p">(</span><span class="o">-</span><span class="n">e</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="o">-</span><span class="n">e</span><span class="o">.</span><span class="n">rhs</span><span class="p">)]</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">true</span>
                    <span class="n">subst</span><span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">Lt</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">rhs</span><span class="p">)]</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">false</span>
                    <span class="n">subst</span><span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">Lt</span><span class="p">(</span><span class="o">-</span><span class="n">e</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="o">-</span><span class="n">e</span><span class="o">.</span><span class="n">rhs</span><span class="p">)]</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">false</span>

            <span class="c1"># NB: this helps us deal with And/Or connectives</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">subst</span><span class="p">)</span>

        <span class="c1"># Simplify making use of value range lower bound</span>
        <span class="n">new_shape_env</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">new_range_env</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">symbols</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_to_val</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">SingletonInt</span><span class="p">):</span>
                <span class="c1"># Skip var_to_range logic for SingletonInt which is only used</span>
                <span class="c1"># for jagged layout NestedTensors today</span>
                <span class="k">continue</span>
            <span class="n">vr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_to_range</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">size_oblivious</span> <span class="ow">and</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">size_like</span><span class="p">:</span>
                <span class="n">lower</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">vr</span><span class="o">.</span><span class="n">lower</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lower</span> <span class="o">=</span> <span class="n">vr</span><span class="o">.</span><span class="n">lower</span>
            <span class="c1"># Don&#39;t do anything if we don&#39;t have a nontrivial lower bound</span>
            <span class="c1"># Also don&#39;t do anything if we asked only to simplify unbacked</span>
            <span class="c1"># SymInt</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">lower</span> <span class="o">&lt;</span> <span class="p">(</span><span class="o">-</span><span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span> <span class="ow">or</span>
                <span class="p">(</span><span class="n">unbacked_only</span> <span class="ow">and</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_to_val</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">new_range_env</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">vr</span>
                <span class="k">continue</span>
            <span class="c1"># Positive means &gt;= 1</span>
            <span class="c1"># Positive - 1 means &gt;= 0</span>
            <span class="c1"># Positive + lower - 1 means &gt;= lower</span>
            <span class="c1"># The new symbol &#39;s&#39; is &quot;too low&quot;, so when we substitute it in</span>
            <span class="c1"># we have to increase it by offset (and conversely, the new</span>
            <span class="c1"># variables have to have their value range bounds adjusted as</span>
            <span class="c1"># well)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;shape_</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">lower</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">new_shape_env</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">offset</span>
            <span class="n">new_range_env</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">SymPyValueRangeAnalysis</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">vr</span><span class="p">,</span> <span class="o">-</span><span class="n">offset</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">repl</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">repl</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">new_expr</span> <span class="o">=</span> <span class="n">replace</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">new_shape_env</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">RecursionError</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;RecursionError in sympy.xreplace(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">new_shape_env</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">counter</span><span class="p">[</span><span class="s2">&quot;sympy_recursion_error&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">floor_div_replace</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">new_expr</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">FloorDiv</span><span class="p">):</span>
            <span class="n">floor_div_replace</span><span class="p">[</span><span class="n">atom</span><span class="p">]</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">atom</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">new_expr</span> <span class="o">=</span> <span class="n">safe_expand</span><span class="p">(</span><span class="n">new_expr</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">floor_div_replace</span><span class="p">))</span>
        <span class="c1"># TODO: when unbacked_only, can sometimes early return even when there</span>
        <span class="c1"># are still free symbols</span>
        <span class="k">if</span> <span class="n">new_expr</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">new_expr</span>

        <span class="c1"># Check if the range can solve it statically</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">bound_sympy</span><span class="p">(</span><span class="n">new_expr</span><span class="p">,</span> <span class="n">new_range_env</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">expect_rational</span><span class="p">:</span>
            <span class="n">_assert_bound_is_rational</span><span class="p">(</span><span class="n">new_expr</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">is_singleton</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">lower</span>

        <span class="k">return</span> <span class="n">new_expr</span> <span class="k">if</span> <span class="n">unbacked_only</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="nd">@_lru_cache</span>
    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="s2">&quot;sympy.Expr&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;sympy.Expr&quot;</span><span class="p">:</span>
        <span class="n">replacements</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">safe_expand</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">replacements</span><span class="p">))</span>

    <span class="nd">@_lru_cache</span>
    <span class="k">def</span> <span class="nf">_update_divisible</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">new_divisible</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">divisible</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">res</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
                <span class="n">new_divisible</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">divisible</span> <span class="o">=</span> <span class="n">new_divisible</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_version_counter</span><span class="p">()</span>

    <span class="nd">@_lru_cache</span>
    <span class="k">def</span> <span class="nf">simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="s2">&quot;sympy.Expr&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;sympy.Expr&quot;</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="c1"># TODO it would seem that this pass is not necessary given the</span>
        <span class="c1"># below replacement of // with /, but for nested FloorDivs</span>
        <span class="c1"># the non-recursive replacement doesn&#39;t work, and</span>
        <span class="c1"># recursive makes it hard to look up divisibility,</span>
        <span class="c1"># because existing divisibility info has FloorDiv in it, not /</span>
        <span class="c1"># for now just do a separate pass to catch common nested case</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">FloorDiv</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_divisible</span><span class="p">()</span>
            <span class="n">div_replacements</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">FloorDiv</span><span class="p">):</span>
                <span class="n">base</span><span class="p">,</span> <span class="n">divisor</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">args</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">divisor</span><span class="p">,</span> <span class="n">FloorDiv</span><span class="p">):</span>
                    <span class="n">base1</span><span class="p">,</span> <span class="n">divisor1</span> <span class="o">=</span> <span class="n">divisor</span><span class="o">.</span><span class="n">args</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">Mod</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">divisor</span><span class="p">))</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">divisible</span> <span class="ow">and</span> \
                            <span class="n">base</span> <span class="o">==</span> <span class="n">base1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">Mod</span><span class="p">(</span><span class="n">base1</span><span class="p">,</span> <span class="n">divisor1</span><span class="p">))</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">divisible</span><span class="p">:</span>
                        <span class="n">div_replacements</span><span class="p">[</span><span class="n">atom</span><span class="p">]</span> <span class="o">=</span> <span class="n">divisor1</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">div_replacements</span><span class="p">)</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">safe_expand</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">FloorDiv</span><span class="p">):</span>
            <span class="n">div_replacements</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">pows</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">Pow</span><span class="p">)</span>
            <span class="n">rationals</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">Rational</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">Integer</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">FloorDiv</span><span class="p">):</span>
                <span class="n">base</span><span class="p">,</span> <span class="n">divisor</span> <span class="o">=</span> <span class="n">fd</span><span class="o">.</span><span class="n">args</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">Mod</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">divisor</span><span class="p">))</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">divisible</span><span class="p">:</span>
                    <span class="n">div_replacements</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span> <span class="o">=</span> <span class="n">base</span> <span class="o">/</span> <span class="n">divisor</span>
            <span class="n">new_expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">div_replacements</span><span class="p">)</span>
            <span class="n">new_expr</span> <span class="o">=</span> <span class="n">safe_expand</span><span class="p">(</span><span class="n">new_expr</span><span class="p">)</span>
            <span class="n">new_pows</span> <span class="o">=</span> <span class="n">new_expr</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">Pow</span><span class="p">)</span>
            <span class="n">new_rationals</span> <span class="o">=</span> <span class="n">new_expr</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">Rational</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">new_expr</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">Integer</span><span class="p">))</span>
            <span class="c1"># divisions simplified away</span>
            <span class="k">if</span> <span class="n">new_pows</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">pows</span><span class="p">)</span> <span class="ow">and</span> <span class="n">new_rationals</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">rationals</span><span class="p">):</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">new_expr</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="nd">@lru_cache</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">size_hint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="s2">&quot;sympy.Expr&quot;</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets a size hint for a given expression from the underlying shapes we had.</span>
<span class="sd">        Does not introduce a guard, so only use this when you can guarantee that</span>
<span class="sd">        your code is still valid for arbitrary shapes (such as optimization decisions)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result_expr</span> <span class="o">=</span> <span class="n">safe_expand</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_to_val</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result_expr</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>

            <span class="kn">from</span> <span class="nn">torch.utils._sympy.singleton_int</span> <span class="kn">import</span> <span class="n">SingletonInt</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result_expr</span><span class="p">,</span> <span class="n">SingletonInt</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_evaluate_static</span><span class="p">(</span><span class="n">result_expr</span><span class="p">,</span> <span class="n">compute_hint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">r</span>
            <span class="k">if</span> <span class="n">allow_none</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_data_dependent_error</span><span class="p">(</span><span class="n">result_expr</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result_expr</span>

    <span class="c1"># NB: keep in sync with size_hint</span>
    <span class="nd">@lru_cache</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">has_hint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="s2">&quot;sympy.Expr&quot;</span><span class="p">):</span>
        <span class="n">result_expr</span> <span class="o">=</span> <span class="n">safe_expand</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_to_val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result_expr</span><span class="o">.</span><span class="n">is_number</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_evaluate_static</span><span class="p">(</span><span class="n">result_expr</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_make_data_dependent_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">unhinted_expr</span><span class="p">):</span>
        <span class="c1"># TODO: in a Dynamo context, having user code, and having the</span>
        <span class="c1"># name of the local, will be much better</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
            <span class="n">stacktrace</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_to_stack</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Data dependent variable &#39;</span><span class="si">%s</span><span class="s2">&#39; allocated at:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">stacktrace</span><span class="p">)</span>
        <span class="c1"># cpp_stack = CapturedTraceback.extract(cpp=True)</span>
        <span class="k">return</span> <span class="n">GuardOnDataDependentSymNode</span><span class="p">(</span>
            <span class="c1"># &quot;C++ stack trace:\n&quot; + &#39;&#39;.join(cpp_stack.format()) + &quot;\n\n&quot;</span>
            <span class="s2">&quot;It appears that you&#39;re trying to get a value out of symbolic int/float &quot;</span>
            <span class="s2">&quot;whose value is data-dependent (and thus we do not know the true value.)  &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;The expression we were trying to evaluate is </span><span class="si">{</span><span class="n">expr</span><span class="si">}</span><span class="s2"> (unhinted: </span><span class="si">{</span><span class="n">unhinted_expr</span><span class="si">}</span><span class="s2">).  &quot;</span>
            <span class="s2">&quot;For more information, run with TORCH_LOGS=</span><span class="se">\&quot;</span><span class="s2">+dynamic</span><span class="se">\&quot;</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="c1"># TODO: Help text about how to use our runtime tests to fix this</span>
            <span class="c1"># problem</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_replacement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="s2">&quot;sympy.Symbol&quot;</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="s2">&quot;sympy.Expr&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds or updates a replacement for a symbol.</span>
<span class="sd">        Use this instead of `self.replacements[a] = expr`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">print_specializations</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">Integer</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Float</span><span class="p">)):</span>
            <span class="c1"># specializing to a constant, which is likely unexpected</span>

            <span class="c1"># NOTE(avik): It is possible that we try logging the same specialization multiple times, e.g.,</span>
            <span class="c1"># when adding a to self.replacements, and again when simplifying an expression containing a.</span>
            <span class="c1"># Thus to avoid duplication, checking whether a is in self.replacements isn&#39;t enough; if it is,</span>
            <span class="c1"># it must not already map to `expr`. Fortunately this check is cheap because `expr` is a constant.</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">replacements</span> <span class="ow">or</span> <span class="n">expr</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">replacements</span><span class="p">[</span><span class="n">a</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Specializing </span><span class="si">%s</span><span class="s2"> to </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_to_sources</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span> <span class="n">expr</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;SPECIALIZATION&quot;</span><span class="p">,</span> <span class="n">stack_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;set_replacement </span><span class="si">%s</span><span class="s2"> = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replacements</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">expr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_version_counter</span><span class="p">()</span>

        <span class="c1"># When specializing &#39;a == expr&#39;, the equality should be also conveyed to</span>
        <span class="c1"># Z3, in case an expression uses &#39;a&#39;.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_target_expr</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">Eq</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">expr</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_add_divisible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="s2">&quot;sympy.Expr&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">divisible</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_version_counter</span><span class="p">()</span>

    <span class="nd">@_lru_cache</span>
    <span class="nd">@record_shapeenv_event</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">_find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="s2">&quot;sympy.Symbol&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;sympy.Expr&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implements a DSU-like algorithm to find the variable that represents a</span>
<span class="sd">        Also handles transitive non-identity replacements.</span>

<span class="sd">        a: b + c</span>
<span class="sd">        c: d</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">replacements</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">replacements</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
        <span class="n">cur_replace</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">res</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_replacement</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">replacements</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">cur_replace</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replacements</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>

    <span class="nd">@lru_cache</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_maybe_guard_eq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;sympy.Eq&quot;</span><span class="p">,</span> <span class="s2">&quot;sympy.Ne&quot;</span><span class="p">],</span> <span class="n">concrete_bool</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluates the result of an eq call. If true, uses information to</span>
<span class="sd">        simplify shapes (i.e. a == b or a % 5 == 0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">concrete_bool</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">bool</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Eq</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">concrete_bool</span><span class="p">:</span>
                <span class="k">return</span>
        <span class="c1"># NB: Apparently this is load bearing; to see what test fails if</span>
        <span class="c1"># you comment it out run:</span>
        <span class="c1"># python test/functorch/test_aotdispatch.py -k</span>
        <span class="c1"># test_aot_autograd_symbolic_module_exhaustive_nn_LazyConv3d_cpu_float32</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Ne</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">concrete_bool</span><span class="p">:</span>
                <span class="k">return</span>
        <span class="n">free</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">free</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;The expression should not be static by this point: </span><span class="si">{</span><span class="n">expr</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="c1"># In case of really gnarly expression, we don&#39;t blow up</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">free</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="c1"># NB: prioritize unbacked symints for solving by ordering them last</span>
        <span class="n">free</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">free</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size_hint</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="ow">or</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># type: ignore[attr-defined]</span>
        <span class="n">lhs</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">lhs</span>
        <span class="n">rhs</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">rhs</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">Mod</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">floor_div_atoms</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">FloorDiv</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">rhs</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">FloorDiv</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">floor_div_atoms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">divisor</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">floor_div_atoms</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
                <span class="c1"># short-circuit when no solving is needed</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">)</span> <span class="ow">and</span> <span class="n">free_unbacked_symbols</span><span class="p">(</span><span class="n">lhs</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_set_replacement</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find</span><span class="p">(</span><span class="n">rhs</span><span class="p">))</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">)</span> <span class="ow">and</span> <span class="n">free_unbacked_symbols</span><span class="p">(</span><span class="n">rhs</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_set_replacement</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find</span><span class="p">(</span><span class="n">lhs</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">try_solve</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">free</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">floordiv_inequality</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">is_integer</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">sympy</span><span class="o">.</span><span class="n">preorder_traversal</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
                        <span class="n">new_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                        <span class="n">ok</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unbacked_symint</span><span class="p">(</span><span class="n">free</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                            <span class="c1"># If you have i0 + i1 + i2 = s0, don&#39;t substitute i2 =</span>
                            <span class="c1"># s0 - i0 - i1.  Arguably this should be OK but the</span>
                            <span class="c1"># runtime assert machinery is very delicate right now</span>
                            <span class="c1"># so this causes things to fail e.g.,</span>
                            <span class="c1"># test_split_unbacked_sizes</span>
                            <span class="n">ok</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">free_unbacked_symbols</span><span class="p">(</span><span class="n">new_var</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># Never substitute backed with unbacked</span>
                            <span class="n">ok</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">free_unbacked_symbols</span><span class="p">(</span><span class="n">new_var</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span>
                        <span class="k">if</span> <span class="n">ok</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_set_replacement</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">free</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">new_var</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">Mod</span><span class="p">):</span>
            <span class="n">mod_expr</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Mod</span><span class="p">)))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">try_solve</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">mod_expr</span><span class="p">,</span> <span class="n">floordiv_inequality</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_add_divisible</span><span class="p">(</span><span class="n">mod_expr</span><span class="p">)</span>
                    <span class="c1"># This is a little bit of extra logic to make things like</span>
                    <span class="c1"># torch.empty(i0, q).view(c, -1, q) work out</span>
                    <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">mod_expr</span><span class="o">.</span><span class="n">args</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Number</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Mul</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">c</span><span class="p">,</span> <span class="n">i0</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">args</span>
                        <span class="c1"># Given Mod(c * i0, q) == 0</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Number</span><span class="p">)</span> <span class="ow">and</span>
                            <span class="nb">isinstance</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">)</span> <span class="ow">and</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">is_unbacked_symint</span><span class="p">(</span><span class="n">i0</span><span class="p">)</span>
                        <span class="p">):</span>
                            <span class="c1"># We have Mod(i0, q / c) == 0, which means we can</span>
                            <span class="c1"># rewrite i0 as (q / gcd(q, c)) * i1</span>
                            <span class="n">d</span> <span class="o">=</span> <span class="n">q</span> <span class="o">/</span> <span class="n">sympy</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                            <span class="n">i1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_unbacked_symint</span><span class="p">()</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span>
                            <span class="c1"># Propagate the value ranges.  It doesn&#39;t really</span>
                            <span class="c1"># matter if we use truediv or floordiv, because we</span>
                            <span class="c1"># have established divisibility.</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">var_to_range</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="o">=</span> <span class="n">SymPyValueRangeAnalysis</span><span class="o">.</span><span class="n">truediv</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">var_to_range</span><span class="p">[</span><span class="n">i0</span><span class="p">],</span> <span class="n">ValueRanges</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                            <span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_set_replacement</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">d</span> <span class="o">*</span> <span class="n">i1</span><span class="p">)</span>

            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">return</span>

    <span class="c1"># See: Note - On 0/1 specialization</span>
    <span class="c1"># NB: sys.maxsize is NOT allowed for sizes, because we use MAX_INT</span>
    <span class="c1"># as a sentinel sometimes.  Your sizevar isn&#39;t going to be</span>
    <span class="c1"># anywhere near the max 64-bit integer anyway.</span>
    <span class="k">def</span> <span class="nf">_default_value_range</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ValueRanges</span><span class="p">:</span>
        <span class="n">lower</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">specialize_zero_one</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">ValueRanges</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_default_unspecified_value_range</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ValueRanges</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ValueRanges</span><span class="p">(</span><span class="o">-</span><span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span><span class="p">)</span>

    <span class="nd">@_lru_cache</span>
    <span class="k">def</span> <span class="nf">_simplify_floor_div</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="n">floor_divs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">FloorDiv</span><span class="p">))</span>
        <span class="c1"># we expect floor_divs to be exact,</span>
        <span class="c1"># and thus add the guards for the exact floordivs,</span>
        <span class="c1"># even if tracing doesn&#39;t require them otherwise</span>
        <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">floor_divs</span><span class="p">):</span>
            <span class="n">base</span><span class="p">,</span> <span class="n">divisor</span> <span class="o">=</span> <span class="n">fd</span><span class="o">.</span><span class="n">args</span>
            <span class="n">mod_expr</span> <span class="o">=</span> <span class="n">Mod</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">divisor</span><span class="p">)</span>
            <span class="n">eq_expr</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Eq</span><span class="p">(</span><span class="n">mod_expr</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="c1"># add necessary mod guards</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_expr</span><span class="p">(</span><span class="n">eq_expr</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="c1"># We&#39;re about to add a guard/runtime assert, check if the ShapeEnv is frozen</span>
    <span class="c1"># and if so issue a warning</span>
    <span class="k">def</span> <span class="nf">_check_frozen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">concrete_val</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">frozen</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">counter</span><span class="p">[</span><span class="s2">&quot;ignored_backward_guard&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">signpost_event</span><span class="p">(</span>
                <span class="s2">&quot;dynamic&quot;</span><span class="p">,</span>
                <span class="s2">&quot;evaluate_expr_frozen&quot;</span><span class="p">,</span>
                <span class="p">{</span>
                    <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">co_fields</span><span class="p">,</span>
                    <span class="s2">&quot;ignored_guard&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">expr</span><span class="si">}</span><span class="s2"> == </span><span class="si">{</span><span class="n">concrete_val</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="c1"># no version = original state (this signpost is expected)</span>
                    <span class="c1"># version 2 = dynamic backwards is eagerly compiled</span>
                    <span class="s2">&quot;version&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Ignored guard </span><span class="si">%s</span><span class="s2"> == </span><span class="si">%s</span><span class="s2">, this could result in accuracy problems&quot;</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">concrete_val</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_get_stack_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">fsummary</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">currentframe</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">frame</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">frame</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_filename</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">uninteresting_files</span><span class="p">():</span>
                    <span class="n">fsummary</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">FrameSummary</span><span class="p">(</span>
                        <span class="n">frame</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_filename</span><span class="p">,</span>
                        <span class="n">frame</span><span class="o">.</span><span class="n">f_lineno</span><span class="p">,</span>
                        <span class="n">frame</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">break</span>
                <span class="n">frame</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">f_back</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">frame</span>

        <span class="c1"># NB: this stack is truncated, but it&#39;s fine because the main</span>
        <span class="c1"># stack_info will give you the rest of the info you need</span>
        <span class="n">maybe_user_loc</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">user_tb</span> <span class="o">=</span> <span class="n">TracingContext</span><span class="o">.</span><span class="n">extract_stack</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">user_tb</span><span class="p">:</span>
            <span class="n">maybe_user_loc</span> <span class="o">=</span> <span class="s2">&quot; at &quot;</span> <span class="o">+</span> <span class="n">format_frame</span><span class="p">(</span><span class="n">user_tb</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">fsummary</span><span class="p">,</span> <span class="n">user_tb</span><span class="p">,</span> <span class="n">maybe_user_loc</span>

    <span class="k">def</span> <span class="nf">_log_guard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">):</span>
            <span class="n">fsummary</span><span class="p">,</span> <span class="n">user_tb</span><span class="p">,</span> <span class="n">maybe_user_loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_stack_summary</span><span class="p">()</span>

            <span class="n">str_g</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>

            <span class="c1"># TODO: make this an artifact</span>
            <span class="n">is_debug</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">extended_debug_guard_added</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">str_g</span> <span class="o">==</span> <span class="n">config</span><span class="o">.</span><span class="n">extended_debug_guard_added</span><span class="p">:</span>
                <span class="n">is_debug</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">maybe_extra_debug</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">if</span> <span class="n">is_debug</span> <span class="ow">and</span> <span class="n">user_tb</span><span class="p">:</span>
                <span class="n">maybe_extra_debug</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">User Stack (most recent call last):</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span>
                    <span class="s1">&#39;  (snipped, see stack below for prefix)</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span>
                    <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">traceback</span><span class="o">.</span><span class="n">format_list</span><span class="p">(</span><span class="n">user_tb</span><span class="p">))</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">is_debug</span><span class="p">:</span>
                <span class="n">cpp_stack</span> <span class="o">=</span> <span class="n">CapturedTraceback</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">cpp</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">maybe_extra_debug</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">C++ stack trace:</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cpp_stack</span><span class="o">.</span><span class="n">format</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> [guard added]</span><span class="si">%s</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">)</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">prefix</span><span class="p">,</span>
                <span class="n">str_g</span><span class="p">,</span>
                <span class="n">maybe_user_loc</span><span class="p">,</span>
                <span class="n">format_frame</span><span class="p">(</span><span class="n">fsummary</span><span class="p">),</span>
                <span class="n">maybe_extra_debug</span><span class="p">,</span>
                <span class="n">stack_info</span><span class="o">=</span><span class="n">is_debug</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="nd">@lru_cache</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span>
    <span class="nd">@record_shapeenv_event</span><span class="p">(</span><span class="n">save_tracked_fakes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">evaluate_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orig_expr</span><span class="p">:</span> <span class="s2">&quot;sympy.Expr&quot;</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fx_node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">expect_rational</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">size_oblivious</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given an expression, evaluates it, adding guards if necessary</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@lru_cache</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">compute_concrete_val</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">hint</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">size_hint</span><span class="p">(</span><span class="n">orig_expr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">sympy</span><span class="o">.</span><span class="n">sympify</span><span class="p">(</span><span class="n">hint</span><span class="p">)</span>

        <span class="c1"># Check if:</span>
        <span class="c1">#   1. &#39;translation_validation&#39; is set</span>
        <span class="c1">#   2. the corresponding &#39;fx_node&#39; is not &#39;None&#39;</span>
        <span class="c1">#   3. the guard should not be suppressed</span>
        <span class="c1">#</span>
        <span class="c1"># If all of the above check, we create an FX node representing the</span>
        <span class="c1"># actual expression to be guarded.</span>
        <span class="n">node</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">fresh</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_translation_validation_enabled</span>
                <span class="ow">and</span> <span class="n">fx_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_suppress_guards_tls</span><span class="p">()</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">size_oblivious</span>
        <span class="p">):</span>
            <span class="n">concrete_val</span> <span class="o">=</span> <span class="n">compute_concrete_val</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">concrete_val</span> <span class="ow">is</span> <span class="n">sympy</span><span class="o">.</span><span class="n">true</span><span class="p">:</span>
                <span class="n">node</span><span class="p">,</span> <span class="n">fresh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_fx_call_function</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">_assert</span><span class="p">,</span> <span class="p">(</span><span class="n">fx_node</span><span class="p">,))</span>
            <span class="k">elif</span> <span class="n">concrete_val</span> <span class="ow">is</span> <span class="n">sympy</span><span class="o">.</span><span class="n">false</span><span class="p">:</span>
                <span class="n">neg</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_fx_call_function</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">not_</span><span class="p">,</span> <span class="p">(</span><span class="n">fx_node</span><span class="p">,))</span>
                <span class="n">node</span><span class="p">,</span> <span class="n">fresh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_fx_call_function</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">_assert</span><span class="p">,</span> <span class="p">(</span><span class="n">neg</span><span class="p">,))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">eql</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_fx_call_function</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">eq</span><span class="p">,</span> <span class="p">(</span><span class="n">fx_node</span><span class="p">,</span> <span class="n">concrete_val</span><span class="p">))</span>
                <span class="n">node</span><span class="p">,</span> <span class="n">fresh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_fx_call_function</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">_assert</span><span class="p">,</span> <span class="p">(</span><span class="n">eql</span><span class="p">,))</span>

            <span class="k">assert</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="c1"># If this is a fresh node, we have to remember the event index that</span>
            <span class="c1"># corresponds to this assertion node.</span>
            <span class="c1"># Reason: so that, given an assertion node, we can replay the ShapeEnv</span>
            <span class="c1"># events until the point where this assertion node was freshly created.</span>
            <span class="k">if</span> <span class="n">fresh</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_fx_node_metadata</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="c1"># After creating the FX node corresponding to orig_expr, we must make sure that</span>
        <span class="c1"># no error will be raised until the end of this function.</span>
        <span class="c1">#</span>
        <span class="c1"># Reason: the translation validation may become invalid otherwise.</span>
        <span class="c1">#</span>
        <span class="c1"># If an error is raised before the end of this function, we remove the FX node</span>
        <span class="c1"># inserted, and re-raise the error.</span>
        <span class="n">guard</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">tb</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">orig_expr</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;eval </span><span class="si">%s</span><span class="s2"> [trivial]&quot;</span><span class="p">,</span> <span class="n">orig_expr</span><span class="p">)</span>
                <span class="c1"># NB: don&#39;t test float as there may be precision issues</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hint</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)):</span>
                    <span class="k">assert</span> <span class="n">orig_expr</span> <span class="o">==</span> <span class="n">hint</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">orig_expr</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="n">hint</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">return</span> <span class="n">orig_expr</span>

            <span class="n">expr</span> <span class="o">=</span> <span class="n">orig_expr</span>

            <span class="n">static_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_evaluate_static</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span>
                                                      <span class="n">expect_rational</span><span class="o">=</span><span class="n">expect_rational</span><span class="p">,</span>
                                                      <span class="n">size_oblivious</span><span class="o">=</span><span class="n">size_oblivious</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">static_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;eval </span><span class="si">%s</span><span class="s2"> == </span><span class="si">%s</span><span class="s2"> [statically known]&quot;</span><span class="p">,</span> <span class="n">orig_expr</span><span class="p">,</span> <span class="n">static_expr</span><span class="p">)</span>
                <span class="c1"># NB: don&#39;t test float as there may be precision issues</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hint</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)):</span>
                    <span class="k">assert</span> <span class="n">static_expr</span> <span class="o">==</span> <span class="n">hint</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">static_expr</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="n">hint</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">return</span> <span class="n">static_expr</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">free_symbols</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_to_val</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="c1"># TODO: dedupe this with _maybe_evaluate_static</span>
                <span class="c1"># Attempt to eliminate the unbacked SymInt</span>
                <span class="n">new_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_evaluate_static</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">unbacked_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">new_expr</span><span class="o">.</span><span class="n">free_symbols</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_to_val</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                    <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_data_dependent_error</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_to_val</span><span class="p">),</span> <span class="n">expr</span><span class="p">)</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">new_expr</span>

            <span class="n">concrete_val</span> <span class="o">=</span> <span class="n">compute_concrete_val</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_frozen</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">concrete_val</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span>
                    <span class="n">config</span><span class="o">.</span><span class="n">inject_EVALUATE_EXPR_flip_equality_TESTING_ONLY</span>
                    <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hint</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">Eq</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Ne</span><span class="p">))</span>
            <span class="p">):</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Not</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">Eq</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Ne</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_guard_eq</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">bool</span><span class="p">(</span><span class="n">concrete_val</span><span class="p">))</span>
                <span class="c1"># TODO: If we successfully eliminate a symbol via equality, it</span>
                <span class="c1"># is not actually necessary to save a guard for the equality,</span>
                <span class="c1"># as we will implicitly generate a guard when we match that</span>
                <span class="c1"># input against the symbol</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">concrete_val</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Integer</span><span class="p">):</span>
                <span class="c1"># WARNING: we cannot actually do simplifications on guards</span>
                <span class="c1"># on floating point values, because Sympy generally does not</span>
                <span class="c1"># think expressions on integers can ever be equal to floating</span>
                <span class="c1"># point (e.g., sympy.Eq(s0/6, 0.5) evaluates to False).  Without</span>
                <span class="c1"># very clear algebraic laws that hold for floating point, such</span>
                <span class="c1"># simplifications are error prone anyway, so be sure not to</span>
                <span class="c1"># maybe_guard_eq in those cases.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_guard_eq</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">Eq</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">concrete_val</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">concrete_val</span> <span class="ow">is</span> <span class="n">sympy</span><span class="o">.</span><span class="n">true</span><span class="p">:</span>
                <span class="n">g</span> <span class="o">=</span> <span class="n">expr</span>
            <span class="k">elif</span> <span class="n">concrete_val</span> <span class="ow">is</span> <span class="n">sympy</span><span class="o">.</span><span class="n">false</span><span class="p">:</span>
                <span class="n">g</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Not</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">g</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Eq</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">concrete_val</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_suppress_guards_tls</span><span class="p">():</span>
                <span class="n">stack</span> <span class="o">=</span> <span class="n">CapturedTraceback</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">skip</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">guard</span> <span class="o">=</span> <span class="n">ShapeGuard</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">stack</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">guards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">guard</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fresh</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove_fx_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">raise</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_suppress_guards_tls</span><span class="p">():</span>
                <span class="k">assert</span> <span class="n">guard</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">refine_ranges</span><span class="p">(</span><span class="n">guard</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_log_guard</span><span class="p">(</span><span class="s2">&quot;eval&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;eval </span><span class="si">%s</span><span class="s2"> [guard suppressed]&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">concrete_val</span>

    <span class="k">def</span> <span class="nf">cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Break reference cycles.</span>
        <span class="c1"># This destroys the stacks. If you really want to keep them, we</span>
        <span class="c1"># just need some way to break references on code objects.</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">guards</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">cleanup</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_to_stack</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">s</span><span class="o">.</span><span class="n">cleanup</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ras</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deferred_runtime_asserts</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">ra</span> <span class="ow">in</span> <span class="n">ras</span><span class="p">:</span>
                <span class="n">ra</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">cleanup</span><span class="p">()</span>

    <span class="nd">@record_shapeenv_event</span><span class="p">(</span><span class="n">save_tracked_fakes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">defer_runtime_assert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orig_expr</span><span class="p">:</span> <span class="s2">&quot;sympy.Expr&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">fx_node</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">orig_expr</span>

        <span class="n">static_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_evaluate_static</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">static_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;runtime_assert </span><span class="si">%s</span><span class="s2"> == </span><span class="si">%s</span><span class="s2"> [statically known]&quot;</span><span class="p">,</span> <span class="n">orig_expr</span><span class="p">,</span> <span class="n">static_expr</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">static_expr</span>

        <span class="c1"># Attempt to eliminate the unbacked SymInt</span>
        <span class="n">new_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_evaluate_static</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">unbacked_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_expr</span><span class="o">.</span><span class="n">free_symbols</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_to_val</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># Do a normal guard</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_expr</span><span class="p">(</span><span class="n">new_expr</span><span class="p">,</span> <span class="n">fx_node</span><span class="o">=</span><span class="n">fx_node</span><span class="p">)</span>
        <span class="c1"># NB: Don&#39;t use new_expr as expr; it could contain gunk like shape0</span>
        <span class="c1"># which we don&#39;t want to guard on</span>

        <span class="c1"># OK, we&#39;re definitely doing a runtime assert now</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_translation_validation_enabled</span>
            <span class="ow">and</span> <span class="n">fx_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_suppress_guards_tls</span><span class="p">()</span>
        <span class="p">):</span>
            <span class="n">node</span><span class="p">,</span> <span class="n">fresh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_fx_call_function</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">_assert</span><span class="p">,</span> <span class="p">(</span><span class="n">fx_node</span><span class="p">,))</span>
            <span class="k">assert</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">fresh</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_fx_node_metadata</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_frozen</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">true</span><span class="p">)</span>

        <span class="c1"># eliminate symbols on equality tests</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Eq</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_guard_eq</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_suppress_guards_tls</span><span class="p">():</span>
            <span class="c1"># canonicalise to remove equations that are trivially equal</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">canonicalize_bool_expr</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="n">CapturedTraceback</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">skip</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">ra</span> <span class="o">=</span> <span class="n">RuntimeAssert</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">stack</span><span class="p">)</span>
            <span class="c1"># TODO: Do this in a way that is less janky than int(s.name[1:])</span>
            <span class="n">cands</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">free_symbols</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;u&quot;</span><span class="p">)],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deferred_runtime_asserts</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">cands</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ra</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_deferred_runtime_asserts</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_version_counter</span><span class="p">()</span>
            <span class="c1"># TODO: refine ranges</span>
            <span class="c1"># Unfortunately, range refinement is probably going to not</span>
            <span class="c1"># work most of the time, because we don&#39;t support symbols</span>
            <span class="c1"># in ranges.  For example, i0 &lt;= s0 is un-rangeable, because</span>
            <span class="c1"># we can&#39;t put s0 in the range.  So this is not very high</span>
            <span class="c1"># priority at the moment.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log_guard</span><span class="p">(</span><span class="s2">&quot;runtime_assert&quot;</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;runtime_assert </span><span class="si">%s</span><span class="s2"> [guard suppressed]&quot;</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="c1"># Refines the ranges of the variables present in &#39;guard&#39;.</span>
    <span class="c1">#</span>
    <span class="c1"># This function tries to refine the range of the variables inside</span>
    <span class="c1"># &#39;guard&#39; by reasoning about it. Specifically, when &#39;guard&#39; is a</span>
    <span class="c1"># &#39;sympy.Relational&#39; operation.</span>
    <span class="c1">#</span>
    <span class="c1"># It does mainly 3 things:</span>
    <span class="c1">#   1. Tries to isolate a variable in the left-hand side</span>
    <span class="c1">#   2. Compute the value range of the right-hand side</span>
    <span class="c1">#   3. Update the value range of the variable, if better</span>
    <span class="k">def</span> <span class="nf">refine_ranges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">guard</span><span class="p">:</span> <span class="n">ShapeGuard</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">guard</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Symbol</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_to_val</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">SingletonInt</span><span class="p">):</span>
                <span class="c1"># Skip var_to_range logic for SingletonInt which is only used</span>
                <span class="c1"># for jagged layout NestedTensors today</span>
                <span class="k">continue</span>

            <span class="n">r</span> <span class="o">=</span> <span class="n">try_solve</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">symbol</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="p">(</span><span class="n">symbol</span><span class="o">.</span><span class="n">is_integer</span> <span class="ow">and</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_integer</span><span class="p">):</span>
                <span class="c1"># Range refinement only supports integer symbols for now.</span>
                <span class="c1"># There are lots of SymPy bugs when it comes to comparing</span>
                <span class="c1"># reals and integers, so we skip that for now.</span>
                <span class="k">continue</span>

            <span class="n">r_expr</span><span class="p">,</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">r</span>
            <span class="n">vr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_to_range</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span>
            <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">vr</span><span class="o">.</span><span class="n">lower</span><span class="p">,</span> <span class="n">vr</span><span class="o">.</span><span class="n">upper</span>

            <span class="n">rhs_vr</span> <span class="o">=</span> <span class="n">bound_sympy</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_to_range</span><span class="p">)</span>
            <span class="n">_assert_bound_is_rational</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">rhs_vr</span><span class="p">)</span>
            <span class="n">lower_guard</span><span class="p">,</span> <span class="n">upper_guard</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_to_guards</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

            <span class="c1"># Let&#39;s suppose that we have a preexisting range for x [0, 100].</span>
            <span class="c1"># Now, we issue a guard x &gt; y, where the range for y is [50, 150].</span>
            <span class="c1"># Then, lower = 0, rhs_vr.lower = 50 and therefore refinement can happen,</span>
            <span class="c1"># refining x to [51, 100], since x must be greater than y, but the lowest</span>
            <span class="c1"># y could be is 50.</span>
            <span class="c1">#</span>
            <span class="c1"># sympy.Eq may update both lower and upper bounds.</span>
            <span class="c1"># sympy.G{t,e} may update the lower bound, only.</span>
            <span class="c1"># sympy.L{t,e} may update the upper bound, only.</span>
            <span class="k">if</span> <span class="n">lower</span> <span class="o">&lt;</span> <span class="n">rhs_vr</span><span class="o">.</span><span class="n">lower</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r_expr</span><span class="p">,</span> <span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">Eq</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Ge</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Gt</span><span class="p">)):</span>
                <span class="c1"># Strictly greater relations allow us to refine a bit more, since</span>
                <span class="c1"># x &lt; y implies that the lower bound for x is: y + 1.</span>
                <span class="n">lower</span> <span class="o">=</span> <span class="n">rhs_vr</span><span class="o">.</span><span class="n">lower</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">r_expr</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Gt</span><span class="p">))</span>
                <span class="n">lower_guard</span> <span class="o">=</span> <span class="n">guard</span>
            <span class="k">if</span> <span class="n">upper</span> <span class="o">&gt;</span> <span class="n">rhs_vr</span><span class="o">.</span><span class="n">upper</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r_expr</span><span class="p">,</span> <span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">Eq</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Le</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Lt</span><span class="p">)):</span>
                <span class="n">upper</span> <span class="o">=</span> <span class="n">rhs_vr</span><span class="o">.</span><span class="n">upper</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">r_expr</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Lt</span><span class="p">))</span>
                <span class="n">upper_guard</span> <span class="o">=</span> <span class="n">guard</span>

            <span class="c1"># Do nothing if the new value range is no better than what we already have.</span>
            <span class="k">if</span> <span class="n">vr</span> <span class="o">==</span> <span class="n">ValueRanges</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1"># Updates the range and the guards corresponding to each bound of the symbol.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">var_to_range</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span> <span class="o">=</span> <span class="n">ValueRanges</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">var_to_guards</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">lower_guard</span><span class="p">,</span> <span class="n">upper_guard</span><span class="p">)</span>
            <span class="c1"># Clears the cache, since this update can change the result.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_evaluate_static</span><span class="o">.</span><span class="n">cache_clear</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">_is_int</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">SymInt</span><span class="p">)</span> <span class="ow">and</span> <span class="n">expr</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">is_number</span>

<span class="c1"># WARNING: This is legacy, DO NOT USE</span>
<span class="k">def</span> <span class="nf">_is_dim_dynamic</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;_dynamo_dynamic_indices&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">_dynamo_dynamic_indices</span>
</pre></div>

             </article>
             
            </div>
            <footer>
  

  

    <hr>

  

  <div role="contentinfo">
    <p>
        &copy; Copyright 2023, PyTorch Contributors.

    </p>
  </div>
    
      <div>
        Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
      </div>
     

</footer>

          </div>
<script>

var match = window.location.href.match(/\/_[a-zA-Z0-9_]*.html|_dynamo/gi);
var url = window.location.href.lastIndexOf(match[match.length-1]);

if (url)
  {
    var div = '<div class="admonition note"><p class="admonition-title">Note</p><p><i class="fa fa-exclamation-circle" aria-hidden="true">&nbsp</i> This page describes an internal API which is not intended to be used outside of the PyTorch codebase and can be modified or removed without notice.</p></div>'
    document.getElementById("pytorch-article").insertAdjacentHTML('afterBegin', div)
  }
</script>
        </div>

        <div class="pytorch-content-right" id="pytorch-content-right">
          <div class="pytorch-right-menu" id="pytorch-right-menu">
            <div class="pytorch-side-scroll" id="pytorch-side-scroll-right">
              
            </div>
          </div>
        </div>
      </section>
    </div>

  


  

     
       <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
         <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
         <script src="../../../../_static/jquery.js"></script>
         <script src="../../../../_static/underscore.js"></script>
         <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
         <script src="../../../../_static/doctools.js"></script>
         <script src="../../../../_static/sphinx_highlight.js"></script>
         <script src="../../../../_static/clipboard.min.js"></script>
         <script src="../../../../_static/copybutton.js"></script>
     

  

  <script type="text/javascript" src="../../../../_static/js/vendor/popper.min.js"></script>
  <script type="text/javascript" src="../../../../_static/js/vendor/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/list.js/1.5.0/list.min.js"></script>
  <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 
<script script type="text/javascript">
  var collapsedSections = ['Developer Notes', 'Language Bindings', 'Libraries', 'Community'];
</script>

<img height="1" width="1" style="border-style:none;" alt="" src="https://www.googleadservices.com/pagead/conversion/795629140/?label=txkmCPmdtosBENSssfsC&amp;guid=ON&amp;script=0"/>


  <!-- Begin Footer -->

  <div class="container-fluid docs-tutorials-resources" id="docs-tutorials-resources">
    <div class="container">
      <div class="row">
        <div class="col-md-4 text-center">
          <h2>Docs</h2>
          <p>Access comprehensive developer documentation for PyTorch</p>
          <a class="with-right-arrow" href="https://pytorch.org/docs/stable/index.html">View Docs</a>
        </div>

        <div class="col-md-4 text-center">
          <h2>Tutorials</h2>
          <p>Get in-depth tutorials for beginners and advanced developers</p>
          <a class="with-right-arrow" href="https://pytorch.org/tutorials">View Tutorials</a>
        </div>

        <div class="col-md-4 text-center">
          <h2>Resources</h2>
          <p>Find development resources and get your questions answered</p>
          <a class="with-right-arrow" href="https://pytorch.org/resources">View Resources</a>
        </div>
      </div>
    </div>
  </div>

  <footer class="site-footer">
    <div class="container footer-container">
      <div class="footer-logo-wrapper">
        <a href="https://pytorch.org/" class="footer-logo"></a>
      </div>

      <div class="footer-links-wrapper">
        <div class="footer-links-col">
          <ul>
            <li class="list-title"><a href="https://pytorch.org/">PyTorch</a></li>
            <li><a href="https://pytorch.org/get-started">Get Started</a></li>
            <li><a href="https://pytorch.org/features">Features</a></li>
            <li><a href="https://pytorch.org/ecosystem">Ecosystem</a></li>
            <li><a href="https://pytorch.org/blog/">Blog</a></li>
            <li><a href="https://github.com/pytorch/pytorch/blob/master/CONTRIBUTING.md">Contributing</a></li>
          </ul>
        </div>

        <div class="footer-links-col">
          <ul>
            <li class="list-title"><a href="https://pytorch.org/resources">Resources</a></li>
            <li><a href="https://pytorch.org/tutorials">Tutorials</a></li>
            <li><a href="https://pytorch.org/docs/stable/index.html">Docs</a></li>
            <li><a href="https://discuss.pytorch.org" target="_blank">Discuss</a></li>
            <li><a href="https://github.com/pytorch/pytorch/issues" target="_blank">Github Issues</a></li>
            <li><a href="https://pytorch.org/assets/brand-guidelines/PyTorch-Brand-Guidelines.pdf" target="_blank">Brand Guidelines</a></li>
          </ul>
        </div>

        <div class="footer-links-col">
          <ul>
            <li class="list-title">Stay up to date</li>
            <li><a href="https://www.facebook.com/pytorch" target="_blank">Facebook</a></li>
            <li><a href="https://twitter.com/pytorch" target="_blank">Twitter</a></li>
            <li><a href="https://www.youtube.com/pytorch" target="_blank">YouTube</a></li>
            <li><a href="https://www.linkedin.com/company/pytorch" target="_blank">LinkedIn</a></li>
          </ul>  
          </div>

        <div class="footer-links-col">
          <ul>
            <li class="list-title">PyTorch Podcasts</li>
            <li><a href="https://open.spotify.com/show/6UzHKeiy368jKfQMKKvJY5" target="_blank">Spotify</a></li>
            <li><a href="https://podcasts.apple.com/us/podcast/pytorch-developer-podcast/id1566080008" target="_blank">Apple</a></li>
            <li><a href="https://www.google.com/podcasts?feed=aHR0cHM6Ly9mZWVkcy5zaW1wbGVjYXN0LmNvbS9PQjVGa0lsOA%3D%3D" target="_blank">Google</a></li>
            <li><a href="https://music.amazon.com/podcasts/7a4e6f0e-26c2-49e9-a478-41bd244197d0/PyTorch-Developer-Podcast?" target="_blank">Amazon</a></li>
          </ul>
         </div>
        </div>
        
        <div class="privacy-policy">
          <ul>
            <li class="privacy-policy-links"><a href="https://www.linuxfoundation.org/terms/" target="_blank">Terms</a></li>
            <li class="privacy-policy-links">|</li>
            <li class="privacy-policy-links"><a href="https://www.linuxfoundation.org/privacy-policy/" target="_blank">Privacy</a></li>
          </ul>
        </div>
        <div class="copyright">
        <p>Â© Copyright The Linux Foundation. The PyTorch Foundation is a project of The Linux Foundation.
          For web site terms of use, trademark policy and other policies applicable to The PyTorch Foundation please see
          <a href="https://www.linuxfoundation.org/policies/">www.linuxfoundation.org/policies/</a>. The PyTorch Foundation supports the PyTorch open source
          project, which has been established as PyTorch Project a Series of LF Projects, LLC. For policies applicable to the PyTorch Project a Series of LF Projects, LLC,
          please see <a href="https://www.lfprojects.org/policies/">www.lfprojects.org/policies/</a>.</p>
      </div>
     </div>

  </footer>

  <div class="cookie-banner-wrapper">
  <div class="container">
    <p class="gdpr-notice">To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or navigating, you agree to allow our usage of cookies. As the current maintainers of this site, Facebookâ€™s Cookies Policy applies. Learn more, including about available controls: <a href="https://www.facebook.com/policies/cookies/">Cookies Policy</a>.</p>
    <img class="close-button" src="../../../../_static/images/pytorch-x.svg">
  </div>
</div>

  <!-- End Footer -->

  <!-- Begin Mobile Menu -->

  <div class="mobile-main-menu">
    <div class="container-fluid">
      <div class="container">
        <div class="mobile-main-menu-header-container">
          <a class="header-logo" href="https://pytorch.org/" aria-label="PyTorch"></a>
          <a class="main-menu-close-button" href="#" data-behavior="close-mobile-menu"></a>
        </div>
      </div>
    </div>

    <div class="mobile-main-menu-links-container">
      <div class="main-menu">
        <ul>
          <li>
            <a href="https://pytorch.org/get-started">Get Started</a>
          </li>

          <li>
            <a href="https://pytorch.org/ecosystem">Ecosystem</a>
          </li>
            
          <li>
            <a href="">Mobile</a>
          </li>

          <li>
            <a href="https://pytorch.org/blog/">Blog</a>
          </li>

          <li>
            <a href="https://pytorch.org/tutorials">Tutorials</a>
          </li>

          <li class="resources-mobile-menu-title" class="active">
            Docs
          </li>

          <ul class="resources-mobile-menu-items">
            <li>
              <a href="https://pytorch.org/docs/stable/index.html">PyTorch</a>
            </li>

            <li>
              <a href="https://pytorch.org/audio/stable/index.html">torchaudio</a>
            </li>

            <li>
              <a href="https://pytorch.org/text/stable/index.html">torchtext</a>
            </li>

            <li>
              <a href="https://pytorch.org/vision/stable/index.html">torchvision</a>
            </li>

            <li>
              <a href="https://pytorch.org/torcharrow">torcharrow</a>
            </li>

            <li>
              <a href="https://pytorch.org/data">TorchData</a>
            </li>

            <li>
              <a href="https://pytorch.org/torchrec">TorchRec</a>
            </li>

            <li>
              <a href="https://pytorch.org/serve/">TorchServe</a>
            </li>

            <li>
              <a href="https://pytorch.org/torchx/">TorchX</a>
            </li>

            <li>
              <a href="https://pytorch.org/xla">PyTorch on XLA Devices</a>
            </li>
          </ul>

          <li class="resources-mobile-menu-title">
            Resources
          </li>
            
           <ul class="resources-mobile-menu-items">

            <li>
              <a href="https://pytorch.org/features">About</a>
            </li>

            <li>
              <a href="https://pytorch.org/foundation">PyTorch Foundation</a>
            </li>

            <li>
              <a href="https://pytorch.org/#community-module">Community</a>
            </li>

            <li>
              <a href="https://pytorch.org/community-stories">Community Stories</a>
            </li>

            <li>
              <a href="https://pytorch.org/resources">Developer Resources</a>
            </li>

            <li>
              <a href="https://pytorch.org/events">Events</a>
            </li>

            <li>
              <a href="https://discuss.pytorch.org/">Forums</a>
            </li>

            <li>
              <a href="https://pytorch.org/hub">Models (Beta)</a>
            </li>
          </ul>

          <li>
            <a href="https://github.com/pytorch/pytorch">Github</a>
          </li>
        </ul>
      </div>
    </div>
  </div>

  <!-- End Mobile Menu -->

  <script type="text/javascript" src="../../../../_static/js/vendor/anchor.min.js"></script>

  <script type="text/javascript">
    $(document).ready(function() {
      mobileMenu.bind();
      mobileTOC.bind();
      pytorchAnchors.bind();
      sideMenus.bind();
      scrollToAnchor.bind();
      highlightNavigation.bind();
      mainMenuDropdown.bind();
      filterTags.bind();

      // Add class to links that have code blocks, since we cannot create links in code blocks
      $("article.pytorch-article a span.pre").each(function(e) {
        $(this).closest("a").addClass("has-code");
      });
    })
  </script>
</body>
</html>