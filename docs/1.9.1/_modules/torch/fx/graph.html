


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta name="robots" content="noindex">
  <meta name="robots" content="noindex">
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>torch.fx.graph &mdash; PyTorch 1.9.1 documentation</title>
  

  
  
  
  
    <link rel="canonical" href="https://pytorch.org/docs/stable/_modules/torch/fx/graph.html"/>
  

  

  
  
    

  

  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!-- <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" /> -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-beta/dist/katex.min.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/jit.css" type="text/css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/katex-math.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <!-- Google Analytics -->
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117752657-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-117752657-2');
    </script>
  
  <!-- End Google Analytics -->
  

  
  <script src="../../../_static/js/modernizr.min.js"></script>

  <!-- Preload the theme fonts -->

<link rel="preload" href="../../../_static/fonts/FreightSans/freight-sans-book.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../_static/fonts/FreightSans/freight-sans-medium.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../_static/fonts/IBMPlexMono/IBMPlexMono-Medium.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../_static/fonts/FreightSans/freight-sans-bold.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../_static/fonts/FreightSans/freight-sans-medium-italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../_static/fonts/IBMPlexMono/IBMPlexMono-SemiBold.woff2" as="font" type="font/woff2" crossorigin="anonymous">

<!-- Preload the katex fonts -->

<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Math-Italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Main-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Main-Bold.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size1-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size4-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size2-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size3-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Caligraphic-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css" integrity="sha384-vSIIfh2YWi9wW0r9iZe7RJPrKwp6bG+s9QZMoITbCckVJqGCCRhc+ccxNcdpHuYu" crossorigin="anonymous">
</head>

<div class="container-fluid header-holder tutorials-header" id="header-holder">
  <div class="container">
    <div class="header-container">
      <a class="header-logo" href="https://pytorch.org/" aria-label="PyTorch"></a>

      <div class="main-menu">
        <ul>
          <li>
            <a href="https://pytorch.org/get-started">Get Started</a>
          </li>

          <li>
            <a href="https://pytorch.org/ecosystem">Ecosystem</a>
          </li>

          <li>
            <a href="https://pytorch.org/mobile">Mobile</a>
          </li>

          <li>
            <a href="https://pytorch.org/blog/">Blog</a>
          </li>

          <li>
            <a href="https://pytorch.org/tutorials">Tutorials</a>
          </li>

          <li class="active docs-active">
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="resource-option with-down-orange-arrow">
                Docs
              </a>
              <div class="resources-dropdown-menu">
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/docs/stable/index.html">
                  <span class="dropdown-title">PyTorch</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/audio/stable/index.html">
                  <span class="dropdown-title">torchaudio</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/text/stable/index.html">
                  <span class="dropdown-title">torchtext</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/vision/stable/index.html">
                  <span class="dropdown-title">torchvision</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/elastic/">
                  <span class="dropdown-title">TorchElastic</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/serve/">
                  <span class="dropdown-title">TorchServe</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://pytorch.org/xla">
                  <span class="dropdown-title">PyTorch on XLA Devices</span>
                  <p></p>
                </a>
            </div>
          </li>

          <li>
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="resource-option with-down-arrow">
                Resources
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="https://pytorch.org/features">
                  <span class="dropdown-title">About</span>
                  <p>Learn about PyTorchâ€™s features and capabilities</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/#community-module">
                  <span class="dropdown-title">Community</span>
                  <p>Join the PyTorch developer community to contribute, learn, and get your questions answered.</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/resources">
                  <span class="dropdown-title">Developer Resources</span>
                  <p>Find resources and get questions answered</p>
                </a>
                <a class="nav-dropdown-item" href="https://discuss.pytorch.org/" target="_blank">
                  <span class="dropdown-title">Forums</span>
                  <p>A place to discuss PyTorch code, issues, install, research</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/hub">
                  <span class="dropdown-title">Models (Beta)</span>
                  <p>Discover, publish, and reuse pre-trained models</p>
                </a>
              </div>
            </div>
          </li>

          <li>
            <a href="https://github.com/pytorch/pytorch">GitHub</a>
          </li>
        </ul>
      </div>

      <a class="main-menu-open-button" href="#" data-behavior="open-mobile-menu"></a>
    </div>
  </div>
</div>

<body class="pytorch-body">

   

    

    <div class="table-of-contents-link-wrapper">
      <span>Table of Contents</span>
      <a href="#" class="toggle-table-of-contents" data-behavior="toggle-table-of-contents"></a>
    </div>

    <nav data-toggle="wy-nav-shift" class="pytorch-left-menu" id="pytorch-left-menu">
      <div class="pytorch-side-scroll">
        <div class="pytorch-menu pytorch-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          <div class="pytorch-left-menu-search">
            
    <div class="version">
      <a href='https://pytorch.org/docs/versions.html'>1.9.1 &#x25BC</a>
    </div>
    


  


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search Docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          </div>

          


            
            
              
            
            
              <p class="caption"><span class="caption-text">Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../notes/amp_examples.html">Automatic Mixed Precision examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notes/autograd.html">Autograd mechanics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notes/broadcasting.html">Broadcasting semantics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notes/cpu_threading_torchscript_inference.html">CPU threading and TorchScript inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notes/cuda.html">CUDA semantics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notes/ddp.html">Distributed Data Parallel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notes/extending.html">Extending PyTorch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notes/faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notes/gradcheck.html">Gradcheck mechanics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notes/hip.html">HIP (ROCm) semantics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notes/large_scale_deployments.html">Features for large-scale deployments</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notes/modules.html">Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notes/multiprocessing.html">Multiprocessing best practices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notes/randomness.html">Reproducibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notes/serialization.html">Serialization semantics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notes/windows.html">Windows FAQ</a></li>
</ul>
<p class="caption"><span class="caption-text">Language Bindings</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../cpp_index.html">C++</a></li>
<li class="toctree-l1"><a class="reference external" href="https://pytorch.org/javadoc/">Javadoc</a></li>
</ul>
<p class="caption"><span class="caption-text">Python API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../torch.html">torch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../nn.html">torch.nn</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../nn.functional.html">torch.nn.functional</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tensors.html">torch.Tensor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tensor_attributes.html">Tensor Attributes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tensor_view.html">Tensor Views</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../autograd.html">torch.autograd</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cuda.html">torch.cuda</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../amp.html">torch.cuda.amp</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../backends.html">torch.backends</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../distributed.html">torch.distributed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../distributed.elastic.html">torch.distributed.elastic</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../distributed.optim.html">torch.distributed.optim</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../distributions.html">torch.distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../fft.html">torch.fft</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../futures.html">torch.futures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../fx.html">torch.fx</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../hub.html">torch.hub</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../jit.html">torch.jit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../linalg.html">torch.linalg</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../special.html">torch.special</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../torch.overrides.html">torch.overrides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../package.html">torch.package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../profiler.html">torch.profiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../nn.init.html">torch.nn.init</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../onnx.html">torch.onnx</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../optim.html">torch.optim</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../complex_numbers.html">Complex Numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ddp_comm_hooks.html">DDP Communication Hooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../pipeline.html">Pipeline Parallelism</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quantization.html">Quantization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rpc.html">Distributed RPC Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../random.html">torch.random</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sparse.html">torch.sparse</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../storage.html">torch.Storage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../testing.html">torch.testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../benchmark_utils.html">torch.utils.benchmark</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bottleneck.html">torch.utils.bottleneck</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../checkpoint.html">torch.utils.checkpoint</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cpp_extension.html">torch.utils.cpp_extension</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../data.html">torch.utils.data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dlpack.html">torch.utils.dlpack</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mobile_optimizer.html">torch.utils.mobile_optimizer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../model_zoo.html">torch.utils.model_zoo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tensorboard.html">torch.utils.tensorboard</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../type_info.html">Type Info</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../named_tensor.html">Named Tensors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../name_inference.html">Named Tensors operator coverage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../__config__.html">torch.__config__</a></li>
</ul>
<p class="caption"><span class="caption-text">Libraries</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://pytorch.org/audio/stable">torchaudio</a></li>
<li class="toctree-l1"><a class="reference external" href="https://pytorch.org/text/stable">torchtext</a></li>
<li class="toctree-l1"><a class="reference external" href="https://pytorch.org/vision/stable">torchvision</a></li>
<li class="toctree-l1"><a class="reference external" href="https://pytorch.org/serve">TorchServe</a></li>
<li class="toctree-l1"><a class="reference external" href="http://pytorch.org/xla/">PyTorch on XLA Devices</a></li>
</ul>
<p class="caption"><span class="caption-text">Community</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../community/contribution_guide.html">PyTorch Contribution Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../community/governance.html">PyTorch Governance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../community/persons_of_interest.html">PyTorch Governance | Persons of Interest</a></li>
</ul>

            
          

        </div>
      </div>
    </nav>

    <div class="pytorch-container">
      <div class="pytorch-page-level-bar" id="pytorch-page-level-bar">
        <div class="pytorch-breadcrumbs-wrapper">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="pytorch-breadcrumbs">
    
      <li>
        <a href="../../../index.html">
          
            Docs
          
        </a> &gt;
      </li>

        
          <li><a href="../../index.html">Module code</a> &gt;</li>
        
          <li><a href="../../torch.html">torch</a> &gt;</li>
        
      <li>torch.fx.graph</li>
    
    
      <li class="pytorch-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
</div>
        </div>

        <div class="pytorch-shortcuts-wrapper" id="pytorch-shortcuts-wrapper">
          Shortcuts
        </div>
      </div>

      <section data-toggle="wy-nav-shift" id="pytorch-content-wrap" class="pytorch-content-wrap">
        <div class="pytorch-content-left">

        
          
          <div class="rst-content">
          
            <div role="main" class="main-content" itemscope="itemscope" itemtype="http://schema.org/Article">
             <article itemprop="articleBody" id="pytorch-article" class="pytorch-article">
              
  <h1>Source code for torch.fx.graph</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">.node</span> <span class="kn">import</span> <span class="n">Node</span><span class="p">,</span> <span class="n">Argument</span><span class="p">,</span> <span class="n">Target</span><span class="p">,</span> <span class="n">map_arg</span><span class="p">,</span> <span class="n">_type_repr</span><span class="p">,</span> <span class="n">_get_qualified_name</span>
<span class="kn">import</span> <span class="nn">torch.utils._pytree</span> <span class="k">as</span> <span class="nn">pytree</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_pytree</span> <span class="k">as</span> <span class="n">fx_pytree</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">NamedTuple</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">FrozenSet</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">keyword</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">builtins</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">warnings</span>


<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">.graph_module</span> <span class="kn">import</span> <span class="n">GraphModule</span>


<span class="c1"># Mapping of builtins to their `typing` equivalent.</span>
<span class="n">_origin_type_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nb">list</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span>
    <span class="nb">dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
    <span class="nb">set</span><span class="p">:</span> <span class="n">Set</span><span class="p">,</span>
    <span class="nb">frozenset</span><span class="p">:</span> <span class="n">FrozenSet</span><span class="p">,</span>
    <span class="nb">tuple</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">_CustomBuiltin</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Additional objs that we add to every graph&#39;s globals.</span>

<span class="sd">    The repr() for some standard library objects is not valid Python code without</span>
<span class="sd">    an import. For common objects of this sort, we bundle them in the globals of</span>
<span class="sd">    every FX graph.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># How to import this object from the standard library.</span>
    <span class="n">import_str</span><span class="p">:</span> <span class="nb">str</span>
    <span class="c1"># The actual object, produced from that import string.</span>
    <span class="n">obj</span><span class="p">:</span> <span class="n">Any</span>

<span class="n">_custom_builtins</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">_CustomBuiltin</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>


<span class="k">def</span> <span class="nf">_register_custom_builtin</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">import_str</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
    <span class="n">_custom_builtins</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">_CustomBuiltin</span><span class="p">(</span><span class="n">import_str</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>


<span class="n">_register_custom_builtin</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">,</span> <span class="s1">&#39;from math import inf&#39;</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="n">_register_custom_builtin</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">,</span> <span class="s1">&#39;from math import nan&#39;</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
<span class="n">_register_custom_builtin</span><span class="p">(</span><span class="s1">&#39;NoneType&#39;</span><span class="p">,</span> <span class="s1">&#39;NoneType = type(None)&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
<span class="n">_register_custom_builtin</span><span class="p">(</span><span class="s1">&#39;torch&#39;</span><span class="p">,</span> <span class="s1">&#39;import torch&#39;</span><span class="p">,</span> <span class="n">torch</span><span class="p">)</span>
<span class="n">_register_custom_builtin</span><span class="p">(</span><span class="s1">&#39;device&#39;</span><span class="p">,</span> <span class="s1">&#39;from torch import device&#39;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
<span class="n">_register_custom_builtin</span><span class="p">(</span><span class="s1">&#39;fx_pytree&#39;</span><span class="p">,</span> <span class="s1">&#39;import torch.fx._pytree as fx_pytree&#39;</span><span class="p">,</span> <span class="n">fx_pytree</span><span class="p">)</span>
<span class="n">_register_custom_builtin</span><span class="p">(</span><span class="s1">&#39;pytree&#39;</span><span class="p">,</span> <span class="s1">&#39;import torch.utils._pytree as pytree&#39;</span><span class="p">,</span> <span class="n">pytree</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_is_magic</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_snake_case</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transforms the given string ``s`` to a Python-style variable name</span>

<span class="sd">    Examples:</span>
<span class="sd">        ``mod.snake_case`` -&gt; ``mod.snake_case``</span>
<span class="sd">        ``mod.pascalCase``-&gt; ``mod.pascal_case``</span>
<span class="sd">        ``mod.ALL_CAPS`` -&gt; ``mod.all_caps``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">chars</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">prev_lower</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">prev_lower</span> <span class="ow">and</span> <span class="n">c</span><span class="o">.</span><span class="n">isupper</span><span class="p">():</span>
            <span class="n">chars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
        <span class="n">chars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
        <span class="n">prev_lower</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">islower</span><span class="p">()</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chars</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_is_from_torch</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="n">module_name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__module__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">module_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">base_module</span> <span class="o">=</span> <span class="n">module_name</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">base_module</span> <span class="o">==</span> <span class="s1">&#39;torch&#39;</span>

    <span class="n">name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="c1"># exclude torch because torch.torch.torch.torch works. idk mang</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;torch&#39;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">guess</span> <span class="ow">in</span> <span class="p">[</span><span class="n">torch</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="p">]:</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">guess</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="n">obj</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="kc">False</span>


<span class="k">class</span> <span class="nc">_Namespace</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A context for associating names uniquely with objects.</span>

<span class="sd">    The following invariants are enforced:</span>
<span class="sd">    - Each object gets a single name.</span>
<span class="sd">    - Each name is unique within a given namespace.</span>
<span class="sd">    - Names generated do not shadow builtins, unless the object is indeed that builtin.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_obj_to_name</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unassociated_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_used_names</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_illegal_char_regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;[^0-9a-zA-Z_]+&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name_suffix_regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(.*)_(\d+)$&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">create_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">candidate</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create a unique name.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            candidate: used as the basis for the unique name, relevant to the user.</span>
<span class="sd">            obj: If not None, an object that will be associated with the unique name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj_to_name</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj_to_name</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span>

        <span class="c1"># delete all characters that are illegal in a Python identifier</span>
        <span class="n">candidate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_illegal_char_regex</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">candidate</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">candidate</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="n">candidate</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;_</span><span class="si">{</span><span class="n">candidate</span><span class="si">}</span><span class="s1">&#39;</span>

        <span class="n">match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name_suffix_regex</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">candidate</span>
            <span class="n">num</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">base</span><span class="p">,</span> <span class="n">num_str</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num_str</span><span class="p">)</span>

        <span class="n">candidate</span> <span class="o">=</span> <span class="n">base</span> <span class="k">if</span> <span class="n">num</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">base</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">num</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="k">if</span> <span class="n">num</span> <span class="k">else</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_used_names</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_illegal_name</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
            <span class="n">num</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">candidate</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">base</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">num</span><span class="si">}</span><span class="s1">&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_used_names</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unassociated_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_obj_to_name</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span> <span class="o">=</span> <span class="n">candidate</span>
        <span class="k">return</span> <span class="n">candidate</span>

    <span class="k">def</span> <span class="nf">associate_name_with_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Associate a unique name with an object.</span>

<span class="sd">        Neither `name` nor `obj` should be associated already.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">obj</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj_to_name</span>
        <span class="k">assert</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unassociated_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_obj_to_name</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unassociated_names</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_is_illegal_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># 1. keywords are never allowed as names.</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">keyword</span><span class="o">.</span><span class="n">kwlist</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># 2. Can&#39;t shadow a builtin name, unless you *are* that builtin.</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">builtins</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">builtins</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

        <span class="c1"># 3. Can&#39;t shadow our custom builtins either</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">_custom_builtins</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_custom_builtins</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">obj</span>

        <span class="k">return</span> <span class="kc">False</span>


<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">PythonCode</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Represents all the information necessary to exec or save a graph as Python code.&quot;&quot;&quot;</span>
    <span class="c1"># Python source code for the forward function definition.</span>
    <span class="n">src</span><span class="p">:</span> <span class="nb">str</span>
    <span class="c1"># Values in global scope during exection of `src_def`.</span>
    <span class="nb">globals</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_format_args</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Argument</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Argument</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="n">args_s</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
    <span class="n">kwargs_s</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1"> = </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">args_s</span> <span class="ow">and</span> <span class="n">kwargs_s</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">args_s</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">kwargs_s</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="k">return</span> <span class="n">args_s</span> <span class="ow">or</span> <span class="n">kwargs_s</span>

<span class="k">def</span> <span class="nf">_format_target</span><span class="p">(</span><span class="n">base</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="n">elems</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">base</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">elems</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">e</span><span class="o">.</span><span class="n">isidentifier</span><span class="p">():</span>
            <span class="n">r</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;getattr(</span><span class="si">{</span><span class="n">r</span><span class="si">}</span><span class="s1">, &quot;</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s1">&quot;)&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">r</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="k">return</span> <span class="n">r</span>

<span class="k">class</span> <span class="nc">_InsertPoint</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">new_insert</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">orig_insert</span><span class="p">,</span> <span class="n">graph</span><span class="o">.</span><span class="n">_insert</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">_insert</span><span class="p">,</span> <span class="n">new_insert</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">_insert</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orig_insert</span>

<span class="k">class</span> <span class="nc">_node_list</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span> <span class="s1">&#39;Graph&#39;</span><span class="p">,</span> <span class="n">direction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;_next&#39;</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">direction</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;_next&#39;</span><span class="p">,</span> <span class="s1">&#39;_prev&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">_len</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">root</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">_root</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">direction</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">cur</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">cur</span><span class="o">.</span><span class="n">_erased</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">cur</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">direction</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__reversed__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_node_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="s1">&#39;_next&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;_prev&#39;</span> <span class="k">else</span> <span class="s1">&#39;_prev&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">_PyTreeInfo</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Contains extra info stored when we&#39;re using Pytrees</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">orig_args</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="n">in_spec</span><span class="p">:</span> <span class="n">pytree</span><span class="o">.</span><span class="n">TreeSpec</span>
    <span class="n">out_spec</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pytree</span><span class="o">.</span><span class="n">TreeSpec</span><span class="p">]</span>

<div class="viewcode-block" id="Graph"><a class="viewcode-back" href="../../../fx.html#torch.fx.Graph">[docs]</a><span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ``Graph`` is the main data structure used in the FX Intermediate Representation.</span>
<span class="sd">    It consists of a series of ``Node`` s, each representing callsites (or other</span>
<span class="sd">    syntactic constructs). The list of ``Node`` s, taken together, constitute a</span>
<span class="sd">    valid Python function.</span>

<span class="sd">    For example, the following code</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import torch</span>
<span class="sd">        import torch.fx</span>

<span class="sd">        class MyModule(torch.nn.Module):</span>
<span class="sd">            def __init__(self):</span>
<span class="sd">                super().__init__()</span>
<span class="sd">                self.param = torch.nn.Parameter(torch.rand(3, 4))</span>
<span class="sd">                self.linear = torch.nn.Linear(4, 5)</span>

<span class="sd">            def forward(self, x):</span>
<span class="sd">                return torch.topk(torch.sum(self.linear(x + self.linear.weight).relu(), dim=-1), 3)</span>

<span class="sd">        m = MyModule()</span>
<span class="sd">        gm = torch.fx.symbolic_trace(m)</span>

<span class="sd">    Will produce the following Graph::</span>

<span class="sd">        print(gm.graph)</span>

<span class="sd">    .. code-block:: text</span>

<span class="sd">        graph(x):</span>
<span class="sd">            %linear_weight : [#users=1] = self.linear.weight</span>
<span class="sd">            %add_1 : [#users=1] = call_function[target=operator.add](args = (%x, %linear_weight), kwargs = {})</span>
<span class="sd">            %linear_1 : [#users=1] = call_module[target=linear](args = (%add_1,), kwargs = {})</span>
<span class="sd">            %relu_1 : [#users=1] = call_method[target=relu](args = (%linear_1,), kwargs = {})</span>
<span class="sd">            %sum_1 : [#users=1] = call_function[target=torch.sum](args = (%relu_1,), kwargs = {dim: -1})</span>
<span class="sd">            %topk_1 : [#users=1] = call_function[target=torch.topk](args = (%sum_1, 3), kwargs = {})</span>
<span class="sd">            return topk_1</span>

<span class="sd">    For the semantics of operations represented in the ``Graph``, please see :class:`Node`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Graph.__init__"><a class="viewcode-back" href="../../../fx.html#torch.fx.Graph.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">owning_module</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;GraphModule&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct an empty Graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_root</span> <span class="p">:</span> <span class="n">Node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;root&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="p">(),</span> <span class="p">{})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_used_names</span> <span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># base name -&gt; number</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_insert</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="o">.</span><span class="n">prepend</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_graph_namespace</span> <span class="o">=</span> <span class="n">_Namespace</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_owners</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_owning_module</span> <span class="o">=</span> <span class="n">owning_module</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pytree_info</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_PyTreeInfo</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">owning_module</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_owning_module</span>

    <span class="nd">@owning_module</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">owning_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mod</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;GraphModule&quot;</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">mod</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_owning_module</span> <span class="o">=</span> <span class="n">mod</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_owners</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_owners</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_node_list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the list of Nodes that constitute this Graph.</span>

<span class="sd">        Note that this ``Node`` list representation is a doubly-linked list. Mutations</span>
<span class="sd">        during iteration (e.g. delete a Node, add a Node) are safe.</span>

<span class="sd">        Returns:</span>

<span class="sd">            A doubly-linked list of Nodes. Note that ``reversed`` can be called on</span>
<span class="sd">            this list to switch iteration order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_node_list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="Graph.graph_copy"><a class="viewcode-back" href="../../../fx.html#torch.fx.Graph.graph_copy">[docs]</a>    <span class="k">def</span> <span class="nf">graph_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span> <span class="p">:</span> <span class="s1">&#39;Graph&#39;</span><span class="p">,</span> <span class="n">val_map</span> <span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Node</span><span class="p">,</span> <span class="n">Node</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;Optional[Argument]&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copy all nodes from a given graph into ``self``.</span>

<span class="sd">        Args:</span>

<span class="sd">            g (Graph): The source graph from which to copy Nodes.</span>

<span class="sd">            val_map (Dict[Node, Node]): a dictionary that will be populated with a mapping</span>
<span class="sd">                from nodes in ``g`` to nodes in ``self``. Note that ``val_map`` can be passed</span>
<span class="sd">                in with values in it already to override copying of certain values.</span>

<span class="sd">        Returns:</span>

<span class="sd">            The value in ``self`` that is now equivalent to the output value in ``g``,</span>
<span class="sd">            if ``g`` had an ``output`` node. ``None`` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">val_map</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;output&#39;</span><span class="p">:</span>
                <span class="n">rv</span> <span class="o">=</span> <span class="n">map_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">val_map</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
                <span class="k">return</span> <span class="n">rv</span>
            <span class="n">val_map</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_copy</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">n</span> <span class="p">:</span> <span class="n">val_map</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="k">return</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Graph&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Explicitly implement __deepcopy__ to prevent excessive recursion depth</span>
<span class="sd">        from the default implementation. This uses graph_copy to copy the nodes</span>
<span class="sd">        in an iterative way, rather than recursive. It also populates the</span>
<span class="sd">        memoization table to prevent unnecessary copies (e.g. references to</span>
<span class="sd">        nodes or other parts of the Graph from a custom GraphModule implementation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">memo</span> <span class="o">=</span> <span class="n">memo</span> <span class="k">if</span> <span class="n">memo</span> <span class="k">else</span> <span class="p">{}</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
        <span class="n">output_val</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">graph_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val_map</span><span class="o">=</span><span class="n">memo</span><span class="p">)</span>
        <span class="n">g</span><span class="o">.</span><span class="n">output</span><span class="p">(</span><span class="n">output_val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">g</span>

<div class="viewcode-block" id="Graph.create_node"><a class="viewcode-back" href="../../../fx.html#torch.fx.Graph.create_node">[docs]</a>    <span class="k">def</span> <span class="nf">create_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="s1">&#39;Target&#39;</span><span class="p">,</span>
                    <span class="n">args</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="s1">&#39;Argument&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;Argument&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">type_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a ``Node`` and add it to the ``Graph`` at the current insert-point.</span>
<span class="sd">        Note that the current insert-point can be set via :meth:`Graph.inserting_before`</span>
<span class="sd">        and :meth:`Graph.inserting_after`.</span>

<span class="sd">        Args:</span>
<span class="sd">            op (str): the opcode for this Node. One of &#39;call_function&#39;, &#39;call_method&#39;, &#39;get_attr&#39;,</span>
<span class="sd">                &#39;call_module&#39;, &#39;placeholder&#39;, or &#39;output&#39;. The semantics of these opcodes are</span>
<span class="sd">                described in the ``Graph`` docstring.</span>

<span class="sd">            args (Optional[Tuple[Argument, ...]]): is a tuple of arguments to this node.</span>

<span class="sd">            kwargs (Optional[Dict[str, Argument]]): the kwargs of this Node</span>

<span class="sd">            name (Optional[str]): an optional string name for the ``Node``.</span>
<span class="sd">                This will influence the name of the value assigned to in the</span>
<span class="sd">                Python generated code.</span>

<span class="sd">            type_expr (Optional[Any]): an optional type annotation representing the</span>
<span class="sd">                Python type the output of this node will have.</span>

<span class="sd">        Returns:</span>

<span class="sd">            The newly-created and inserted node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">op</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;call_function&#39;</span><span class="p">,</span> <span class="s1">&#39;call_method&#39;</span><span class="p">,</span> <span class="s1">&#39;get_attr&#39;</span><span class="p">,</span> <span class="s1">&#39;call_module&#39;</span><span class="p">,</span> <span class="s1">&#39;placeholder&#39;</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">()</span> <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">args</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">kwargs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">kwargs</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">),</span> <span class="s2">&quot;args must be a tuple&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span> <span class="s2">&quot;kwargs must be a dict&quot;</span>

        <span class="n">candidate</span> <span class="o">=</span> <span class="n">name</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_to_str</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graph_namespace</span><span class="o">.</span><span class="n">create_name</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">type_expr</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_graph_namespace</span><span class="o">.</span><span class="n">associate_name_with_obj</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_insert</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">n</span></div>

    <span class="k">def</span> <span class="nf">flatten_inps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">flat_args</span><span class="p">,</span> <span class="n">args_spec</span> <span class="o">=</span> <span class="n">pytree</span><span class="o">.</span><span class="n">tree_flatten</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">flat_args</span>

    <span class="k">def</span> <span class="nf">unflatten_outs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pytree_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">out</span><span class="p">]</span>
        <span class="k">assert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pytree_info</span><span class="o">.</span><span class="n">out_spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pytree</span><span class="o">.</span><span class="n">tree_unflatten</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pytree_info</span><span class="o">.</span><span class="n">out_spec</span><span class="p">)</span>

<div class="viewcode-block" id="Graph.erase_node"><a class="viewcode-back" href="../../../fx.html#torch.fx.Graph.erase_node">[docs]</a>    <span class="k">def</span> <span class="nf">erase_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_erase</span> <span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Erases a ``Node`` from the ``Graph``. Throws an exception if</span>
<span class="sd">        there are still users of that node in the ``Graph``.</span>

<span class="sd">        Args:</span>

<span class="sd">            to_erase (Node): The ``Node`` to erase from the ``Graph``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_erase</span><span class="o">.</span><span class="n">users</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Tried to erase Node </span><span class="si">{</span><span class="n">to_erase</span><span class="si">}</span><span class="s1"> but it still had </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">to_erase</span><span class="o">.</span><span class="n">users</span><span class="p">)</span><span class="si">}</span><span class="s1"> &#39;</span>
                               <span class="sa">f</span><span class="s1">&#39;users in the graph: </span><span class="si">{</span><span class="n">to_erase</span><span class="o">.</span><span class="n">users</span><span class="si">}</span><span class="s1">!&#39;</span><span class="p">)</span>

        <span class="n">to_erase</span><span class="o">.</span><span class="n">_remove_from_list</span><span class="p">()</span>
        <span class="n">to_erase</span><span class="o">.</span><span class="n">_erased</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># iterators may retain handles to erased nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="c1"># Null out this Node&#39;s argument nodes so that the Nodes referred to</span>
        <span class="c1"># can update their ``users`` accordingly</span>
        <span class="n">new_args</span> <span class="o">=</span> <span class="n">map_arg</span><span class="p">(</span><span class="n">to_erase</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_args</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
        <span class="n">to_erase</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">new_args</span>
        <span class="n">new_kwargs</span> <span class="o">=</span> <span class="n">map_arg</span><span class="p">(</span><span class="n">to_erase</span><span class="o">.</span><span class="n">kwargs</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_kwargs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
        <span class="n">to_erase</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">new_kwargs</span></div>

<div class="viewcode-block" id="Graph.inserting_before"><a class="viewcode-back" href="../../../fx.html#torch.fx.Graph.inserting_before">[docs]</a>    <span class="k">def</span> <span class="nf">inserting_before</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Node</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the point at which create_node and companion methods will insert into the graph.</span>
<span class="sd">        When used within a &#39;with&#39; statement, this will temporary set the insert point and</span>
<span class="sd">        then restore it when the with statement exits::</span>

<span class="sd">            with g.inserting_before(n):</span>
<span class="sd">                ... # inserting before node n</span>
<span class="sd">            ... # insert point restored to what it was previously</span>
<span class="sd">            g.inserting_before(n) #  set the insert point permanently</span>

<span class="sd">        Args:</span>
<span class="sd">            n (Optional[Node]): The node before which to insert. If None this will insert before</span>
<span class="sd">              the beginning of the entire graph.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A resource manager that will restore the insert point on ``__exit__``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inserting_after</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">n</span><span class="o">.</span><span class="n">graph</span> <span class="o">==</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Node to insert before is not in graph.&quot;</span>
        <span class="k">return</span> <span class="n">_InsertPoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">prepend</span><span class="p">)</span></div>

<div class="viewcode-block" id="Graph.inserting_after"><a class="viewcode-back" href="../../../fx.html#torch.fx.Graph.inserting_after">[docs]</a>    <span class="k">def</span> <span class="nf">inserting_after</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Node</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the point at which create_node and companion methods will insert into the graph.</span>
<span class="sd">        When used within a &#39;with&#39; statement, this will temporary set the insert point and</span>
<span class="sd">        then restore it when the with statement exits::</span>

<span class="sd">            with g.inserting_after(n):</span>
<span class="sd">                ... # inserting after node n</span>
<span class="sd">            ... # insert point restored to what it was previously</span>
<span class="sd">            g.inserting_after(n) #  set the insert point permanently</span>

<span class="sd">        Args:</span>
<span class="sd">            n (Optional[Node]): The node before which to insert. If None this will insert after</span>
<span class="sd">              the beginning of the entire graph.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A resource manager that will restore the insert point on ``__exit__``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inserting_before</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">n</span><span class="o">.</span><span class="n">graph</span> <span class="o">==</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Node to insert after is not in graph.&quot;</span>
        <span class="k">return</span> <span class="n">_InsertPoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">append</span><span class="p">)</span></div>

    <span class="c1"># sugar for create_node when you know the op</span>
<div class="viewcode-block" id="Graph.placeholder"><a class="viewcode-back" href="../../../fx.html#torch.fx.Graph.placeholder">[docs]</a>    <span class="k">def</span> <span class="nf">placeholder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">type_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert a ``placeholder`` node into the Graph. A ``placeholder`` represents</span>
<span class="sd">        a function input.</span>

<span class="sd">        Args:</span>

<span class="sd">            name (str): A name for the input value. This corresponds to the name</span>
<span class="sd">                of the positional argument to the function this ``Graph`` represents.</span>

<span class="sd">            type_expr (Optional[Any]): an optional type annotation representing the</span>
<span class="sd">                Python type the output of this node will have. This is needed in some</span>
<span class="sd">                cases for proper code generation (e.g. when the function is used</span>
<span class="sd">                subsequently in TorchScript compilation).</span>

<span class="sd">        .. note::</span>
<span class="sd">            The same insertion point and type expression rules apply for this method</span>
<span class="sd">            as ``Graph.create_node``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_node</span><span class="p">(</span><span class="s1">&#39;placeholder&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">type_expr</span><span class="o">=</span><span class="n">type_expr</span><span class="p">)</span></div>

<div class="viewcode-block" id="Graph.get_attr"><a class="viewcode-back" href="../../../fx.html#torch.fx.Graph.get_attr">[docs]</a>    <span class="k">def</span> <span class="nf">get_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qualified_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">type_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert a ``get_attr`` node into the Graph. A ``get_attr`` ``Node`` represents the</span>
<span class="sd">        fetch of an attribute from the ``Module`` hierarchy.</span>

<span class="sd">        Args:</span>

<span class="sd">            qualified_name (str): the fully-qualified name of the attribute to be retrieved.</span>
<span class="sd">                For example, if the traced Module has a submodule named ``foo``, which has a</span>
<span class="sd">                submodule named ``bar``, which has an attribute named ``baz``, the qualified</span>
<span class="sd">                name ``foo.bar.baz`` should be passed as ``qualified_name``.</span>

<span class="sd">            type_expr (Optional[Any]): an optional type annotation representing the</span>
<span class="sd">                Python type the output of this node will have.</span>


<span class="sd">        Returns:</span>

<span class="sd">            The newly-created and inserted ``get_attr`` node.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The same insertion point and type expression rules apply for this method</span>
<span class="sd">            as ``Graph.create_node``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_get_attr_reference_exists</span><span class="p">(</span><span class="n">mod</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">qualified_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="n">module_path</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">qualified_name</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>

            <span class="n">submod</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">]</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">get_submodule</span><span class="p">(</span><span class="n">module_path</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">submod</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">submod</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="n">res</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">submod</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Parameter</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">submod</span><span class="o">.</span><span class="n">_buffers</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">owning_module</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="n">_get_attr_reference_exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">owning_module</span><span class="p">,</span> <span class="n">qualified_name</span><span class="p">)):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Attempted to insert a get_attr Node with no &quot;</span>
                          <span class="s2">&quot;underlying reference in the owning &quot;</span>
                          <span class="s2">&quot;GraphModule! Call &quot;</span>
                          <span class="s2">&quot;GraphModule.add_submodule to add the &quot;</span>
                          <span class="s2">&quot;necessary submodule, &quot;</span>
                          <span class="s2">&quot;GraphModule.add_parameter to add the &quot;</span>
                          <span class="s2">&quot;necessary Parameter, or &quot;</span>
                          <span class="s2">&quot;nn.Module.register_buffer to add the &quot;</span>
                          <span class="s2">&quot;necessary buffer&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_node</span><span class="p">(</span><span class="s1">&#39;get_attr&#39;</span><span class="p">,</span> <span class="n">qualified_name</span><span class="p">,</span> <span class="n">type_expr</span><span class="o">=</span><span class="n">type_expr</span><span class="p">)</span></div>

<div class="viewcode-block" id="Graph.call_module"><a class="viewcode-back" href="../../../fx.html#torch.fx.Graph.call_module">[docs]</a>    <span class="k">def</span> <span class="nf">call_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">module_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                    <span class="n">args</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="s1">&#39;Argument&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;Argument&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">type_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert a ``call_module`` ``Node`` into the ``Graph``. A ``call_module`` node</span>
<span class="sd">        represents a call to the forward() function of a ``Module`` in the ``Module``</span>
<span class="sd">        hierarchy.</span>

<span class="sd">        Args:</span>

<span class="sd">            module_name (str): The qualified name of the ``Module`` in the ``Module``</span>
<span class="sd">                hierarchy to be called. For example, if the traced ``Module`` has a</span>
<span class="sd">                submodule named ``foo``, which has a submodule named ``bar``, the</span>
<span class="sd">                qualified name ``foo.bar`` should be passed as ``module_name`` to</span>
<span class="sd">                call that module.</span>

<span class="sd">            args (Optional[Tuple[Argument, ...]]): The positional arguments to be passed</span>
<span class="sd">                to the called method. Note that this should *not* include a ``self`` argument.</span>

<span class="sd">            kwargs (Optional[Dict[str, Argument]]): The keyword arguments to be passed</span>
<span class="sd">                to the called method</span>

<span class="sd">            type_expr (Optional[Any]): an optional type annotation representing the</span>
<span class="sd">                Python type the output of this node will have.</span>

<span class="sd">        Returns:</span>

<span class="sd">            The newly-created and inserted ``call_module`` node.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The same insertion point and type expression rules apply for this method</span>
<span class="sd">            as :meth:`Graph.create_node`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">owning_module</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">owning_module</span><span class="o">.</span><span class="n">get_submodule</span><span class="p">(</span><span class="n">module_name</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Attempted to insert a call_module Node with &quot;</span>
                          <span class="s2">&quot;no underlying reference in the owning &quot;</span>
                          <span class="s2">&quot;GraphModule! Call &quot;</span>
                          <span class="s2">&quot;GraphModule.add_submodule to add the &quot;</span>
                          <span class="s2">&quot;necessary submodule&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_node</span><span class="p">(</span><span class="s1">&#39;call_module&#39;</span><span class="p">,</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">type_expr</span><span class="o">=</span><span class="n">type_expr</span><span class="p">)</span></div>

<div class="viewcode-block" id="Graph.call_method"><a class="viewcode-back" href="../../../fx.html#torch.fx.Graph.call_method">[docs]</a>    <span class="k">def</span> <span class="nf">call_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">method_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                    <span class="n">args</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="s1">&#39;Argument&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;Argument&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">type_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert a ``call_method`` ``Node`` into the ``Graph``. A ``call_method`` node</span>
<span class="sd">        represents a call to a given method on the 0th element of ``args``.</span>

<span class="sd">        Args:</span>

<span class="sd">            method_name (str): The name of the method to apply to the self argument.</span>
<span class="sd">                For example, if args[0] is a ``Node`` representing a ``Tensor``,</span>
<span class="sd">                then to call ``relu()`` on that ``Tensor``, pass ``relu`` to ``method_name``.</span>

<span class="sd">            args (Optional[Tuple[Argument, ...]]): The positional arguments to be passed</span>
<span class="sd">                to the called method. Note that this *should* include a ``self`` argument.</span>

<span class="sd">            kwargs (Optional[Dict[str, Argument]]): The keyword arguments to be passed</span>
<span class="sd">                to the called method</span>

<span class="sd">            type_expr (Optional[Any]): an optional type annotation representing the</span>
<span class="sd">                Python type the output of this node will have.</span>

<span class="sd">        Returns:</span>

<span class="sd">            The newly created and inserted ``call_method`` node.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The same insertion point and type expression rules apply for this method</span>
<span class="sd">            as :meth:`Graph.create_node`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_node</span><span class="p">(</span><span class="s1">&#39;call_method&#39;</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">type_expr</span><span class="o">=</span><span class="n">type_expr</span><span class="p">)</span></div>

<div class="viewcode-block" id="Graph.call_function"><a class="viewcode-back" href="../../../fx.html#torch.fx.Graph.call_function">[docs]</a>    <span class="k">def</span> <span class="nf">call_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                      <span class="n">the_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
                      <span class="n">args</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="s1">&#39;Argument&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="n">kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;Argument&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="n">type_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert a ``call_function`` ``Node`` into the ``Graph``. A ``call_function`` node</span>
<span class="sd">        represents a call to a Python callable, specified by ``the_function``. ``the_function``</span>
<span class="sd">        can be</span>

<span class="sd">        Args:</span>

<span class="sd">            the_function (Callable[..., Any]): The function to be called. Can be any PyTorch</span>
<span class="sd">                operator, Python function, or member of the ``builtins`` or ``operator``</span>
<span class="sd">                namespaces.</span>

<span class="sd">            args (Optional[Tuple[Argument, ...]]): The positional arguments to be passed</span>
<span class="sd">                to the called function.</span>

<span class="sd">            kwargs (Optional[Dict[str, Argument]]): The keyword arguments to be passed</span>
<span class="sd">                to the called function</span>

<span class="sd">            type_expr (Optional[Any]): an optional type annotation representing the</span>
<span class="sd">                Python type the output of this node will have.</span>

<span class="sd">        Returns</span>

<span class="sd">            The newly created and inserted ``call_function`` node.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The same insertion point and type expression rules apply for this method</span>
<span class="sd">            as :meth:`Graph.create_node`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_node</span><span class="p">(</span><span class="s1">&#39;call_function&#39;</span><span class="p">,</span> <span class="n">the_function</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">type_expr</span><span class="o">=</span><span class="n">type_expr</span><span class="p">)</span></div>

<div class="viewcode-block" id="Graph.node_copy"><a class="viewcode-back" href="../../../fx.html#torch.fx.Graph.node_copy">[docs]</a>    <span class="k">def</span> <span class="nf">node_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">arg_transform</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Node</span><span class="p">],</span> <span class="s1">&#39;Argument&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copy a node from one graph into another. ``arg_transform`` needs to transform arguments from</span>
<span class="sd">        the graph of node to the graph of self. Example::</span>

<span class="sd">            # Copying all the nodes in `g` into `new_graph`</span>
<span class="sd">            g : torch.fx.Graph = ...</span>
<span class="sd">            new_graph = torch.fx.graph()</span>
<span class="sd">            value_remap = {}</span>
<span class="sd">            for node in g.nodes:</span>
<span class="sd">                value_remap[node] = new_graph.node_copy(node, lambda n : value_remap[n])</span>

<span class="sd">        Args:</span>

<span class="sd">            node (Node): The node to copy into ``self``.</span>

<span class="sd">            arg_transform (Callable[[Node], Argument]): A function that transforms</span>
<span class="sd">                ``Node`` arguments in node&#39;s ``args`` and ``kwargs`` into the</span>
<span class="sd">                equivalent argument in ``self``. In the simplest case, this should</span>
<span class="sd">                retrieve a value out of a table mapping Nodes in the original</span>
<span class="sd">                graph to ``self``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">map_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">arg_transform</span><span class="p">)</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">map_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">arg_transform</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
        <span class="n">result_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_node</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
        <span class="n">result_node</span><span class="o">.</span><span class="n">meta</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">meta</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result_node</span></div>

<div class="viewcode-block" id="Graph.output"><a class="viewcode-back" href="../../../fx.html#torch.fx.Graph.output">[docs]</a>    <span class="k">def</span> <span class="nf">output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="s1">&#39;Argument&#39;</span><span class="p">,</span> <span class="n">type_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert an ``output`` ``Node`` into the ``Graph``. An ``output`` node represents</span>
<span class="sd">        a ``return`` statement in Python code. ``result`` is the value that should</span>
<span class="sd">        be returned.</span>

<span class="sd">        Args:</span>

<span class="sd">            result (Argument): The value to be returned.</span>

<span class="sd">            type_expr (Optional[Any]): an optional type annotation representing the</span>
<span class="sd">                Python type the output of this node will have.</span>

<span class="sd">        .. note::</span>

<span class="sd">            The same insertion point and type expression rules apply for this method</span>
<span class="sd">            as ``Graph.create_node``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_node</span><span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="s1">&#39;output&#39;</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="s1">&#39;output&#39;</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">result</span><span class="p">,),</span> <span class="n">type_expr</span><span class="o">=</span><span class="n">type_expr</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_target_to_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span> <span class="p">:</span> <span class="n">Target</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">target</span>
            <span class="k">if</span> <span class="n">_is_magic</span><span class="p">(</span><span class="n">op</span><span class="p">):</span>
                <span class="n">op</span> <span class="o">=</span> <span class="n">op</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">_snake_case</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">op</span>

<div class="viewcode-block" id="Graph.python_code"><a class="viewcode-back" href="../../../fx.html#torch.fx.Graph.python_code">[docs]</a>    <span class="k">def</span> <span class="nf">python_code</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root_module</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PythonCode</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Turn this ``Graph`` into valid Python code.</span>

<span class="sd">        Args:</span>

<span class="sd">            root_module (str): The name of the root module on which to look-up</span>
<span class="sd">                qualified name targets. This is usually &#39;self&#39;.</span>

<span class="sd">        Returns:</span>

<span class="sd">            A PythonCode object, consisting of two fields:</span>
<span class="sd">                src: the Python source code representing the object</span>
<span class="sd">                globals: a dictionary of global names in `src` -&gt; the objects that they reference.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOTE: [Graph Namespaces]</span>
        <span class="c1">#</span>
        <span class="c1"># There are two types of symbols in generated Python source code:</span>
        <span class="c1"># locals and globals.</span>
        <span class="c1">#   Locals are locally defined by the output of a node in the Graph.</span>
        <span class="c1">#   Globals are references to external objects, like functions or types.</span>
        <span class="c1">#</span>
        <span class="c1"># When generating Python code, we need to make sure to name things</span>
        <span class="c1"># appropriately. In particular:</span>
        <span class="c1"># - All names should be unique, to avoid weird shadowing bugs.</span>
        <span class="c1"># - These names need to be consistent, e.g. a object should always be</span>
        <span class="c1">#   referenced by the same name.</span>
        <span class="c1">#</span>
        <span class="c1"># To do this, we create a new namespace just for this source. All names</span>
        <span class="c1"># that get printed must come from this namespace.</span>
        <span class="c1">#</span>
        <span class="c1"># Why can&#39;t we re-use node.name? Because it was generated within the</span>
        <span class="c1"># namespace `self._graph_namespace`. In order to provide uniqueness</span>
        <span class="c1"># over both locals (node.name) *and* globals, we create a completely</span>
        <span class="c1"># new namespace to put all identifiers in.</span>
        <span class="n">namespace</span> <span class="o">=</span> <span class="n">_Namespace</span><span class="p">()</span>

        <span class="c1"># Override Node&#39;s repr to generate a valid name within our namespace.</span>
        <span class="c1"># Since repr() is designed to produce a valid Python expression, it</span>
        <span class="c1"># makes sense to re-use it. This way, it&#39;s easy to print something like</span>
        <span class="c1"># Tuple[Node, Node] by simply calling repr() on it. Node&#39;s __repr__ is</span>
        <span class="c1"># implemented cooperatively to allow this.</span>
        <span class="k">def</span> <span class="nf">node_repr</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="n">Node</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">namespace</span><span class="o">.</span><span class="n">create_name</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

        <span class="nd">@contextmanager</span>
        <span class="k">def</span> <span class="nf">override_node_repr</span><span class="p">(</span><span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">):</span>
            <span class="n">orig_repr_fns</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                <span class="n">orig_repr_fns</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">_repr_fn</span>
                <span class="n">node</span><span class="o">.</span><span class="n">_repr_fn</span> <span class="o">=</span> <span class="n">node_repr</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">yield</span> <span class="kc">None</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="c1"># restore the original repr functions</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">_repr_fn</span> <span class="o">=</span> <span class="n">orig_repr_fns</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>

        <span class="k">with</span> <span class="n">override_node_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_python_code</span><span class="p">(</span><span class="n">root_module</span><span class="p">,</span> <span class="n">namespace</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_python_code</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root_module</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">namespace</span><span class="p">:</span> <span class="n">_Namespace</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PythonCode</span><span class="p">:</span>
        <span class="n">free_vars</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">body</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">globals_</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Wrap string in list to pass by reference</span>
        <span class="n">maybe_return_annotation</span> <span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">add_global</span><span class="p">(</span><span class="n">name_hint</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Add an obj to be tracked as a global.</span>

<span class="sd">            We call this for names that reference objects external to the</span>
<span class="sd">            Graph, like functions or types.</span>

<span class="sd">            Returns: the global name that should be used to reference &#39;obj&#39; in generated source.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">_is_from_torch</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">and</span> <span class="n">obj</span> <span class="o">!=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">:</span>  <span class="c1"># to support registering torch.device</span>
                <span class="c1"># HACK: workaround for how torch custom ops are registered. We</span>
                <span class="c1"># can&#39;t import them like normal modules so they must retain their</span>
                <span class="c1"># fully qualified name.</span>
                <span class="k">return</span> <span class="n">_get_qualified_name</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

            <span class="c1"># normalize the name hint to get a proper identifier</span>
            <span class="n">global_name</span> <span class="o">=</span> <span class="n">namespace</span><span class="o">.</span><span class="n">create_name</span><span class="p">(</span><span class="n">name_hint</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">global_name</span> <span class="ow">in</span> <span class="n">globals_</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">globals_</span><span class="p">[</span><span class="n">global_name</span><span class="p">]</span> <span class="ow">is</span> <span class="n">obj</span>
                <span class="k">return</span> <span class="n">global_name</span>
            <span class="n">globals_</span><span class="p">[</span><span class="n">global_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>
            <span class="k">return</span> <span class="n">global_name</span>

        <span class="c1"># Pre-fill the globals table with registered builtins.</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span> <span class="ow">in</span> <span class="n">_custom_builtins</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">add_global</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">type_repr</span><span class="p">(</span><span class="n">o</span> <span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
            <span class="n">typename</span> <span class="o">=</span> <span class="n">_type_repr</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

            <span class="c1"># This is a generic type, e.g. typing.List[torch.Tensor]</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s1">&#39;__origin__&#39;</span><span class="p">):</span>
                <span class="n">origin_type</span> <span class="o">=</span> <span class="n">_origin_type_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">__origin__</span><span class="p">)</span>
                <span class="n">origin_typename</span> <span class="o">=</span> <span class="n">add_global</span><span class="p">(</span><span class="n">_type_repr</span><span class="p">(</span><span class="n">origin_type</span><span class="p">),</span> <span class="n">origin_type</span><span class="p">)</span>

                <span class="c1"># Assign global names for each of the inner type variables.</span>
                <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">type_repr</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">o</span><span class="o">.</span><span class="n">__args__</span><span class="p">]</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">origin_typename</span><span class="si">}</span><span class="s1">[</span><span class="si">{</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="si">}</span><span class="s1">]&#39;</span>

            <span class="c1"># Common case: this is a regular module name like &#39;foo.bar.baz&#39;</span>
            <span class="k">return</span> <span class="n">add_global</span><span class="p">(</span><span class="n">typename</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span>

        <span class="c1"># Run through reverse nodes and record the first instance of a use</span>
        <span class="c1"># of a given node. This represents the *last* use of the node in the</span>
        <span class="c1"># execution order of the program, which we will use to free unused</span>
        <span class="c1"># values</span>
        <span class="n">node_to_last_use</span> <span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Node</span><span class="p">,</span> <span class="n">Node</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">user_to_last_uses</span> <span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Node</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Node</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">def</span> <span class="nf">register_last_uses</span><span class="p">(</span><span class="n">n</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">user</span> <span class="p">:</span> <span class="n">Node</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node_to_last_use</span><span class="p">:</span>
                <span class="n">node_to_last_use</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">user</span>
                <span class="n">user_to_last_uses</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">):</span>
            <span class="n">map_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">register_last_uses</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
            <span class="n">map_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">kwargs</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">register_last_uses</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">delete_unused_values</span><span class="p">(</span><span class="n">user</span> <span class="p">:</span> <span class="n">Node</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Delete values after their last use. This ensures that values that are</span>
<span class="sd">            not used in the remainder of the code are freed and the memory usage</span>
<span class="sd">            of the code is optimal.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">user</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;placeholder&#39;</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">user</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;output&#39;</span><span class="p">:</span>
                <span class="n">body</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="n">nodes_to_delete</span> <span class="o">=</span> <span class="n">user_to_last_uses</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="p">[])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes_to_delete</span><span class="p">):</span>
                <span class="n">to_delete_str</span> <span class="o">=</span> <span class="s1">&#39; = &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">repr</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes_to_delete</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;None&#39;</span><span class="p">])</span>
                <span class="n">body</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;;  </span><span class="si">{</span><span class="n">to_delete_str</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">body</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>


        <span class="k">def</span> <span class="nf">emit_node</span><span class="p">(</span><span class="n">node</span> <span class="p">:</span> <span class="n">Node</span><span class="p">):</span>
            <span class="n">maybe_type_annotation</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="sa">f</span><span class="s1">&#39; : </span><span class="si">{</span><span class="n">type_repr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">type</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;placeholder&#39;</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
                <span class="n">maybe_default_arg</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">args</span> <span class="k">else</span> <span class="sa">f</span><span class="s1">&#39; = </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="n">free_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="si">}{</span><span class="n">maybe_type_annotation</span><span class="si">}{</span><span class="n">maybe_default_arg</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">raw_name</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">raw_name</span> <span class="o">!=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                    <span class="n">body</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s1"> = </span><span class="si">{</span><span class="n">raw_name</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;call_method&#39;</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
                <span class="n">body</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}{</span><span class="n">maybe_type_annotation</span><span class="si">}</span><span class="s1"> = </span><span class="si">{</span><span class="n">_format_target</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="n">_format_args</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">node</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;call_function&#39;</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">callable</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
                <span class="c1"># pretty print operators</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">==</span> <span class="s1">&#39;_operator&#39;</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">in</span> <span class="n">magic_methods</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
                    <span class="n">body</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}{</span><span class="n">maybe_type_annotation</span><span class="si">}</span><span class="s1"> = &#39;</span>
                                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">magic_methods</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">))</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="k">return</span>
                <span class="n">qualified_name</span> <span class="o">=</span> <span class="n">_get_qualified_name</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
                <span class="n">global_name</span> <span class="o">=</span> <span class="n">add_global</span><span class="p">(</span><span class="n">qualified_name</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">global_name</span> <span class="o">==</span> <span class="s1">&#39;getattr&#39;</span> <span class="ow">and</span> \
                   <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> \
                   <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> \
                   <span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">isidentifier</span><span class="p">():</span>
                    <span class="c1"># pretty print attribute access</span>
                    <span class="n">body</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}{</span><span class="n">maybe_type_annotation</span><span class="si">}</span><span class="s1"> = </span><span class="si">{</span><span class="n">_format_target</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="k">return</span>
                <span class="n">body</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}{</span><span class="n">maybe_type_annotation</span><span class="si">}</span><span class="s1"> = </span><span class="si">{</span><span class="n">global_name</span><span class="si">}</span><span class="s1">(</span><span class="si">{</span><span class="n">_format_args</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;call_module&#39;</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
                <span class="n">body</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}{</span><span class="n">maybe_type_annotation</span><span class="si">}</span><span class="s1"> = &#39;</span>
                            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">_format_target</span><span class="p">(</span><span class="n">root_module</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">)</span><span class="si">}</span><span class="s1">(</span><span class="si">{</span><span class="n">_format_args</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;get_attr&#39;</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
                <span class="n">body</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}{</span><span class="n">maybe_type_annotation</span><span class="si">}</span><span class="s1"> = </span><span class="si">{</span><span class="n">_format_target</span><span class="p">(</span><span class="n">root_module</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;output&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">maybe_return_annotation</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot; -&gt; </span><span class="si">{</span><span class="n">type_repr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">type</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pytree_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">body</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;return </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">body</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;return pytree.tree_unflatten(</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s1">, self._out_spec)&#39;</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;node: </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="c1"># NOTE: emit_node does not emit a string with newline. It depends</span>
            <span class="c1"># on delete_unused_values to append one</span>
            <span class="n">emit_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">delete_unused_values</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">body</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># If the Graph has no non-placeholder nodes, no lines for the body</span>
            <span class="c1"># have been emitted. To continue to have valid Python code, emit a</span>
            <span class="c1"># single pass statement</span>
            <span class="n">body</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;pass</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pytree_info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">orig_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pytree_info</span><span class="o">.</span><span class="n">orig_args</span>
            <span class="n">has_orig_self</span> <span class="o">=</span> <span class="p">(</span><span class="n">orig_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;self&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">has_orig_self</span><span class="p">:</span>
                <span class="n">free_vars</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;self&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">free_vars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># pytree has placeholders in it</span>
                <span class="n">body</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">free_vars</span><span class="p">)</span><span class="si">}</span><span class="s2">, = fx_pytree.tree_flatten_spec([</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">orig_args</span><span class="p">)</span><span class="si">}</span><span class="s2">], self._in_spec)</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">orig_args</span> <span class="o">=</span> <span class="n">free_vars</span>

        <span class="c1"># If the original function didn&#39;t have self as its first argument, we</span>
        <span class="c1"># would have added it.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">orig_args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">orig_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;self&#39;</span><span class="p">:</span>
            <span class="n">orig_args</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;self&#39;</span><span class="p">)</span>
        <span class="n">code</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>
        <span class="n">code</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;    &#39;</span> <span class="o">+</span> <span class="n">line</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">code</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">))</span>
        <span class="n">fn_code</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">def forward(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">orig_args</span><span class="p">)</span><span class="si">}</span><span class="s2">)</span><span class="si">{</span><span class="n">maybe_return_annotation</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">:</span>
<span class="si">{</span><span class="n">code</span><span class="si">}</span><span class="s2">&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">PythonCode</span><span class="p">(</span><span class="n">fn_code</span><span class="p">,</span>
                          <span class="n">globals_</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print a human-readable (not machine-readable) string representation</span>
<span class="sd">        of this Graph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">placeholder_names</span> <span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># This is a one-element array just so ``format_node`` can modify the closed</span>
        <span class="c1"># over value</span>
        <span class="n">maybe_return_typename</span> <span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span>

        <span class="n">node_strs</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">format_node</span><span class="p">(</span><span class="n">placeholder_names</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">]</span>
        <span class="n">param_str</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">placeholder_names</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;graph(</span><span class="si">{</span><span class="n">param_str</span><span class="si">}</span><span class="s1">)</span><span class="si">{</span><span class="n">maybe_return_typename</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">:&#39;</span>
        <span class="k">for</span> <span class="n">node_str</span> <span class="ow">in</span> <span class="n">node_strs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node_str</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">    &#39;</span> <span class="o">+</span> <span class="n">node_str</span>
        <span class="k">return</span> <span class="n">s</span>

<div class="viewcode-block" id="Graph.print_tabular"><a class="viewcode-back" href="../../../fx.html#torch.fx.Graph.print_tabular">[docs]</a>    <span class="k">def</span> <span class="nf">print_tabular</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prints the intermediate representation of the graph in tabular</span>
<span class="sd">        format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">tabulate</span> <span class="kn">import</span> <span class="n">tabulate</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;`print_tabular` relies on the library `tabulate`, &quot;</span>
                  <span class="s2">&quot;which could not be found on this machine. Run `pip &quot;</span>
                  <span class="s2">&quot;install tabulate` to install the library.&quot;</span><span class="p">)</span>
        <span class="n">node_specs</span> <span class="o">=</span> <span class="p">[[</span><span class="n">n</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">kwargs</span><span class="p">]</span>
                      <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">tabulate</span><span class="p">(</span><span class="n">node_specs</span><span class="p">,</span>
              <span class="n">headers</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;opcode&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;target&#39;</span><span class="p">,</span> <span class="s1">&#39;args&#39;</span><span class="p">,</span> <span class="s1">&#39;kwargs&#39;</span><span class="p">]))</span></div>

<div class="viewcode-block" id="Graph.lint"><a class="viewcode-back" href="../../../fx.html#torch.fx.Graph.lint">[docs]</a>    <span class="k">def</span> <span class="nf">lint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Runs various checks on this Graph to make sure it is well-formed. In</span>
<span class="sd">        particular:</span>
<span class="sd">        - Checks Nodes have correct ownership (owned by this graph)</span>
<span class="sd">        - Checks Nodes appear in topological order</span>
<span class="sd">        - If this Graph has an owning GraphModule, checks that targets</span>
<span class="sd">        exist in that GraphModule</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check topo order</span>
        <span class="k">def</span> <span class="nf">check_arg</span><span class="p">(</span><span class="n">arg</span> <span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Node</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">context_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39; of Node </span><span class="se">\&#39;</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="se">\&#39;</span><span class="s1"> &#39;</span> <span class="k">if</span> <span class="n">n</span> <span class="k">else</span> <span class="s1">&#39; &#39;</span>
            <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">graph</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Argument </span><span class="se">\&#39;</span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="se">\&#39;</span><span class="si">{</span><span class="n">context_str</span><span class="si">}</span><span class="s1">does not belong to this Graph, &#39;</span>
                                   <span class="sa">f</span><span class="s1">&#39;but was used as an argument! If you are copying nodes from another graph, make &#39;</span>
                                   <span class="sa">f</span><span class="s1">&#39;sure to use ``arg_transform`` on node_copy() to remap values</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen_values</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Argument </span><span class="se">\&#39;</span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="se">\&#39;</span><span class="si">{</span><span class="n">context_str</span><span class="si">}</span><span class="s1">was used before it has been &#39;</span>
                                   <span class="sa">f</span><span class="s1">&#39;defined! Please check that Nodes in the graph are topologically ordered</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">seen_names</span> <span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">seen_values</span> <span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;placeholder&#39;</span><span class="p">,</span> <span class="s1">&#39;call_method&#39;</span><span class="p">,</span> <span class="s1">&#39;call_module&#39;</span><span class="p">,</span> <span class="s1">&#39;call_function&#39;</span><span class="p">,</span> <span class="s1">&#39;get_attr&#39;</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Node </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s1"> had unknown opcode </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="si">}</span><span class="s1">!&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">graph</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Node </span><span class="se">\&#39;</span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="se">\&#39;</span><span class="s1"> does not belong to this Graph!&#39;</span><span class="p">)</span>
            <span class="n">map_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">arg</span><span class="p">:</span> <span class="n">check_arg</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
            <span class="n">map_arg</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">kwargs</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">arg</span><span class="p">:</span> <span class="n">check_arg</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
            <span class="n">seen_values</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">seen_names</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Node redefined name </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">!&#39;</span><span class="p">)</span>
            <span class="n">seen_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># Check targets are legit</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">owning_module</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;get_attr&#39;</span><span class="p">,</span> <span class="s1">&#39;call_module&#39;</span><span class="p">]:</span>
                    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
                    <span class="n">target_atoms</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
                    <span class="n">m_itr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">owning_module</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">target_atoms</span><span class="p">):</span>
                        <span class="n">new_m_itr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">m_itr</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                        <span class="n">seen_qualname</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">target_atoms</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">new_m_itr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Node </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s1"> target </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="si">}</span><span class="s1"> references nonexistent attribute &#39;</span>
                                               <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">atom</span><span class="si">}</span><span class="s1"> of </span><span class="si">{</span><span class="n">seen_qualname</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;call_module&quot;</span>
                                <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_m_itr</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">)):</span>
                            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Node </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s1"> target </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">atom</span><span class="si">}</span><span class="s1"> of </span><span class="si">{</span><span class="n">seen_qualname</span><span class="si">}</span><span class="s1"> does &#39;</span>
                                               <span class="s1">&#39;not reference an nn.Module&#39;</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;get_attr&quot;</span>
                              <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_m_itr</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">)</span>
                              <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_m_itr</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Parameter</span><span class="p">)</span>
                              <span class="ow">and</span> <span class="n">atom</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">m_itr</span><span class="o">.</span><span class="n">_buffers</span><span class="p">):</span>
                            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Node </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s1"> target </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">atom</span><span class="si">}</span><span class="s1"> of </span><span class="si">{</span><span class="n">seen_qualname</span><span class="si">}</span><span class="s1"> does &#39;</span>
                                          <span class="s1">&#39;not reference an nn.Module, nn.Parameter, or buffer, which is &#39;</span>
                                          <span class="s1">&#39;what </span><span class="se">\&#39;</span><span class="s1">get_attr</span><span class="se">\&#39;</span><span class="s1"> Nodes typically target&#39;</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">m_itr</span> <span class="o">=</span> <span class="n">new_m_itr</span></div>

<div class="viewcode-block" id="Graph.eliminate_dead_code"><a class="viewcode-back" href="../../../fx.html#torch.fx.Graph.eliminate_dead_code">[docs]</a>    <span class="k">def</span> <span class="nf">eliminate_dead_code</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all dead code from the graph, based on each node&#39;s number of</span>
<span class="sd">        users, and whether the nodes have any side effects. The graph must be</span>
<span class="sd">        topologically sorted before calling.</span>

<span class="sd">        Returns:</span>
<span class="sd">          bool: Whether the graph was changed as a result of the pass.</span>

<span class="sd">        Example:</span>

<span class="sd">        Before dead code is eliminated, `a` from `a = x + 1` below has no users</span>
<span class="sd">        and thus can be eliminated from the graph without having an effect.</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            def forward(self, x):</span>
<span class="sd">                a = x + 1</span>
<span class="sd">                return x + self.attr_1</span>

<span class="sd">        After dead code is eliminated, `a = x + 1` has been removed, and the rest</span>
<span class="sd">        of `forward` remains.</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            def forward(self, x):</span>
<span class="sd">                return x + self.attr_1</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Lint the graph first to make sure its topologically sorted, otherwise</span>
        <span class="c1"># DCE below will not behave as expected.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lint</span><span class="p">()</span>

        <span class="c1"># Reverse iterate so that when we remove a node, any nodes used as an</span>
        <span class="c1"># input to that node have an updated user count that no longer reflects</span>
        <span class="c1"># the removed node.</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_impure</span><span class="p">()</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">users</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">erase_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">changed</span></div></div>


<span class="n">reflectable_magic_methods</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;add&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> + </span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">,</span>
    <span class="s1">&#39;sub&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> - </span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">,</span>
    <span class="s1">&#39;mul&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> * </span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">,</span>
    <span class="s1">&#39;floordiv&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> // </span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">,</span>
    <span class="s1">&#39;truediv&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> / </span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">,</span>
    <span class="s1">&#39;div&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> / </span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">,</span>
    <span class="s1">&#39;mod&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> % </span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">,</span>
    <span class="s1">&#39;pow&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> ** </span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">,</span>
    <span class="s1">&#39;lshift&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> &lt;&lt; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">,</span>
    <span class="s1">&#39;rshift&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> &gt;&gt; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">,</span>
    <span class="s1">&#39;and&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> &amp; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">,</span>
    <span class="s1">&#39;or&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> | </span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">,</span>
    <span class="s1">&#39;xor&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> ^ </span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">,</span>
    <span class="s1">&#39;getitem&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">[</span><span class="si">{}</span><span class="s1">]&#39;</span>
<span class="p">}</span>

<span class="n">magic_methods</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">({</span>
    <span class="s1">&#39;eq&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> == </span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ne&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> != </span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">,</span>
    <span class="s1">&#39;lt&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> &lt; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">,</span>
    <span class="s1">&#39;gt&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> &gt; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">,</span>
    <span class="s1">&#39;le&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> &lt;= </span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ge&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> &gt;= </span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">,</span>
    <span class="s1">&#39;pos&#39;</span><span class="p">:</span> <span class="s1">&#39;+</span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">,</span>
    <span class="s1">&#39;neg&#39;</span><span class="p">:</span> <span class="s1">&#39;-</span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">,</span>
    <span class="s1">&#39;invert&#39;</span><span class="p">:</span> <span class="s1">&#39;~</span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">},</span> <span class="o">**</span><span class="n">reflectable_magic_methods</span><span class="p">)</span>
</pre></div>

             </article>
             
            </div>
            <footer>
  

  

    <hr>

  

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Torch Contributors.

    </p>
  </div>
    
      <div>
        Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
      </div>
     

</footer>

          </div>
        </div>

        <div class="pytorch-content-right" id="pytorch-content-right">
          <div class="pytorch-right-menu" id="pytorch-right-menu">
            <div class="pytorch-side-scroll" id="pytorch-side-scroll-right">
              
            </div>
          </div>
        </div>
      </section>
    </div>

  


  

     
       <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
         <script src="../../../_static/jquery.js"></script>
         <script src="../../../_static/underscore.js"></script>
         <script src="../../../_static/doctools.js"></script>
         <script src="../../../_static/language_data.js"></script>
     

  

  <script type="text/javascript" src="../../../_static/js/vendor/popper.min.js"></script>
  <script type="text/javascript" src="../../../_static/js/vendor/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/list.js/1.5.0/list.min.js"></script>
  <script type="text/javascript" src="../../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 
<script script type="text/javascript">
  var collapsedSections = ['Notes', 'Language Bindings', 'Libraries', 'Community'];
</script>

<img height="1" width="1" style="border-style:none;" alt="" src="https://www.googleadservices.com/pagead/conversion/795629140/?label=txkmCPmdtosBENSssfsC&amp;guid=ON&amp;script=0"/>


  <!-- Begin Footer -->

  <div class="container-fluid docs-tutorials-resources" id="docs-tutorials-resources">
    <div class="container">
      <div class="row">
        <div class="col-md-4 text-center">
          <h2>Docs</h2>
          <p>Access comprehensive developer documentation for PyTorch</p>
          <a class="with-right-arrow" href="https://pytorch.org/docs/stable/index.html">View Docs</a>
        </div>

        <div class="col-md-4 text-center">
          <h2>Tutorials</h2>
          <p>Get in-depth tutorials for beginners and advanced developers</p>
          <a class="with-right-arrow" href="https://pytorch.org/tutorials">View Tutorials</a>
        </div>

        <div class="col-md-4 text-center">
          <h2>Resources</h2>
          <p>Find development resources and get your questions answered</p>
          <a class="with-right-arrow" href="https://pytorch.org/resources">View Resources</a>
        </div>
      </div>
    </div>
  </div>

  <footer class="site-footer">
    <div class="container footer-container">
      <div class="footer-logo-wrapper">
        <a href="https://pytorch.org/" class="footer-logo"></a>
      </div>

      <div class="footer-links-wrapper">
        <div class="footer-links-col">
          <ul>
            <li class="list-title"><a href="https://pytorch.org/">PyTorch</a></li>
            <li><a href="https://pytorch.org/get-started">Get Started</a></li>
            <li><a href="https://pytorch.org/features">Features</a></li>
            <li><a href="https://pytorch.org/ecosystem">Ecosystem</a></li>
            <li><a href="https://pytorch.org/blog/">Blog</a></li>
            <li><a href="https://github.com/pytorch/pytorch/blob/master/CONTRIBUTING.md">Contributing</a></li>
          </ul>
        </div>

        <div class="footer-links-col">
          <ul>
            <li class="list-title"><a href="https://pytorch.org/resources">Resources</a></li>
            <li><a href="https://pytorch.org/tutorials">Tutorials</a></li>
            <li><a href="https://pytorch.org/docs/stable/index.html">Docs</a></li>
            <li><a href="https://discuss.pytorch.org" target="_blank">Discuss</a></li>
            <li><a href="https://github.com/pytorch/pytorch/issues" target="_blank">Github Issues</a></li>
            <li><a href="https://pytorch.org/assets/brand-guidelines/PyTorch-Brand-Guidelines.pdf" target="_blank">Brand Guidelines</a></li>
          </ul>
        </div>

        <div class="footer-links-col follow-us-col">
          <ul>
            <li class="list-title">Stay Connected</li>
            <li>
              <div id="mc_embed_signup">
                <form
                  action="https://twitter.us14.list-manage.com/subscribe/post?u=75419c71fe0a935e53dfa4a3f&id=91d0dccd39"
                  method="post"
                  id="mc-embedded-subscribe-form"
                  name="mc-embedded-subscribe-form"
                  class="email-subscribe-form validate"
                  target="_blank"
                  novalidate>
                  <div id="mc_embed_signup_scroll" class="email-subscribe-form-fields-wrapper">
                    <div class="mc-field-group">
                      <label for="mce-EMAIL" style="display:none;">Email Address</label>
                      <input type="email" value="" name="EMAIL" class="required email" id="mce-EMAIL" placeholder="Email Address">
                    </div>

                    <div id="mce-responses" class="clear">
                      <div class="response" id="mce-error-response" style="display:none"></div>
                      <div class="response" id="mce-success-response" style="display:none"></div>
                    </div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->

                    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_75419c71fe0a935e53dfa4a3f_91d0dccd39" tabindex="-1" value=""></div>

                    <div class="clear">
                      <input type="submit" value="" name="subscribe" id="mc-embedded-subscribe" class="button email-subscribe-button">
                    </div>
                  </div>
                </form>
              </div>

            </li>
          </ul>

          <div class="footer-social-icons">
            <a href="https://www.facebook.com/pytorch" target="_blank" class="facebook"></a>
            <a href="https://twitter.com/pytorch" target="_blank" class="twitter"></a>
            <a href="https://www.youtube.com/pytorch" target="_blank" class="youtube"></a>
          </div>
        </div>
      </div>
    </div>
  </footer>

  <div class="cookie-banner-wrapper">
  <div class="container">
    <p class="gdpr-notice">To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or navigating, you agree to allow our usage of cookies. As the current maintainers of this site, Facebookâ€™s Cookies Policy applies. Learn more, including about available controls: <a href="https://www.facebook.com/policies/cookies/">Cookies Policy</a>.</p>
    <img class="close-button" src="../../../_static/images/pytorch-x.svg">
  </div>
</div>

  <!-- End Footer -->

  <!-- Begin Mobile Menu -->

  <div class="mobile-main-menu">
    <div class="container-fluid">
      <div class="container">
        <div class="mobile-main-menu-header-container">
          <a class="header-logo" href="https://pytorch.org/" aria-label="PyTorch"></a>
          <a class="main-menu-close-button" href="#" data-behavior="close-mobile-menu"></a>
        </div>
      </div>
    </div>

    <div class="mobile-main-menu-links-container">
      <div class="main-menu">
        <ul>
          <li>
            <a href="https://pytorch.org/get-started">Get Started</a>
          </li>

          <li>
            <a href="https://pytorch.org/ecosystem">Ecosystem</a>
          </li>

          <li>
            <a href="https://pytorch.org/mobile">Mobile</a>
          </li>

          <li>
            <a href="https://pytorch.org/hub">PyTorch Hub</a>
          </li>

          <li>
            <a href="https://pytorch.org/blog/">Blog</a>
          </li>

          <li>
            <a href="https://pytorch.org/tutorials">Tutorials</a>
          </li>

          <li class="resources-mobile-menu-title" class="active">
            Docs
          </li>

          <ul class="resources-mobile-menu-items">
            <li>
              <a href="https://pytorch.org/docs/stable/index.html">PyTorch</a>
            </li>

            <li>
              <a href="https://pytorch.org/audio/stable/index.html">torchaudio</a>
            </li>

            <li>
              <a href="https://pytorch.org/text/stable/index.html">torchtext</a>
            </li>

            <li>
              <a href="https://pytorch.org/vision/stable/index.html">torchvision</a>
            </li>

            <li>
              <a href="https://pytorch.org/elastic/">TorchElastic</a>
            </li>

            <li>
              <a href="https://pytorch.org/serve/">TorchServe</a>
            </li>

            <li>
              <a href="https://pytorch.org/xla">PyTorch on XLA Devices</a>
            </li>
          </ul>

          <li class="resources-mobile-menu-title">
            Resources
          </li>

          <ul class="resources-mobile-menu-items">
            <li>
              <a href="https://pytorch.org/resources">Developer Resources</a>
            </li>

            <li>
              <a href="https://pytorch.org/features">About</a>
            </li>

            <li>
              <a href="https://pytorch.org/hub">Models (Beta)</a>
            </li>

            <li>
              <a href="https://pytorch.org/#community-module">Community</a>
            </li>

            <li>
              <a href="https://discuss.pytorch.org/">Forums</a>
            </li>
          </ul>

          <li>
            <a href="https://github.com/pytorch/pytorch">Github</a>
          </li>
        </ul>
      </div>
    </div>
  </div>

  <!-- End Mobile Menu -->

  <script type="text/javascript" src="../../../_static/js/vendor/anchor.min.js"></script>

  <script type="text/javascript">
    $(document).ready(function() {
      mobileMenu.bind();
      mobileTOC.bind();
      pytorchAnchors.bind();
      sideMenus.bind();
      scrollToAnchor.bind();
      highlightNavigation.bind();
      mainMenuDropdown.bind();
      filterTags.bind();

      // Add class to links that have code blocks, since we cannot create links in code blocks
      $("article.pytorch-article a span.pre").each(function(e) {
        $(this).closest("a").addClass("has-code");
      });
    })
  </script>
</body>
</html>