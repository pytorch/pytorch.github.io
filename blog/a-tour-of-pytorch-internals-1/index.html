<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?">
  <title>
    
      A Tour of PyTorch Internals (Part I) | PyTorch
    
  </title>
  <meta property="og:title" content="PyTorch"/>
<meta property="og:description" content="An open source deep learning platform that provides a seamless path from research prototyping to production deployment."/>
<meta property="og:url" content="https://www.pytorch.org"/>
<meta property="og:type" content="website"/>
<meta property="og:image" content="https://pytorch.org/assets/images/pytorch-logo.png"/>

  <link rel="stylesheet" href="/assets/main.css">
  <script src="/assets/vendor/jquery.min.js"></script>
  <script src="/assets/vendor/popper.min.js"></script>
  <script src="/assets/vendor/bootstrap.min.js"></script>
  <script src="/assets/vendor/anchor.min.js"></script>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-90545585-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA‌-90545585-1');
</script>

    <script>
    !function(f,b,e,v,n,t,s)
    {if(f.fbq)return;n=f.fbq=function(){n.callMethod?
    n.callMethod.apply(n,arguments):n.queue.push(arguments)};
    if(!f._fbq)f._fbq=n;n.push=n;n.loaded=!0;n.version='2.0';
    n.queue=[];t=b.createElement(e);t.async=!0;
    t.src=v;s=b.getElementsByTagName(e)[0];
    s.parentNode.insertBefore(t,s)}(window,document,'script',
    'https://connect.facebook.net/en_US/fbevents.js');
    fbq('init', '243028289693773');
    fbq('track', 'PageView');
  </script>
  <noscript>
    <img height="1" width="1"
    src="https://www.facebook.com/tr?id=243028289693773&ev=PageView
    &noscript=1"/>
  </noscript>

  
</head>


<body class="blog">
    <div class="main-background "></div>

    <div class="container-fluid header-holder blog-detail-header">
        <div class="container">
            

<div class="header-container">
  <a class="header-logo" href="https://pytorch.org" aria-label="PyTorch"></a>

  <div class="main-menu">
  <ul>
    <li class="">
      <a href="/get-started">Get Started</a>
    </li>

    <li class="">
      <a href="/features">Features</a>
    </li>

    <li class="">
      <a href="/ecosystem">Ecosystem</a>
    </li>

    <li class="active">
      <a href="/blog">Blog</a>
    </li>

    <li>
      <a href="https://pytorch.org/tutorials">Tutorials</a>
    </li>

    <li>
      <a href="https://pytorch.org/docs">Docs</a>
    </li>

    <li class="">
      <a href="/resources">Resources</a>
    </li>

    <li>
      <a href="https://github.com/pytorch/pytorch">Github</a>
    </li>
  </ul>
</div>


  <a class="main-menu-open-button" href="#" data-behavior="open-mobile-menu"></a>
</div>

        </div>
    </div>

    <div class="jumbotron jumbotron-fluid">
        <div class="container blog-detail-container">
            <p class="blog-date">May 11, 2017</p>
            <h1>
                <a class="blog-title">A Tour of PyTorch Internals (Part I)</a>
            </h1>
        </div>
    </div>

    <div class="main-content-wrapper">
        <div class="main-content">
            <div class="container">
                <img src="/assets/images/logo-icon.svg" class="img-fluid author-icon">
                <article class="pytorch-article">
                    <p class="author">
                      by
                      
                        Trevor Killeen
                      
                    </p>
                    <p>The fundamental unit in PyTorch is the Tensor. This post will serve as an overview for how we implement Tensors in PyTorch, such that the user can interact with it from the Python shell. In particular, we want to answer four main questions:</p>

<ul>
  <li>How does PyTorch extend the Python interpreter to define a Tensor type that can be manipulated from Python code?</li>
  <li>How does PyTorch wrap the C libraries that actually define the Tensor’s properties and methods?</li>
  <li>How does PyTorch cwrap work to generate code for Tensor methods?</li>
  <li>How does PyTorch’s build system take all of these components to compile and generate a workable application?</li>
</ul>

<h2 id="extending-the-python-interpreter">Extending the Python Interpreter</h2>

<p>PyTorch defines a new package <code class="highlighter-rouge">torch</code>. In this post we will consider the <code class="highlighter-rouge">._C</code> module. This module is known as an “extension module” - a Python module written in C. Such modules allow us to define new built-in object types (e.g. the <code class="highlighter-rouge">Tensor</code>) and to call C/C++ functions.</p>

<p>The <code class="highlighter-rouge">._C</code> module is defined in <code class="highlighter-rouge">torch/csrc/Module.cpp</code>. The <code class="highlighter-rouge">init_C()</code> / <code class="highlighter-rouge">PyInit__C()</code> function creates the module and adds the method definitions as appropriate. This module is passed around to a number of different <code class="highlighter-rouge">__init()</code> functions that add further objects to the module, register new types, etc.</p>

<p>One collection of these <code class="highlighter-rouge">__init()</code> calls is the following:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ASSERT_TRUE</span><span class="p">(</span><span class="n">THPDoubleTensor_init</span><span class="p">(</span><span class="n">module</span><span class="p">));</span>
<span class="n">ASSERT_TRUE</span><span class="p">(</span><span class="n">THPFloatTensor_init</span><span class="p">(</span><span class="n">module</span><span class="p">));</span>
<span class="n">ASSERT_TRUE</span><span class="p">(</span><span class="n">THPHalfTensor_init</span><span class="p">(</span><span class="n">module</span><span class="p">));</span>
<span class="n">ASSERT_TRUE</span><span class="p">(</span><span class="n">THPLongTensor_init</span><span class="p">(</span><span class="n">module</span><span class="p">));</span>
<span class="n">ASSERT_TRUE</span><span class="p">(</span><span class="n">THPIntTensor_init</span><span class="p">(</span><span class="n">module</span><span class="p">));</span>
<span class="n">ASSERT_TRUE</span><span class="p">(</span><span class="n">THPShortTensor_init</span><span class="p">(</span><span class="n">module</span><span class="p">));</span>
<span class="n">ASSERT_TRUE</span><span class="p">(</span><span class="n">THPCharTensor_init</span><span class="p">(</span><span class="n">module</span><span class="p">));</span>
<span class="n">ASSERT_TRUE</span><span class="p">(</span><span class="n">THPByteTensor_init</span><span class="p">(</span><span class="n">module</span><span class="p">));</span>
</code></pre></div></div>

<p>These <code class="highlighter-rouge">__init()</code> functions add the Tensor object for each type to the <code class="highlighter-rouge">._C</code> module so that they can be used in the module. Let’s learn how these methods work.</p>

<h2 id="the-thptensor-type">The THPTensor Type</h2>

<p>Much like the underlying <code class="highlighter-rouge">TH</code> and <code class="highlighter-rouge">THC</code> libraries, PyTorch defines a “generic” Tensor which is then specialized to a number of different types. Before considering how this specialization works, let’s first consider how defining a new type in Python works, and how we create the generic <code class="highlighter-rouge">THPTensor</code> type.</p>

<p>The Python runtime sees all Python objects as variables of type <code class="highlighter-rouge">PyObject *</code>, which serves as a “base type” for all Python objects. Every Python type contains the refcount for the object, and a pointer to the object’s <em>type object</em>. The type object determines the properties of the type. For example, it might contain a list of methods associated with the type, and which C functions get called to implement those methods. The object also contains any fields necessary to represent its state.</p>

<p>The formula for defining a new type is as follows:</p>

<ul>
  <li>Create a struct that defines what the new object will contain</li>
  <li>Define the type object for the type</li>
</ul>

<p>The struct itself could be very simple. Inn Python, all floating point types are actually objects on the heap. The Python float struct is defined as:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="kt">double</span> <span class="n">ob_fval</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PyFloatObject</span><span class="p">;</span>
</code></pre></div></div>
<p>The <code class="highlighter-rouge">PyObject_HEAD</code> is a macro that brings in the code that implements an object’s reference counting, and a pointer to the corresponding type object. So in this case, to implement a float, the only other “state” needed is the floating point value itself.</p>

<p>Now, let’s see the struct for our <code class="highlighter-rouge">THPTensor</code> type:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">THPTensor</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="n">THTensor</span> <span class="o">*</span><span class="n">cdata</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>
<p>Pretty simple, right? We are just wrapping the underlying <code class="highlighter-rouge">TH</code> tensor by storing a pointer to it.</p>

<p>The key part is defining the “type object” for a new type. An example definition of a type object for our Python float takes the form:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">PyTypeObject</span> <span class="n">py_FloatType</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="s">"py.FloatObject"</span><span class="p">,</span>          <span class="cm">/* tp_name */</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">PyFloatObject</span><span class="p">),</span>     <span class="cm">/* tp_basicsize */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_itemsize */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_dealloc */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_print */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_getattr */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_setattr */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_async */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_repr */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_number */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_sequence */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_mapping */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_hash  */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_call */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_str */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_getattro */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_setattro */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_buffer */</span>
    <span class="n">Py_TPFLAGS_DEFAULT</span><span class="p">,</span>        <span class="cm">/* tp_flags */</span>
    <span class="s">"A floating point number"</span><span class="p">,</span> <span class="cm">/* tp_doc */</span>
<span class="p">};</span>
</code></pre></div></div>
<p>The easiest way to think of a <em>type object</em> is as a set of fields which define the properties of the object. For example, the <code class="highlighter-rouge">tp_basicsize</code> field is set to <code class="highlighter-rouge">sizeof(PyFloatObject)</code>. This is so that Python knows how much memory to allocate when calling <code class="highlighter-rouge">PyObject_New()</code> for a <code class="highlighter-rouge">PyFloatObject.</code> The full list of fields you can set is defined in <code class="highlighter-rouge">object.h</code> in the CPython backend:
https://github.com/python/cpython/blob/master/Include/object.h.</p>

<p>The type object for our <code class="highlighter-rouge">THPTensor</code> is <code class="highlighter-rouge">THPTensorType</code>, defined in <code class="highlighter-rouge">csrc/generic/Tensor.cpp</code>. This object defines the name, size, mapping methods, etc. for a <code class="highlighter-rouge">THPTensor</code>.</p>

<p>As an example, let’s take a look at the <code class="highlighter-rouge">tp_new</code> function we set in the <code class="highlighter-rouge">PyTypeObject</code>:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PyTypeObject</span> <span class="n">THPTensorType</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">...</span>
  <span class="n">THPTensor_</span><span class="p">(</span><span class="n">pynew</span><span class="p">),</span> <span class="cm">/* tp_new */</span>
<span class="p">};</span>
</code></pre></div></div>
<p>The <code class="highlighter-rouge">tp_new</code> function enables object creation. It is responsible for creating (as opposed to initializing) objects of that type and is equivalent to the <code class="highlighter-rouge">__new__()</code> method at the Python level. The C implementation is a static method that is passed the type being instantiated and any arguments, and returns a newly created object.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span> <span class="nf">THPTensor_</span><span class="p">(</span><span class="n">pynew</span><span class="p">)(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwargs</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">HANDLE_TH_ERRORS</span>
  <span class="n">Py_ssize_t</span> <span class="n">num_args</span> <span class="o">=</span> <span class="n">args</span> <span class="o">?</span> <span class="n">PyTuple_Size</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">THPTensorPtr</span> <span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="n">THPTensor</span> <span class="o">*</span><span class="p">)</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">tp_alloc</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">// more code below
</span></code></pre></div></div>
<p>The first thing our new function does is allocate the <code class="highlighter-rouge">THPTensor</code>. It then runs through a series of initializations based off of the args passed to the function. For example, when creating a <code class="highlighter-rouge">THPTensor</code> <em>x</em> from another <code class="highlighter-rouge">THPTensor</code> <em>y</em>, we set the newly created <code class="highlighter-rouge">THPTensor</code>’s <code class="highlighter-rouge">cdata</code> field to be the result of calling <code class="highlighter-rouge">THTensor_(newWithTensor)</code> with the <em>y</em>’s underlying <code class="highlighter-rouge">TH</code> Tensor as an argument. Similar constructors exist for sizes, storages, NumPy arrays, and sequences.</p>

<p>** Note that we solely use <code class="highlighter-rouge">tp_new</code>, and not a combination of <code class="highlighter-rouge">tp_new</code> and <code class="highlighter-rouge">tp_init</code> (which corresponds to the <code class="highlighter-rouge">__init__()</code> function).</p>

<p>The other important thing defined in Tensor.cpp is how indexing works. PyTorch Tensors support Python’s <strong>Mapping Protocol</strong>. This allows us to do things like:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">fill_</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">//</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">1</span>
<span class="n">x</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="o">//</span> <span class="n">etc</span><span class="o">.</span>
</code></pre></div></div>
<p>** Note that this indexing extends to Tensor with more than one dimension</p>

<p>We are able to use the <code class="highlighter-rouge">[]</code>-style notation by defining the three mapping methods described <a href="https://docs.python.org/3.7/c-api/typeobj.html#c.PyMappingMethods">here.</a></p>

<p>The most important methods are <code class="highlighter-rouge">THPTensor_(getValue)</code> and <code class="highlighter-rouge">THPTensor_(setValue)</code> which describe how to index a Tensor, for returning a new Tensor/Scalar, or updating the values of an existing Tensor in place. Read through these implementations to better understand how PyTorch supports basic tensor indexing.</p>

<h3 id="generic-builds-part-one">Generic Builds (Part One)</h3>

<p>We could spend a ton of time exploring various aspects of the <code class="highlighter-rouge">THPTensor</code> and how it relates to defining a new Python object. But we still need to see how the <code class="highlighter-rouge">THPTensor_(init)()</code> function is translated to the <code class="highlighter-rouge">THPIntTensor_init()</code> we used in our module initialization. How do we take our <code class="highlighter-rouge">Tensor.cpp</code> file that defines a “generic” Tensor and use it to generate Python objects for all the permutations of types? To put it another way, <code class="highlighter-rouge">Tensor.cpp</code> is littered with lines of code like:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">return</span> <span class="n">THPTensor_</span><span class="p">(</span><span class="n">New</span><span class="p">)(</span><span class="n">THTensor_</span><span class="p">(</span><span class="k">new</span><span class="p">)(</span><span class="n">LIBRARY_STATE_NOARGS</span><span class="p">));</span>
</code></pre></div></div>
<p>This illustrates both cases we need to make type-specific:</p>

<ul>
  <li>Our output code will call <code class="highlighter-rouge">THP&lt;Type&gt;Tensor_New(...)</code> in place of <code class="highlighter-rouge">THPTensor_(New)</code></li>
  <li>Our output code will call <code class="highlighter-rouge">TH&lt;Type&gt;Tensor_new(...)</code> in place of <code class="highlighter-rouge">THTensor_(new)</code></li>
</ul>

<p>In other words, for all supported Tensor types, we need to “generate” source code that has done the above substitutions. This is part of the “build” process for PyTorch. PyTorch relies on Setuptools (https://setuptools.readthedocs.io/en/latest/) for building the package, and we define a <code class="highlighter-rouge">setup.py</code> file in the top-level directory to customize the build process.</p>

<p>One component building an Extension module using Setuptools is to list the source files involved in the compilation. However, our <code class="highlighter-rouge">csrc/generic/Tensor.cpp</code> file is not listed! So how does the code in this file end up being a part of the end product?</p>

<p>Recall that we are calling the <code class="highlighter-rouge">THPTensor*</code> functions (such as <code class="highlighter-rouge">init</code>) from the directory above <code class="highlighter-rouge">generic</code>. If we take a look in this directory, there is another file <code class="highlighter-rouge">Tensor.cpp</code> defined. The last line of this file is important:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//generic_include TH torch/csrc/generic/Tensor.cpp
</span></code></pre></div></div>
<p>Note that this <code class="highlighter-rouge">Tensor.cpp</code> file is included in <code class="highlighter-rouge">setup.py</code>, but it is wrapped in a call to a Python helper function called <code class="highlighter-rouge">split_types</code>. This function takes as input a file, and looks for the “//generic_include” string in the file contents. If it is found, it generates a new output file for each Tensor type, with the following changes:</p>

<ul>
  <li>The output file is renamed to <code class="highlighter-rouge">Tensor&lt;Type&gt;.cpp</code></li>
  <li>The output file is slightly modified as follows:</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp"># Before:
</span><span class="c1">//generic_include TH torch/csrc/generic/Tensor.cpp
</span>
<span class="cp"># After:
#define TH_GENERIC_FILE "torch/src/generic/Tensor.cpp"
#include "TH/THGenerate&lt;Type&gt;Type.h"
</span></code></pre></div></div>
<p>Including the header file on the second line has the side effect of including the source code in <code class="highlighter-rouge">Tensor.cpp</code> with some additional context defined. Let’s take a look at one of the headers:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef TH_GENERIC_FILE
#error "You must define TH_GENERIC_FILE before including THGenerateFloatType.h"
#endif
</span>
<span class="cp">#define real float
#define accreal double
#define TH_CONVERT_REAL_TO_ACCREAL(_val) (accreal)(_val)
#define TH_CONVERT_ACCREAL_TO_REAL(_val) (real)(_val)
#define Real Float
#define THInf FLT_MAX
#define TH_REAL_IS_FLOAT
#line 1 TH_GENERIC_FILE
#include TH_GENERIC_FILE
#undef accreal
#undef real
#undef Real
#undef THInf
#undef TH_REAL_IS_FLOAT
#undef TH_CONVERT_REAL_TO_ACCREAL
#undef TH_CONVERT_ACCREAL_TO_REAL
</span>
<span class="cp">#ifndef THGenerateManyTypes
#undef TH_GENERIC_FILE
#endif
</span></code></pre></div></div>

<p>What this is doing is bringing in the code from the generic <code class="highlighter-rouge">Tensor.cpp</code> file and surrounding it with the following macro definitions. For example, we define real as a float, so any code in the generic Tensor implementation that refers to something as a real will have that real replaced with a float. In the corresponding file <code class="highlighter-rouge">THGenerateIntType.h</code>, the same macro would replace <code class="highlighter-rouge">real</code> with <code class="highlighter-rouge">int</code>.</p>

<p>These output files are returned from <code class="highlighter-rouge">split_types</code> and added to the list of source files, so we can see how the <code class="highlighter-rouge">.cpp</code> code for different types is created.</p>

<p>There are a few things to note here: First, the <code class="highlighter-rouge">split_types</code> function is not strictly necessary. We could wrap the code in <code class="highlighter-rouge">Tensor.cpp</code> in a single file, repeating it for each type. The reason we split the code into separate files is to speed up compilation. Second, what we mean when we talk about the type replacement (e.g. replace real with a float) is that the C preprocessor will perform these substitutions during compilation. Merely surrounding the source code with these macros has no side effects until preprocessing.</p>

<h3 id="generic-builds-part-two">Generic Builds (Part Two)</h3>

<p>Now that we have source files for all the Tensor types, we need to consider how the corresponding header declarations are created, and also how the conversions from <code class="highlighter-rouge">THTensor_(method)</code> and <code class="highlighter-rouge">THPTensor_(method)</code> to <code class="highlighter-rouge">TH&lt;Type&gt;Tensor_method</code> and <code class="highlighter-rouge">THP&lt;Type&gt;Tensor_method</code> work. For example, <code class="highlighter-rouge">csrc/generic/Tensor.h</code> has declarations like:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">THP_API</span> <span class="n">PyObject</span> <span class="o">*</span> <span class="n">THPTensor_</span><span class="p">(</span><span class="n">New</span><span class="p">)(</span><span class="n">THTensor</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
</code></pre></div></div>
<p>We use the same strategy for generating code in the source files for the headers. In <code class="highlighter-rouge">csrc/Tensor.h</code>, we do the following:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include "generic/Tensor.h"
#include &lt;TH/THGenerateAllTypes.h&gt;
</span>
<span class="cp">#include "generic/Tensor.h"
#include &lt;TH/THGenerateHalfType.h&gt;
</span></code></pre></div></div>
<p>This has the same effect, where we draw in the code from the generic header, wrapped with the same macro definitions, for each type. The only difference is that the resulting code is contained all within the same header file, as opposed to being split into multiple source files.</p>

<p>Lastly, we need to consider how we “convert” or “substitute” the function types. If we look in the same header file, we see a bunch of <code class="highlighter-rouge">#define</code> statements, including:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define THPTensor_(NAME)            TH_CONCAT_4(THP,Real,Tensor_,NAME)
</span></code></pre></div></div>
<p>This macro says that any string in the source code matching the format <code class="highlighter-rouge">THPTensor_(NAME)</code> should be replaced with <code class="highlighter-rouge">THPRealTensor_NAME</code>, where Real is derived from whatever the symbol Real is <code class="highlighter-rouge">#define</code>‘d to be at the time. Because our header code and source code is surrounded by macro definitions for all the types as seen above, after the preprocessor has run, the resulting code is what we would expect. The code in the <code class="highlighter-rouge">TH</code> library defines the same macro for <code class="highlighter-rouge">THTensor_(NAME)</code>, supporting the translation of those functions as well. In this way, we end up with header and source files with specialized code.</p>

<h4 id="module-objects-and-type-methods">Module Objects and Type Methods</h4>

<p>Now we have seen how we have wrapped <code class="highlighter-rouge">TH</code>’s Tensor definition in <code class="highlighter-rouge">THP</code>, and generated THP methods such as <code class="highlighter-rouge">THPFloatTensor_init(...)</code>. Now we can explore what the above code actually does in terms of the module we are creating. The key line in <code class="highlighter-rouge">THPTensor_(init)</code> is:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp"># THPTensorBaseStr, THPTensorType are also macros that are specific
# to each type
</span><span class="n">PyModule_AddObject</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">THPTensorBaseStr</span><span class="p">,</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">THPTensorType</span><span class="p">);</span>
</code></pre></div></div>
<p>This function registers our Tensor objects to the extension module, so we can use THPFloatTensor, THPIntTensor, etc. in our Python code.</p>

<p>Just being able to create Tensors isn’t very useful - we need to be able to call all the methods that <code class="highlighter-rouge">TH</code> defines. A simple example shows calling the in-place <code class="highlighter-rouge">zero_</code> method on a Tensor.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">FloatTensor</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">x</span><span class="o">.</span><span class="n">zero_</span><span class="p">()</span>
</code></pre></div></div>
<p>Let’s start by seeing how we add methods to newly defined types. One of the fields in the “type object” is <code class="highlighter-rouge">tp_methods</code>. This field holds an array of method definitions (<code class="highlighter-rouge">PyMethodDef</code>s) and is used to associate methods (and their underlying C/C++ implementations) with a type. Suppose we wanted to define a new method on our <code class="highlighter-rouge">PyFloatObject</code> that replaces the value. We could implement this as follows:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span> <span class="nf">replace</span><span class="p">(</span><span class="n">PyFloatObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">double</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyArg_ParseTuple</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="s">"d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">ob_fval</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">Py_RETURN_NONE</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This is equivalent to the Python method:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">ob_fval</span> <span class="o">=</span> <span class="n">val</span>
</code></pre></div></div>
<p>It is instructive to read more about how defining methods works in CPython. In general, methods take as the first parameter the instance of the object, and optionally parameters for the positional arguments and keyword arguments. This static function is registered as a method on our float:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">PyMethodDef</span> <span class="n">float_methods</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="s">"replace"</span><span class="p">,</span> <span class="p">(</span><span class="n">PyCFunction</span><span class="p">)</span><span class="n">replace</span><span class="p">,</span> <span class="n">METH_VARARGS</span><span class="p">,</span>
	<span class="s">"replace the value in the float"</span>
	<span class="p">},</span>
	<span class="p">{</span><span class="nb">NULL</span><span class="p">}</span> <span class="cm">/* Sentinel */</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This registers a method called replace, which is implemented by the C function of the same name. The <code class="highlighter-rouge">METH_VARARGS</code> flag indicates that the method takes a tuple of arguments representing all the arguments to the function. This array is set to the <code class="highlighter-rouge">tp_methods</code> field of the type object, and then we can use the <code class="highlighter-rouge">replace</code> method on objects of that type.</p>

<p>We would like to be able to call all of the methods for <code class="highlighter-rouge">TH</code> tensors on our <code class="highlighter-rouge">THP</code> tensor equivalents. However, writing wrappers for all of the <code class="highlighter-rouge">TH</code> methods would be time-consuming and error prone. We need a better way to do this.</p>

<h3 id="pytorch-cwrap">PyTorch cwrap</h3>

<p>PyTorch implements its own cwrap tool to wrap the <code class="highlighter-rouge">TH</code> Tensor methods for use in the Python backend. We define a <code class="highlighter-rouge">.cwrap</code> file containing a series of C method declarations in our custom <a href="http://yaml.org">YAML format</a>. The cwrap tool takes this file and outputs <code class="highlighter-rouge">.cpp</code> source files containing the wrapped methods in a format that is compatible with our <code class="highlighter-rouge">THPTensor</code> Python object and the Python C extension method calling format. This tool is used to generate code to wrap not only <code class="highlighter-rouge">TH</code>, but also <code class="highlighter-rouge">CuDNN</code>. It is defined to be extensible.</p>

<p>An example YAML “declaration” for the in-place <code class="highlighter-rouge">addmv_</code> function is as follows:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[[
  name: addmv_
  cname: addmv
  return: self
  arguments:
    - THTensor* self
    - arg: real beta
      default: AS_REAL(1)
    - THTensor* self
    - arg: real alpha
      default: AS_REAL(1)
    - THTensor* mat
    - THTensor* vec
]]
</code></pre></div></div>
<p>The architecture of the cwrap tool is very simple. It reads in a file, and then processes it with a series of <strong>plugins.</strong> See <code class="highlighter-rouge">tools/cwrap/plugins/__init__.py</code> for documentation on all the ways a plugin can alter the code.</p>

<p>The source code generation occurs in a series of passes. First, the YAML “declaration” is parsed and processed. Then the source code is generated piece-by-piece - adding things like argument checks and extractions, defining the method header, and the actual call to the underlying library such as <code class="highlighter-rouge">TH</code>. Finally, the cwrap tool allows for processing the entire file at a time. The resulting output for <code class="highlighter-rouge">addmv_</code> can be <a href="https://gist.github.com/killeent/c00de46c2a896335a52552604cc4d74b">explored here</a>.</p>

<p>In order to interface with the CPython backend, the tool generates an array of <code class="highlighter-rouge">PyMethodDef</code>s that can be stored or appended to the <code class="highlighter-rouge">THPTensor</code>’s <code class="highlighter-rouge">tp_methods</code> field.</p>

<p>In the specific case of wrapping Tensor methods, the build process first generates the output source file from <code class="highlighter-rouge">TensorMethods.cwrap</code>. This source file is <code class="highlighter-rouge">#include</code>‘d in the generic Tensor source file. This all occurs before the preprocessor does its magic. As a result, all of the method wrappers that are generated undergo the same pass as the <code class="highlighter-rouge">THPTensor</code> code above. Thus a single generic declaration and definition is specialized for each type as well.</p>

<h3 id="putting-it-all-together">Putting It All Together</h3>

<p>So far, we have shown how we extend the Python interpreter to create a new extension module, how such a module defines our new <code class="highlighter-rouge">THPTensor</code> type, and how we can generate source code for Tensors of all types that interface with <code class="highlighter-rouge">TH</code>. Briefly, we will touch on compilation.</p>

<p>Setuptools allows us to define an Extension for compilation. The entire <code class="highlighter-rouge">torch._C</code> extension is compiled by collecting all of the source files, header files, libraries, etc. and creating a setuptools <code class="highlighter-rouge">Extension</code>. Then setuptools handles building the extension itself. I will explore the build process more in a subsequent post.</p>

<p>To summarize, let’s revisit our four questions:</p>

<ul>
  <li><strong>How does PyTorch extend the Python interpreter to define a Tensor type that can be manipulated from Python code?</strong></li>
</ul>

<p>It uses CPython’s framework for extending the Python interpreter and defining new types, while taking special care to generate code for all types.</p>

<ul>
  <li><strong>How does PyTorch wrap the C libraries that actually define the Tensor’s properties and methods?</strong></li>
</ul>

<p>It does so by defining a new type, <code class="highlighter-rouge">THPTensor</code>, that is backed by a <code class="highlighter-rouge">TH</code> Tensor. Function calls are forwarded to this tensor via the CPython backend’s conventions.</p>

<ul>
  <li><strong>How does PyTorch cwrap work to generate code for Tensor methods?</strong></li>
</ul>

<p>It takes our custom YAML-formatted code and generates source code for each method by processing it through a series of steps using a number of plugins.</p>

<ul>
  <li><strong>How does PyTorch’s build system take all of these components to compile and generate a workable application?</strong></li>
</ul>

<p>It takes a bunch of source/header files, libraries, and compilation directives to build an extension using Setuptools.</p>

<p>This is just a snapshot of parts of the build system for PyTorch. There is more nuance, and detail, but I hope this serves as a gentle introduction to a lot of the components of our Tensor library.</p>

<h3 id="resources">Resources:</h3>

<ul>
  <li><a href="https://docs.python.org/3.7/extending/index.html">https://docs.python.org/3.7/extending/index.html</a> is invaluable for understanding how to write C/C++ Extension to Python</li>
</ul>

                </article>
            </div>
        </div>
    </div>

<!--    


 -->
    <div class="container-fluid docs-tutorials-resources">
  <div class="container">
    <div class="row">
      <div class="col-md-4 text-center">
        <h2>Docs</h2>
        <p>Access comprehensive developer documentation for PyTorch</p>
        <a class="with-right-arrow" href="https://pytorch.org/docs">View Docs</a>
      </div>

      <div class="col-md-4 text-center">
        <h2>Tutorials</h2>
        <p>Get in-depth tutorials for beginners and advanced developers</p>
        <a class="with-right-arrow" href="https://pytorch.org/tutorials">View Tutorials</a>
      </div>

      <div class="col-md-4 text-center">
        <h2>Resources</h2>
        <p>Find development resources and get your questions answered</p>
        <a class="with-right-arrow" href="/resources">View Resources</a>
      </div>
    </div>
  </div>
</div>

<footer class="site-footer">
  <div class="container footer-container">
    <div class="footer-logo-wrapper">
      <a href="https://pytorch.org" class="footer-logo"></a>
    </div>

    <div class="footer-links-wrapper">
      <div class="footer-links-col">
        <ul>
          <li class="list-title"><a href="https://pytorch.org">PyTorch</a></li>
          <li><a href="/get-started">Get Started</a></li>
          <li><a href="/features">Features</a></li>
          <li><a href="/ecosystem">Ecosystem</a></li>
          <li><a href="/blog">Blog</a></li>
          <li><a href="https://github.com/pytorch/pytorch/blob/master/CONTRIBUTING.md" target="_blank">Contributing</a></li>
        </ul>
      </div>

      <div class="footer-links-col">
        <ul>
          <li class="list-title"><a href="/resources">Resources</a></li>
          <li><a href="https://pytorch.org/tutorials">Tutorials</a></li>
          <li><a href="https://pytorch.org/docs">Docs</a></li>
          <li><a href="https://discuss.pytorch.org" target="_blank">Discuss</a></li>
          <li><a href="https://github.com/pytorch/pytorch/issues" target="_blank">GitHub Issues</a></li>
          <li><a href="https://pytorch.slack.com" target="_blank">Slack</a></li>
        </ul>
      </div>

      <div class="footer-links-col follow-us-col">
        <ul>
          <li class="list-title">Stay Connected</li>
          <li>
            
            <div id="mc_embed_signup">
  <form
    action="https://twitter.us14.list-manage.com/subscribe/post?u=75419c71fe0a935e53dfa4a3f&id=91d0dccd39"
    method="post"
    id="mc-embedded-subscribe-form"
    name="mc-embedded-subscribe-form"
    class="email-subscribe-form validate"
    target="_blank"
    novalidate>
    <div id="mc_embed_signup_scroll" class="email-subscribe-form-fields-wrapper">
      <div class="mc-field-group">
        <label for="mce-EMAIL" style="display:none;">Email Address</label>
        <input type="email" value="" name="EMAIL" class="required email" id="mce-EMAIL" placeholder="Email Address">
      </div>

      <div id="mce-responses" class="clear">
        <div class="response" id="mce-error-response" style="display:none"></div>
        <div class="response" id="mce-success-response" style="display:none"></div>
      </div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->

      <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_75419c71fe0a935e53dfa4a3f_91d0dccd39" tabindex="-1" value=""></div>

      <div class="clear">
        <input type="submit" value="" name="subscribe" id="mc-embedded-subscribe" class="button email-subscribe-button">
      </div>
    </div>
  </form>
</div>

          </li>
        </ul>

        <div class="footer-social-icons">
          <a href="https://www.facebook.com/pytorch" target="_blank" class="facebook"></a>
          <a href="https://twitter.com/pytorch" target="_blank" class="twitter"></a>
        </div>
      </div>
    </div>
  </div>
</footer>

<div class="mobile-main-menu">
  <div class="container-fluid">
    <div class="container">
      <div class="mobile-main-menu-header-container">
        <a class="header-logo" href="https://pytorch.org" aria-label="PyTorch"></a>
        <a class="main-menu-close-button" href="#" data-behavior="close-mobile-menu"></a>
      </div>
    </div>
  </div>

  <div class="mobile-main-menu-links-container">
    <div class="main-menu">
  <ul>
    <li class="">
      <a href="/get-started">Get Started</a>
    </li>

    <li class="">
      <a href="/features">Features</a>
    </li>

    <li class="">
      <a href="/ecosystem">Ecosystem</a>
    </li>

    <li class="active">
      <a href="/blog">Blog</a>
    </li>

    <li>
      <a href="https://pytorch.org/tutorials">Tutorials</a>
    </li>

    <li>
      <a href="https://pytorch.org/docs">Docs</a>
    </li>

    <li class="">
      <a href="/resources">Resources</a>
    </li>

    <li>
      <a href="https://github.com/pytorch/pytorch">Github</a>
    </li>
  </ul>
</div>

  </div>
</div>


<script src="/assets/mobile-menu.js"></script>
<script src="/assets/scroll-to-anchor.js"></script>
<script src="/assets/external-links-new-tab.js"></script>

<script type="text/javascript">
  mobileMenu.bind();
  anchors.add('.pytorch-article h2, .pytorch-article h3, .pytorch-article h4, .pytorch-article h5');

  // Add class to links that have code blocks, since we cannot create links in code blocks
  $("a code.highlighter-rouge").each(function(e) {
    $(this).closest("a").addClass("has-code");
  });

  scrollToAnchor.bind();

  var hasStaticHeader = $(".blog-header, .blog-detail-header, .resources-header").length > 0;

  if (!hasStaticHeader) {
    $(window).on("scroll", function() {
      var top = $(this).scrollTop();
      var fullPosition = $(".main-background").height() - $(".header-holder").height();

      if (top === 0) {
        $(".header-holder").css({"backgroundColor": "transparent"});
      } else if (top >= fullPosition) {
        $(".header-holder").css({"backgroundColor": "#000000"});
      } else {
        var bgColor = "rgba(0, 0, 0, " + top / fullPosition + ")";
        $(".header-holder").css({"backgroundColor": bgColor});
      }
    });
  }
</script>



</body>

</html>
